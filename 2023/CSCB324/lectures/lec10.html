<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <title>lec10</title>
  </head>
  <body>
    <h2>10. Търсене. Последователно и двоично търсене. Търсене с връщане</h2>
    <p><i>План: </i><br>
      <i>Задачи 9 и 10</i><br>
      Последователно търсене<br>
      Двоично търсене (разделай и владей)<br>
      Класификация на задачите <br>
      Tърсене с връщане<br>
      -- Разходка на коня<br>
      -- Задача за осемте царици<br>
      <i>Задачи 11 и 12</i><br>
    </p>
    <hr width="100%" size="2">
    <h3><font color="#000000">Последователно търсене [4, стр. 231]<br>
      </font></h3>
    <big>** Човешката дейност търсене<br>
      <br>
      ** Опростен модел на търсене<br>
      <br>
      ** Фундаментални операции над елемнтите на множество (правилна
      оценка на ефективността на алгоритмите за търсене)<br>
      -- инициализиране<br>
      -- търсене<br>
      -- вмъкване<br>
      -- изтриване<br>
      -- обединяване на множества<br>
      --&nbsp; сортиране.<br>
      <br>
      ** Ключ, повтарящи се ключове<br>
      -- има ли елемент с даден ключ? <span style="font-family:
        monospace;">[bool exists(unsigned key)]</span><br>
      -- индекс на елемент (обект) с даден ключ? <span
        style="font-family: monospace;">[unsigned find_one(unsigned
        key)]<br>
      </span>-- брой елементи с даден ключ? <span style="font-family:
        monospace;">[unsigned count(unsigned key)]</span><br>
      -- индекси на всички елементи (обекти) с даден ключ? <span
        style="font-family: monospace;">[vector&lt;unsigned&gt;
        find_all(unsigned key)]</span><br>
      <br>
      ** Последователно (линейно) търсене<br>
      Проверяваме последователно елементите на множеството (което е
      линейно наредено), докато или намерим търсения елемент или стигнем
      до края на редицата. <br>
      Ефективност на алгоритъма за линейно търсене:<br>
      Броят на обръщенията към елементите на масива зависи от търсеното
      число, но в най-лошия случай, когато числото не се среща в масива,
      е равен на дължината на масива. Следователно сложността на
      алгоритъма е <i>O</i>(<i>n</i>). <br>
    </big><b><tt><font color="#993300">// <a href="sources/lsearch.cpp"><big>lsearch.cpp</big></a></font></tt></b><a
      href="sources/lsearch.cpp"><big> </big></a><b><tt><font
          color="#000099"><br>
        </font></tt></b>
    <p><font size="+1"><b><tt><font color="#000099">int
              linear_search(vector&lt;int&gt; v, int a)</font></tt></b><br>
        <b><tt><font color="#000099">{</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;&nbsp; int i;</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;&nbsp; for (i = 0; i &lt;
              v.size(); i++)</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;




















              if (v[i] == a) return i;</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;&nbsp; return -1;</font></tt></b><br>
        <b><tt><font color="#000099">}</font></tt></b></font> </p>
    <big>** Последователно търсене в сортиран списък с поддържане на
      сортирания списък при вмъкване на нов елемент.</big><br>
    <hr width="100%" size="2">
    <h3>Двоично търсене (разделай и владей) [4.3, стр. 239] (<a
        href="https://en.wikipedia.org/wiki/Binary_search_algorithm">Binary



        search algorithm</a>)<br>
    </h3>
    <p><b><tt><font color="#993300">// <a href="sources/bsearch.cpp"><big>bsearch.cpp</big></a></font></tt></b><a
        href="sources/bsearch.cpp"><big> </big></a><b><tt><font
            color="#000099"><br>
          </font></tt></b></p>
    <p><font size="+1"><b><tt><font color="#000099">int
              binary_search(vector&lt;int&gt; v, int from, int to, int
              a)</font></tt></b><br>
        <b><tt><font color="#000099">{</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;&nbsp; if (from &gt;
              to)&nbsp; return -1;</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;&nbsp; int mid = (from + to)
              / 2;</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;&nbsp; int diff = v[mid] - a;</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;&nbsp; if (diff == 0) return
              mid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              /* v[mid] == a */</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;&nbsp; else if (diff &lt;
              0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;




















              /* v[mid] &lt; a */</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              return binary_search(v, mid + 1, to, a);</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;&nbsp; else</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              return binary_search(v, from, mid - 1, a);</font></tt></b><br>
        <b><tt><font color="#000099">}</font></tt></b></font> </p>
    <p><font size="+1">Търсене и сортиране на реални данни </font><br>
      <b><tt><font color="#993300">// <a href="sources/esearch.cpp"><big>esearch.cpp</big></a></font></tt></b><a
        href="sources/esearch.cpp"><big> </big></a><br>
    </p>
    <p><font size="+1"><b><tt><font color="#000099">int
              binary_search(vector&lt;Employee&gt; v, int from, int to,
              string n)</font></tt></b><br>
        <b><tt><font color="#000099">{</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;&nbsp; if (from &gt; to)
              return -1;</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;&nbsp; int mid = (from + to)
              / 2;</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;&nbsp; if (v[mid].get_name()
              == n)&nbsp; return mid;</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;&nbsp; else if
              (v[mid].get_name() &lt; n)</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              return binary_search(v, mid + 1, to, n);</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;&nbsp; else</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              return binary_search(v, from, mid - 1, n);</font></tt></b><br>
        <b><tt><font color="#000099">}<br>
            </font></tt></b></font></p>
    <p><font size="+1"><font color="#000099">Търсене на корен на урав</font></font><font
        size="+1"><font color="#000099">нение</font></font><font
        size="+1"><font color="#000099"> с произволна точност</font></font><font
        size="+1"><b><tt><font color="#000099"><br>
            </font></tt></b></font> </p>
    <h3><span style="font-weight: bold;"></span></h3>
    <hr width="100%" size="2">
    <h3><span style="font-weight: bold;"></span></h3>
    <h3><span style="font-weight: bold;">Класификация на задачите [6.1]</span></h3>
    <span style="font-weight: bold;">Сложност по време </span>[6.1.1] <br>
    NP- задачи: Класът на полиномиално проверимите задачи<br>
    P- задачи: Съществува решение с полиномиална сложност<br>
    P = NP ???&nbsp;&nbsp; <a
      href="https://en.wikipedia.org/wiki/P_versus_NP_problem">(P versus
      NP problem)</a><br>
    <br>
    Експоненциални задачи: Съществува алгоритъм с експоненциална
    сложност<br>
    <span style="font-weight: bold;"><br>
      Сложност по паме</span>т <span style="font-weight: bold;"> </span>[6.1.2]

    <br>
    <br>
    <span style="font-weight: bold;">Нерешими задачи</span> <span
      style="font-weight: bold;"> </span>[6.1.3] <br>
    Задачи, за които съществува доказателство, че не могат да бъдат
    решени, независимо от това с колко време и памет разполагаме. <br>
    <span style="font-weight: bold;"><br>
      Примери</span> [6.1.4] <br>
    Полиномиално решими задачи: търсене, сортиране, ...<br>
    NP- задачи: Съществуване на делител на цяло положително число,
    по-малък от зададено число. <br>
    <br>
    Класификация по памет: игра на шах<br>
    <br>
    Нерешими задачи: Дали дадена програма е в безкраен цикъл (<a
href="https://bg.wikipedia.org/wiki/%D0%9F%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BD%D0%B0_%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%BD%D0%B0_%D0%A4%D0%B5%D1%80%D0%BC%D0%B0">Голямата







      теорема на Ферма</a>).<br>
    <br>
    <span style="font-family: monospace;">int main()</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">{</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; unsigned a,
      b , c, n, u;</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; for (u =
      3;;)</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; {</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; for (a = 1; a &lt; u; a++)</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (b = 1; b &lt; u; b++)</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (c=1;
      c &lt; u; c++)</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; for (n=3; n &lt; u; n++)</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pow(a, n) + pow(b, n) ==
      pow(c, n)) exit(0);</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; u++;</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; }</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; return 0;</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">}<br>
    </span>&nbsp;<br>
    Неопределени задачи: <br>
    -- Задача на Сколем (<a
      href="https://en.wikipedia.org/wiki/Skolem_problem">Skolem problem</a>)<br>
    -- За дадена матрица дали съществува число <span style="font-style:
      italic;">n</span> такова, че матрицата, повдигната на степен <i>n</i>
    съдържа нула в горния десен ъгъл.<br>
    <br>
    <span style="font-weight: bold;"><a
        href="https://en.wikipedia.org/wiki/NP-completeness">NP-пълни
        задачи</a> [6.2] </span><br>
    <span style="font-weight: bold;"></span>
    <hr width="100%" size="2">
    <h3><span style="font-weight: bold;">Търсене с връщане [6.3]</span></h3>
    <span style="font-weight: bold;">Разходка на коня</span> [6.3.4] (<a
      href="https://en.wikipedia.org/wiki/Knight%27s_tour">Knight's tour</a>)<br>
    <br>
    <span style="font-family: monospace;">// <a href="sources/knight.c">knight.c</a><br>
      #include &lt;stdio.h&gt;</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">#include &lt;stdlib.h&gt;</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;"></span><br style="font-family:
      monospace;">
    <span style="font-family: monospace;">#define MAXN 10</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;"></span><br style="font-family:
      monospace;">
    <span style="font-family: monospace;">#define MAXD 10</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;"></span><br style="font-family:
      monospace;">
    <span style="font-family: monospace;">const unsigned n = 6;</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;"></span><br style="font-family:
      monospace;">
    <span style="font-family: monospace;">const unsigned startX = 1;</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">const unsigned startY = 1;</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;"></span><br style="font-family:
      monospace;">
    <span style="font-family: monospace;">const unsigned maxDiff = 8;</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">const int diffX[MAXD] = { 1,
      1, -1, -1, 2, -2, 2, -2 };</span><br style="font-family:
      monospace;">
    <span style="font-family: monospace;">const int diffY[MAXD] = { 2,
      -2, 2, -2, 1, 1, -1, -1 };</span><br style="font-family:
      monospace;">
    <br style="font-family: monospace;">
    <span style="font-family: monospace;">unsigned board[MAXN][MAXN];</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">unsigned newX, newY;</span><br
      style="font-family: monospace;">
    <br style="font-family: monospace;">
    <span style="font-family: monospace;">void printBoard(void)</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">{ unsigned i, j;</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; for (i = n; i &gt; 0;
      i--) {</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; for (j = 0;
      j &lt; n; j++) printf("%3u", board[i-1][j]);</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
      printf("\n");</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; }</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; exit(0); </span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">}</span><br
      style="font-family: monospace;">
    <br style="font-family: monospace;">
    <span style="font-family: monospace;">void nextMove(unsigned X,
      unsigned Y, unsigned i)</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">{ unsigned k;</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; board[X][Y] = i;</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; if (i == n * n) {
      printBoard(); return; }</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; for (k = 0; k &lt;
      maxDiff; k++) {</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; newX = X +
      diffX[k]; newY = Y + diffY[k];</span><br style="font-family:
      monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; if ((newX
      &gt;= 0 &amp;&amp; newX &lt; n &amp;&amp; newY &gt;= 0 &amp;&amp;
      newY &lt; n) &amp;&amp; (0 == board[newX][newY]))</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      nextMove(newX, newY, i + 1);</span><br style="font-family:
      monospace;">
    <span style="font-family: monospace;">&nbsp; }</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; board[X][Y] = 0;</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">}</span><br
      style="font-family: monospace;">
    <br style="font-family: monospace;">
    <span style="font-family: monospace;">int main(void) {</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; unsigned i, j;</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; for (i = 0; i &lt; n;
      i++)</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; for (j = 0;
      j &lt; n; j++) board[i][j] = 0;</span><br style="font-family:
      monospace;">
    <span style="font-family: monospace;">&nbsp; nextMove(startX-1,
      startY-1, 1);</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; printf("No solution.
      \n");</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; return 0;</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">}</span><br>
    <br>
    <span style="font-weight: bold;">Задача за осемте царици</span>
    [6.3.5] (<a href="https://en.wikipedia.org/wiki/Eight_queens_puzzle">Eight



      queens puzzle</a>)<br>
    <br>
    <tt>// <a href="sources/queens.c">queens.c</a></tt><br>
    <span style="font-family: monospace;">#include&lt;stdio.h&gt;</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">#include&lt;stdlib.h&gt;</span><br
      style="font-family: monospace;">
    <br style="font-family: monospace;">
    <span style="font-family: monospace;">#define MAXN 100</span><br
      style="font-family: monospace;">
    <br style="font-family: monospace;">
    <span style="font-family: monospace;">const unsigned n = 13;</span><br
      style="font-family: monospace;">
    <br style="font-family: monospace;">
    <span style="font-family: monospace;">unsigned col[MAXN] , RD[2*MAXN
      - 1],</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;



















      LD[2*MAXN], queens [MAXN];</span><br style="font-family:
      monospace;">
    <br style="font-family: monospace;">
    <span style="font-family: monospace;">void printBoard()</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">{ unsigned i , j ;</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; for (i = 0; i &lt; n;
      i++) {</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
      printf("\n");</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; for (j = 0;
      j &lt; n; j++)</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      if(queens[i] == j) printf("x ");</span><br style="font-family:
      monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      else printf(". ");</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; }</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; printf("\n");</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; exit(0);</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">}</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;"></span><br style="font-family:
      monospace;">
    <span style="font-family: monospace;">void generate(unsigned i)</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">{ if(i == n) printBoard();</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; unsigned
      k;&nbsp;&nbsp;&nbsp; </span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; for (k = 0; k &lt;= n;
      k++) {</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; if (col[k]
      &amp;&amp; RD[i + k] &amp;&amp; LD[n + i - k]) {</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      col[k] = 0; RD[i + k] = 0; LD[n + i - k] = 0; queens[i] = k;</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      generate(i + 1);</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      col[k] = 1; RD[i + k] = 1; LD[n + i - k] = 1;</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; }</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; }</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">}</span><br
      style="font-family: monospace;">
    <br style="font-family: monospace;">
    <span style="font-family: monospace;">int main(void) {</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; unsigned i;</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; for (i = 0; i &lt; n;
      i++) col[i] = 1;</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; for (i = 0; i &lt; (2*n
      - 1); i++) RD[i] = 1;</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; for (i = 0; i &lt; 2*n;
      i++) LD[i] = 1;</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; generate(0);</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; printf("No
      solution!\n");</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; return 0;</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">}</span><br>
    <br>
    <span style="font-weight: bold;">Метод на разклоненията и границите
    </span>[6.4]<br>
    <br>
    Задача за търговския пътник (<a
      href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">Travelling



      salesman problem</a>)<br>
    <br>
    Задача за раницата (<a
      href="https://en.wikipedia.org/wiki/Knapsack_problem">Knapsack
      problem</a>)<br>
    <span style="text-decoration: underline;"></span><br>
    <hr width="100%" size="2"><span style="text-decoration: underline;"></span>
  </body>
</html>
