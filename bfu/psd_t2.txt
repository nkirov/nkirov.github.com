Дадена е следната програма:
class Term {
public:
   Term(int ti = 0, int i = 1);
   int addTerm() { return temp += inc; }
   int subTerm() { return temp -= inc; }
private:
   int temp;
   const int inc; };
Term::Term(int ti, int i):inc(i) { temp=ti; }
void main()
{ Term ... ;
 cout<<t1.addTerm()*t2.subTerm()<<"\n"; }
Отбележете дефинициите, които като се поставят на
мястото на ..., се извежда числото 60.

+ t1(4), t2(t1.addTerm(),-5)
- t1(4), t2(t1.subTerm(),-5)



Отбележете верните декларации на функции, които могат да
бъдат конструктори на класове.

+ Log();
- int Cache();



Даден е класът
class Disk    {
public:
   Disk();
   Disk(long n, double p);
   long get_seek() const;
   double get_access() const;
private:
   long seek;
   double access;
};
и обект от този клас p, дефиниран в main.
Отбележете операторите, които могат да се срещат в блока на
функцията main.

+ Disk d;
- long s = p.seek;



Даден е вектор и стойности на елементите му.
   vector<double> user(2);
   user[0] = 0.5; user[1] = 3.5;
Отбележете операторите, където правилно е използван векторът user.

+ user.pop_back();
- user.pop_back(3.1);



Даден е клас Signal и обект b.
class Signal {
public:
  Signal();
  vector<string> get_msg() const {return msg;}
  void set_msg(string s, int i) { msg[i]=s; }
private:
   vector<string> msg;
} b;
Конструкторът на класа зарежда 9 стойности на вектора msg.
Отбележете верните оператори от блока на main.

+ vector<string> c = b.get_msg();
- vector<int> id = b.get_msg();



Дадена е следната дефиниция на функция:
int fvec()
{ int vec[]={0,10,0,30,0,50,0,70,0,90};
  int *pt_vec=vec;
  return int(...); }
Отбележете изразите, поставени на мястото на ..., при които функцията
връща стойност 0.

+ *vec
- *vec[2]

Дадени са елементи на масив и две числа в скоби.
Отбележете случаите, когато второто число е броя на размените на
двойки елементи в алгоритъма за деление на масива на дялове относно
първото число.

+ 1,1,1,0,0 (1,2)
- 2,3,1,3 (2.5,2)



Дадени са следните дефиниции:
   int *pk, *pi, c=10;
Отбележете верните оператори.

+ pk=pi;
- *pk=new pi;



Даден е свързан списък
   class Item {
   public:
     Item *next;
     ... } *pb, *p, *pe;
като pb е указател за началото на списъка,
pe съдържа адреса на последния елемент от списъка,
а p е указател към елемент от списъка, който не е първия
и последния. Отбележете верните твърдения.

+ pe->next==0 е истина.
- Ако списъка се състои от 3 елемента, то pb->next==pe е истина.



Дадени да следните свързан списък и итератор:
   list<int> bip;
   list<int>::iterator it;
Списъкът е попълнен с 10 елемента и итераторът сочи втория
елемент на списъка. Отбележете верните оператори.

+ cout << *it;
- cout << *bip.end();

