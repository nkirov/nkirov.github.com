<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
   <meta name="Author" content="Nikolay Kirov">
   <meta name="GENERATOR" content="Mozilla/4.75 [en] (Win95; U) [Netscape]">
   <title>psd_l8</title>
</head>
<body>

<hr WIDTH="100%">
<br><b>8. Още структури от данни</b>
<br><img SRC="bullet.gif" height=18 width=20 align=ABSCENTER> Двоични дървета
<br>*** Определение и свойства на дърво.
<br>- Ацикличен насочен граф, в който всички върхове без 1 имат по 1 предшественик,
а 1 връх (корен) няма предшественици.
<br>- Единствен път до корена, ниво - брой на върховете по пътя до корена
<br>- Ниво на върха - брой на върховете в пътя до корена
<br>- Корен - ниво 0
<br>- Листа - върхове без наследници
<br>- Поддърво определено от връх - върхът и всичките му наследници, техните
наследници и т.н.
<br>- Рекурсивна същност на дърветата като структури от данни
<p>*** Двоично дърво:
<br>Брой на наследниците на върховете - 0, 1 или 2;
<br>Ляв и десен наследник.
<br>-- Рекурсивно определение на двоично дърво
<br>Крайно множество от елементи (възли), което е или празно, или се състои
от корен (възел), свързан с две непресичащи се двоични дървета (поддървета)
- ляво и дясно поддърво.
<br>-- Реализация с масив
<br>-- Реализация с указатели
<br>Дърво за двоично търсене:
<br><b><tt><font color="#000099">// tree: Introduction to binary trees</font></tt></b>
<br><b><tt><font color="#000099">#include &lt;iostream.h></font></tt></b>
<p><b><tt><font color="#000099">struct node {int info; node *pLeft, *pRight;};</font></tt></b>
<p><b><tt><font color="#000099">class tree {</font></tt></b>
<br><b><tt><font color="#000099">public:</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; tree();</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; void print()const{pr(root);}</font></tt></b>
<br><b><tt><font color="#000099">private:</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; node *root;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; void AddNode(int x, node*
&amp;p);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; void pr(const node *p)const;</font></tt></b>
<br><b><tt><font color="#000099">};</font></tt></b>
<p><b><tt><font color="#000099">tree::tree()</font></tt></b>
<br><b><tt><font color="#000099">{&nbsp; root = NULL;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; int x;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; while (cin >> x, !cin.fail())
AddNode(x, root);</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<p><b><tt><font color="#000099">void tree::AddNode(int x, node* &amp;p)</font></tt></b>
<br><b><tt><font color="#000099">{&nbsp; if (p == NULL)</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; {</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = new
node;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p->info
= x;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p->pLeft
= p->pRight = NULL;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; }</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; else AddNode(x, x &lt; p->info
? p->pLeft : p->pRight);</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<p><b><tt><font color="#000099">void tree::pr(const node *p)const</font></tt></b>
<br><b><tt><font color="#000099">{&nbsp; if (p)</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; {</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pr(p->pLeft);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt;
p->info &lt;&lt; " ";</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pr(p->pRight);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; }</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<p><b><tt><font color="#000099">int main()</font></tt></b>
<br><b><tt><font color="#000099">{&nbsp; cout &lt;&lt;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Enter
some integers to be placed in a binary tree,\n"</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "followed
by /:\n";</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; tree t;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; cout &lt;&lt; "Tree contents
(in ascending order):\n";</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; t.print();</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; cout &lt;&lt; endl;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; return 0;</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<br>***&nbsp; Обхождане на структура от данни двоично дърво
<br>Обхождане на двоично дърво - линейно нареждане на възлите на дървото
<br>* корен, ляв, десен (низходящо, preorder,&nbsp; клд)
<br>* ляв, корен, десен (смесено,&nbsp;&nbsp;&nbsp;&nbsp; inorder,&nbsp;&nbsp;&nbsp;
лкд)
<br>* ляв, десен, корен (възходящо, postorder, лдк)
<br>Пример:
<br>Аритметични изрази и двоични дървета
<br>Листата са имена на променливи и константи, другите възли са аритметични
операции
<br>(a+b/c)*(d-e*f)
<br>1) preorder (клд) - *+a/bc-d*ef
<br>2) inorder&nbsp; (лкд)&nbsp; - a+b/c*d-e*f
<br>3) postorder(лдк) - abc/+def*-*
<p>Претърсване на дърво за двоично търсене:
<br><b><tt><font color="#000099">/* bintree:</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; This program builds and searches
a binary search</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; tree and prints its contents.
The program produces</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; a frequency distribution
of words read from a textfile.</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; We can also search the tree
for a given word to inquire</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; how often that word occurs.</font></tt></b>
<br><b><tt><font color="#000099">*/</font></tt></b>
<br><b><tt><font color="#000099">#include &lt;fstream.h></font></tt></b>
<br><b><tt><font color="#000099">#include &lt;iomanip.h></font></tt></b>
<br><b><tt><font color="#000099">#include &lt;ctype.h></font></tt></b>
<br><b><tt><font color="#000099">#include &lt;string.h></font></tt></b>
<br><b><tt><font color="#000099">#include &lt;stdlib.h></font></tt></b>
<p><b><tt><font color="#000099">struct node {char *pWord; int count; node
*pLeft, *pRight;};</font></tt></b>
<p><b><tt><font color="#000099">class tree {</font></tt></b>
<br><b><tt><font color="#000099">public:</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; tree(ifstream &amp;input);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; ~tree(){DelTree(root);}</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; void print()const{pr(root);}</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; node *search()const;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; int ReadWord(istream &amp;input);</font></tt></b>
<br><b><tt><font color="#000099">private:</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; node *root;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; enum {buflen = 50};</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; char buf[buflen];</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; void AddNode(node* &amp;p);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; void DelTree(node* &amp;p);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; void pr(const node *root)const;</font></tt></b>
<br><b><tt><font color="#000099">};</font></tt></b>
<p><b><tt><font color="#000099">int tree::ReadWord(istream &amp;input)</font></tt></b>
<br><b><tt><font color="#000099">/* This function reads a word from the
stream 'input'.</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; It skips any leading nonalphabetic
characters.</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; Then the longest possible
string of letters (no longer</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; than buflen - 1) is read,
converted to upper case and</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; placed in 'buf'. Return value:
success (1) or failure (0).</font></tt></b>
<br><b><tt><font color="#000099">*/</font></tt></b>
<br><b><tt><font color="#000099">{&nbsp; char ch;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; int i;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; do</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; {&nbsp; input >> ch;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (input.fail())
return 0;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; }&nbsp; while (!isalpha(ch));</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; for (i=0; i&lt;buflen-1;
)</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; {&nbsp; buf[i++] = toupper(ch);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; input.get(ch);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (input.fail()
|| !isalpha(ch)) break;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; }</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; buf[i] = '\0';</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; return 1;</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<p><b><tt><font color="#000099">tree::tree(ifstream &amp;input)</font></tt></b>
<br><b><tt><font color="#000099">{&nbsp; root = NULL;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; while (ReadWord(input)) AddNode(root);</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<p><b><tt><font color="#000099">void tree::DelTree(node* &amp;p)</font></tt></b>
<br><b><tt><font color="#000099">{&nbsp; if (p)</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; {&nbsp; DelTree(p->pLeft);
DelTree(p->pRight);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[]
p->pWord; delete p; p = NULL;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; }</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<p><b><tt><font color="#000099">void tree::AddNode(node* &amp;p) // Add
word in buf to tree</font></tt></b>
<br><b><tt><font color="#000099">{&nbsp; if (p == NULL)</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; {&nbsp; p = new node;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p->pWord
= new char[strlen(buf) + 1];</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(p->pWord,
buf); p->count = 1;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p->pLeft
= p->pRight = NULL;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; }&nbsp; else</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; {&nbsp; int code = strcmp(buf,
p->pWord);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (code)
AddNode(code &lt; 0 ? p->pLeft : p->pRight);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else p->count++;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; }</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<p><b><tt><font color="#000099">void tree::pr(const node *p)const</font></tt></b>
<br><b><tt><font color="#000099">{&nbsp; if (p)</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; {&nbsp; pr(p->pLeft);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt;
setw(5) &lt;&lt; p->count &lt;&lt; " "</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt; p->pWord &lt;&lt; endl;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pr(p->pRight);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; }</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<p><b><tt><font color="#000099">node *tree::search()const</font></tt></b>
<br><b><tt><font color="#000099">{&nbsp; node *p = root;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; for (;;)</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; {&nbsp; if (p == NULL) return
NULL;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int code
= strcmp(buf, p->pWord);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (code
== 0) return p;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = (code
&lt; 0 ? p->pLeft : p->pRight);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; }</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<p><b><tt><font color="#000099">int main()</font></tt></b>
<br><b><tt><font color="#000099">{&nbsp; ifstream input;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; node *ptr;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; const int NameLen=50;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; char FileName[NameLen];</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; cout &lt;&lt; "Input file:
";</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; cin >> setw(NameLen) >> FileName;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; input.open(FileName, ios::in);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; if (input.fail())</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; {&nbsp; cout &lt;&lt; "Cannot
open input file.\n"; exit(1);&nbsp;&nbsp; }</font></tt></b>
<p><b><tt><font color="#000099">&nbsp;&nbsp; tree t(input);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; cout &lt;&lt; "Frequency
distribution:\n";</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; t.print();</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; for (;;)</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; {&nbsp; cout &lt;&lt; "\nEnter
a word, or type Ctrl+Z (or Ctrl+D) "</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "to stop:
";</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (t.ReadWord(cin)
== 0) break;</font></tt></b>
<br><b><tt><font color="#000099">// The word read by ReadWord has been
placed in the buf</font></tt></b>
<br><b><tt><font color="#000099">// class member. We now search the tree
for this word:</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptr = t.search();</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt;
"Number of occurrences: "</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt; (ptr ? ptr->count : 0) &lt;&lt; endl;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; }</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; return 0;</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p><img SRC="bullet.gif" height=18 width=20 align=ABSCENTER> Кодиране на
Хъфман
<br>*** Алгоритъм на Хъфман:
<br>&nbsp;1. Всички букви - листа на дървото с тегла броя на срещанията
на буквата в текста
<br>&nbsp;2. Всички други възли на дървото имат тегла 0
<br>&nbsp;3. В началото разглеждаме всички листа като отделни дървета
<br>&nbsp;4. Намираме две дървета с най-малки претеглени дължини
<br>&nbsp;5. Построяваме ново дърво, като създаваме нов възел (корен) с
наследници - двете поддървета
<br>&nbsp;6. Пресмятаме претеглената дължина на новото дърво (сума от претеглените
дължини на двете поддървета)
<br>&nbsp;7. Отиваме на 4., ако имаме поне 2 дървета
<p>*** Построяване на оптимално двоично дърво по алгоритъма на Хъфман и
пример за следния текст:
<p><b><font color="#CC0000">програмиране и структури от данни</font></b>
<p><b><tt><font color="#000099">#include &lt;iostream.h></font></tt></b>
<br><b><tt><font color="#000099">struct Huf {</font></tt></b>
<br><b><tt><font color="#000099">char id;</font></tt></b>
<br><b><tt><font color="#000099">int wh;</font></tt></b>
<br><b><tt><font color="#000099">Huf *left, *right; };</font></tt></b>
<p><b><tt><font color="#000099">struct List {</font></tt></b>
<br><b><tt><font color="#000099">List *next;</font></tt></b>
<br><b><tt><font color="#000099">Huf *tree; };</font></tt></b>
<p><b><tt><font color="#000099">List *head;</font></tt></b>
<p><b><tt><font color="#000099">void CreateList();</font></tt></b>
<br><b><tt><font color="#000099">void WriteList();</font></tt></b>
<br><b><tt><font color="#000099">void DelList(List *l);</font></tt></b>
<br><b><tt><font color="#000099">void AddList(Huf *h);</font></tt></b>
<br><b><tt><font color="#000099">Huf *FindDels();</font></tt></b>
<br><b><tt><font color="#000099">void CreateTree();</font></tt></b>
<br><b><tt><font color="#000099">void rlrootTree(Huf *h);</font></tt></b>
<p><b><tt><font color="#000099">void main()</font></tt></b>
<br><b><tt><font color="#000099">{</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;CreateList();</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;WriteList();</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;CreateTree();</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;rlrootTree(head->tree);</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<p><b><tt><font color="#000099">void CreateList()</font></tt></b>
<br><b><tt><font color="#000099">{</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;const n=13;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;char ch[n]={'Ї','°','®','Ј',' ','¬','Ё','­','±','І','і','Є','¤'};</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;int&nbsp;&nbsp; w[n]={ 1,&nbsp;
5,&nbsp; 2,&nbsp; 1,&nbsp; 3,&nbsp; 1,&nbsp; 4,&nbsp; 3,&nbsp; 1,&nbsp;
2,&nbsp; 2,&nbsp; 1,&nbsp; 1};</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;List *l; Huf *h;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;head=0;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;for (int i=0; i&lt;n; i++)</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;{</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; h=new Huf;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; h->id=ch[i]; h->wh=w[i];</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; h->left=0; h->right=0;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; l=new List;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; l->tree=h;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; l->next=head; head=l;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;}</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<p><b><tt><font color="#000099">void WriteList()</font></tt></b>
<br><b><tt><font color="#000099">{</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;List *l;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;l=head;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;while&nbsp; (l)</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;{</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; cout &lt;&lt; (l->tree)->id &lt;&lt;
"&nbsp; " &lt;&lt; (l->tree)->wh &lt;&lt; endl;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; l=l->next;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;}</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<p><b><tt><font color="#000099">void DelList(List *l)</font></tt></b>
<br><b><tt><font color="#000099">{</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;List *lp, *lc;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;if (l==head) {head=l->next; delete
l;}</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;else</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;{</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; lp=head; lc=lp->next;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; while (lc!=l)</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; {</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp; lp=lc; lc=lc->next;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; }</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; lp->next=lc->next; delete lc;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;}</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<p><b><tt><font color="#000099">void AddList(Huf *h)</font></tt></b>
<br><b><tt><font color="#000099">{</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;List *l;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;l=new List;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;l->tree=h;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;l->next=head;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;head=l;</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<p><b><tt><font color="#000099">Huf *FindDels()</font></tt></b>
<br><b><tt><font color="#000099">{</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;List *l, *sm;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;Huf *h;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;l=head; sm=l;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;while (l)</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;{</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; if ((l->tree)->wh &lt; (sm->tree)->wh)
sm=l;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; l=l->next;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;}</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;h=sm->tree;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;DelList(sm);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;return h;</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<p><b><tt><font color="#000099">void CreateTree()</font></tt></b>
<br><b><tt><font color="#000099">{</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;Huf *h, *h1, *h2;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;while (head->next)</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;{</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; h1=FindDels();</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; h2=FindDels();</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; h=new Huf;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; h->id=' '; h->wh=(h1->wh)+(h2->wh);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; h->left=h1; h->right=h2;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; AddList(h);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;}</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<p><b><tt><font color="#000099">void rlrootTree(Huf *h)</font></tt></b>
<br><b><tt><font color="#000099">{</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;if (h)</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;{</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; rlrootTree(h->right);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; rlrootTree(h->left);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; cout &lt;&lt; h->id &lt;&lt; "
: " &lt;&lt; h->wh &lt;&lt; endl;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;}</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<br>
<hr WIDTH="100%">
</body>
</html>
