<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="GENERATOR" content="Mozilla/4.75 [en] (Win98; U) [Netscape]">
  <title>lecture06</title>
</head>
<body>
<h3 style="font-weight: normal;">9. <font color="#000000">Сортиране
- общи положения; сортиране чрез сравнение</font><br>
</h3>
<p><big>** Класификации на алгоритмите за сортиране [Глава 3, стр.187]<br>
</big></p>
<p><big>* В зависимост от местонахождението на данните: <br>
 - вътрешно (директен достъп), например бързо сортиране и <br>
 - външно (последователен достъп), например сливане.<br>
* В зависимост от операцията: <br>
 - чрез сравнение (<span style="font-family: monospace;">&lt;</span>,
<span style="font-family: monospace;">&gt;</span> и <span style="font-family: monospace;">==</span>) на двойки елементи и <br>
 - чрез трансформация, напр. сортиране чрез броене.<br>
* Свойство на алгоритъма за сортиране:<br>
 - устойчиви - относителният ред на елементите с равни ключове
остава непроменен и<br>
 - неустойчиви - разместване на елементи с равни ключове.
(сортиране с 2 ключа)<br>
* Ефективност на алгоритмите за сортиране - брой на извършени сравнения
и размени (присвоявания).<br>
* Използване на допълнителна памет.<br>
</big></p>
<big>** Дърво на сравненията; сортиране на 3 числа.<br>
<br>
** Класически универсални елементарни методи за сортиране чрез
сравнение <span style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span><sup>2</sup>):<br>
 - пряко вмъкване - намираме елемент, който "не е сортиран" и го
поставяме на мястото му в сортираната част;<br>
 - пряка селекция (избор) - намираме най-малкия елемент и го
поставяме на мястото му в окончателно сортираната част;<br>
 - мехурчето - последователно се разглеждат двойки елементи и
евентуално се разменят.<br>
</big>
<p><big>** Бързо сортиране на Хоор - <span style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span> log</big><sub>2</sub><big><span style="font-style: italic;">n</span>) средно и <span style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span><sup>2</sup>)
в най-лошия
случай.<br>
</big></p>
<p><big>** Пирамидално сортиране, сортиране чрез сливане: <span style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span>
log</big><sub>2</sub><big><span style="font-style: italic;">n</span>) и
тази оценка не може да се
подобри при сортиране чрез сравняване.<br>
</big></p>
<big>
</big>
<h3 style="font-weight: normal;"><big>** <font color="#000000">Сортиране
чрез трансформация [3.2]</font>
</big></h3>
<big>** Сортиране чрез множество [3.2.1]<br>
    Дадено е множество <span style="font-style: italic;">M</span>
от числа в затворения интервал [<span style="font-style: italic;">a, b</span>]
и инективна функция за нареждане <span style="font-style: italic;">f:</span>
<span style="font-style: italic;">M <span style="font-family: monospace;">-&gt;</span> </span>[<span style="font-style: italic;">a, b</span>], т.е. ако <span style="font-style: italic;">x</span><sub>1</sub> и <span style="font-style: italic;">x</span><sub>2</sub> са
различни, то са различни и <span style="font-style: italic;">f</span> (<span style="font-style: italic;">x</span><sub>1</sub>) и <span style="font-style: italic;">f</span> (<span style="font-style: italic;">x</span><sub>2</sub>).<br>
    Построяваме нулев масив <span style="font-family: monospace;">S</span> с индекси от <span style="font-style: italic;">a</span> до <span style="font-style: italic;">b</span> <span style="font-style: italic;"></span>и
с едно минаване през множеството <span style="font-style: italic;">M </span>поставяме
стойности 1
на <span style="font-family: monospace;">S[</span><span style="font-style: italic;">f</span> (<span style="font-style: italic;">x</span>)<span style="font-family: monospace;">]</span> за всяко <span style="font-style: italic;">x</span> от <span style="font-style: italic;">M</span><span style="font-style: italic;"></span><span style="font-style: italic;"></span>.  След това минаваме през
масива <span style="font-family: monospace;">S</span> за да
подредим елементите на <span style="font-style: italic;">M.<br>
    </span> Сложност <span style="font-style: italic;">O</span>(<span style="font-style: italic;">m+n</span>)<span style="font-style: italic;">, </span>където<span style="font-style: italic;"> n </span>е броят на елементите на<span style="font-style: italic;"> M</span>, а<span style="font-style: italic;"> m = b - a +</span> 1<span style="font-style: italic;">.</span><span style="font-style: italic;"></span>
<br>
** Сортиране чрез броене [3.2.2]
<br>
** Побитово сортиране [3.2.3]
<br>
** Метод на бройните системи [3.2.4]
<br>
** Сортиране чрез пермутация [3.2.5]<br>
<br>
   Дадено е множество <span style="font-style: italic;">M</span>
от <span style="font-style: italic;">n</span> елементи. Означаваме с <span style="font-style: italic;">S</span> множеството {1, 2, 3, ..., <span style="font-style: italic;">n</span>}<span style="font-style: italic;">.</span> 
Функцията за нареждане е <span style="font-style: italic;">f:</span> <span style="font-style: italic;">S <span style="font-family: monospace;">-&gt;</span>
</span><span style="font-style: italic;">S</span> е сюрективна, т.е.
ако <span style="font-style: italic;">x</span><sub>1</sub>
и <span style="font-style: italic;">x</span><sub>2</sub> са
различни, то са различни и <span style="font-style: italic;">f</span> (<span style="font-style: italic;">x</span><sub>1</sub>) и <span style="font-style: italic;">f</span> (<span style="font-style: italic;">x</span><sub>2</sub>)
и за
всяко <span style="font-style: italic;">y</span> от <span style="font-style: italic;">S</span> съществува <span style="font-style: italic;">x</span> от <span style="font-style: italic;">S</span> такова, че <span style="font-style: italic;">y</span> = <span style="font-style: italic;">f</span> (<span style="font-style: italic;">x</span>).<br>
    Разменяме <span style="font-family: monospace;">m[1]</span>
с <span style="font-family: monospace;">m[m[1]]</span> докато на <span style="font-family: monospace;">1</span>-во място не дойде <span style="font-family: monospace;">1</span>. После по същия начин с
втория елемент и т.н.<br>
<span style="font-family: monospace;">позиции <span style="text-decoration: underline;">1234567</span></span><br style="font-family: monospace;">
<span style="font-family: monospace;">       
<span style="font-weight: bold;">4</span>37<span style="font-weight: bold;">5</span>612</span><br>
<span style="font-family: monospace;">       
<span style="font-weight: bold;">5</span>374<span style="font-weight: bold;">6</span>12</span><br>
<span style="font-family: monospace;">       
<span style="font-weight: bold;">6</span>3745<span style="font-weight: bold;">12</span></span><br>
<span style="font-family: monospace;"><span style="font-weight: bold;">       
</span>1<span style="font-weight: bold;">37</span>4562</span><br>
<span style="font-family: monospace;">       
1<span style="font-weight: bold;">7</span>3456<span style="font-weight: bold;">2</span></span><br>
<span style="font-family: monospace;"><span style="font-weight: bold;">       
</span>1234567<span style="font-weight: bold;"> </span></span><br>
<span style="font-family: monospace;"><span style="font-weight: bold;"></span></span>Броят
на размените не недвишава <span style="font-style: italic;">n</span>,
а броят на сравненията - 2<span style="font-style: italic;">n</span>.<span style="font-family: monospace;"><span style="font-weight: bold;"></span></span><br>
<span style="font-family: monospace;"><span style="font-weight: bold;"></span><span style="font-weight: bold;"></span></span></big>
<hr style="width: 100%; height: 2px;">
<big><span style="font-weight: bold;"></span></big>
<hr style="width: 100%; height: 2px;">
<big><span style="font-weight: bold;"></span></big>
</body>
</html>
