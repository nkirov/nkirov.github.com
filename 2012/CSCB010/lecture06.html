<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <title>l6</title>
</head>
<body>
<h2>6.  Сортиране. Търсене. Хеширане<br>
</h2>
<h3 style="font-weight: normal;"> <font color="#000000">Сортиране
- общи положения; сортиране чрез сравнение</font><br>
</h3>
<p><big>** Класификации на алгоритмите за сортиране [Глава 3, стр.187]<br>
</big></p>
<p><big>* В зависимост от местонахождението на данните: <br>
 - вътрешно (директен достъп), например бързо сортиране и <br>
 - външно (последователен достъп), например сливане.<br>
* В зависимост от операцията: <br>
 - чрез сравнение (<span style="font-family: monospace;">&lt;</span>,
<span style="font-family: monospace;">&gt;</span> и <span style="font-family: monospace;">==</span>) на двойки елементи и <br>
 - чрез трансформация, напр. сортиране чрез броене.<br>
* Свойство на алгоритъма за сортиране:<br>
 - устойчиви - относителният ред на елементите с равни ключове
остава непроменен и<br>
 - неустойчиви - разместване на елементи с равни ключове
(сортиране с 2 ключа)<br>
* Ефективност на алгоритмите за сортиране - брой на извършени сравнения
и размени (присвоявания).<br>
* Използване на допълнителна памет.<br>
</big></p>
<big>** Дърво на сравненията; сортиране на 3 числа.<br>
<br>
** Класически универсални "елементарни" методи за сортиране чрез
сравнение <span style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span><sup>2</sup>):<br>
 - пряко вмъкване - намираме елемент, който "не е сортиран" и го
поставяме на мястото му в сортираната част;<br>
 - пряка селекция (избор) - намираме най-малкия елемент и го
поставяме на мястото му в окончателно сортираната част;<br>
 - мехурчето - последователно се разглеждат двойки елементи и
евентуално се разменят.<br>
</big>
<p><big>** Бързо сортиране на Хоор - <span style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span> log</big><sub>2</sub><big><span style="font-style: italic;">n</span>) средно и <span style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span><sup>2</sup>)
в
най-лошия
случай.<br>
</big></p>
<p><big>** Пирамидално сортиране, сортиране чрез сливане: <span style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span>
log</big><sub>2</sub><big><span style="font-style: italic;">n</span>) и
тази оценка не може да се
подобри при сортиране чрез сравняване.<br>
</big></p>
<big>
</big>
<h3 style="font-weight: normal;"><big>** <font color="#000000">Сортиране
чрез
трансформация
[3.2]</font>
</big></h3>
<big>** Сортиране чрез множество [3.2.1]<br>
    Дадено е множество <span style="font-style: italic;">M</span>
от числа в затворения интервал [<span style="font-style: italic;">a, b</span>]
и
инективна
функция
за
нареждане
<span style="font-style: italic;">f:</span>
<span style="font-style: italic;">M <span style="font-family: monospace;">-&gt;</span> </span>[<span style="font-style: italic;">a, b</span>], т.е. ако <span style="font-style: italic;">x</span><sub>1</sub> и <span style="font-style: italic;">x</span><sub>2</sub> са
различни, то са различни и <span style="font-style: italic;">f</span> (<span style="font-style: italic;">x</span><sub>1</sub>) и <span style="font-style: italic;">f</span> (<span style="font-style: italic;">x</span><sub>2</sub>).<br>
    Построяваме нулев масив <span style="font-family: monospace;">S</span> с индекси от <span style="font-style: italic;">a</span> до <span style="font-style: italic;">b</span> <span style="font-style: italic;"></span>и
с
едно
минаване
през
множеството
<span style="font-style: italic;">M </span>поставяме
стойности
1
на
<span style="font-family: monospace;">S[</span><span style="font-style: italic;">f</span> (<span style="font-style: italic;">x</span>)<span style="font-family: monospace;">]</span> за всяко <span style="font-style: italic;">x</span> от <span style="font-style: italic;">M</span><span style="font-style: italic;"></span><span style="font-style: italic;"></span>.  След това минаваме през
масива <span style="font-family: monospace;">S</span> за да
подредим елементите на <span style="font-style: italic;">M.<br>
    </span> Сложност <span style="font-style: italic;">O</span>(<span style="font-style: italic;">m+n</span>)<span style="font-style: italic;">, </span>където<span style="font-style: italic;"> n </span>е броят на елементите на<span style="font-style: italic;"> M</span>, а<span style="font-style: italic;"> m = b - a +</span> 1<span style="font-style: italic;">.</span><span style="font-style: italic;"></span>
<br>
** Сортиране чрез броене [3.2.2]
<br>
** Побитово сортиране [3.2.3]
<br>
** Метод на бройните системи [3.2.4]
<br>
** Сортиране чрез пермутация [3.2.5]<br>
<br>
   Дадено е множество <span style="font-style: italic;">M</span>
от <span style="font-style: italic;">n</span> елементи. Означаваме с <span style="font-style: italic;">S</span> множеството {1, 2, 3, ..., <span style="font-style: italic;">n</span>}<span style="font-style: italic;">.</span> 
Функцията
за
нареждане
е
<span style="font-style: italic;">f:</span> <span style="font-style: italic;">S <span style="font-family: monospace;">-&gt;</span>
</span><span style="font-style: italic;">S</span> е сюрективна, т.е.
ако <span style="font-style: italic;">x</span><sub>1</sub>
и <span style="font-style: italic;">x</span><sub>2</sub> са
различни, то са различни и <span style="font-style: italic;">f</span> (<span style="font-style: italic;">x</span><sub>1</sub>) и <span style="font-style: italic;">f</span> (<span style="font-style: italic;">x</span><sub>2</sub>)
и
за
всяко
<span style="font-style: italic;">y</span> от <span style="font-style: italic;">S</span> съществува <span style="font-style: italic;">x</span> от <span style="font-style: italic;">S</span> такова, че <span style="font-style: italic;">y</span> = <span style="font-style: italic;">f</span> (<span style="font-style: italic;">x</span>).<br>
    Разменяме <span style="font-family: monospace;">m[1]</span>
с <span style="font-family: monospace;">m[m[1]]</span> докато на <span style="font-family: monospace;">1</span>-во място не дойде <span style="font-family: monospace;">1</span>. После по същия начин с
втория елемент и т.н.<br>
<span style="font-family: monospace;">позиции <span style="text-decoration: underline;">1234567</span></span><br style="font-family: monospace;">
<span style="font-family: monospace;">       
<span style="font-weight: bold;">4</span>37<span style="font-weight: bold;">5</span>612</span><br>
<span style="font-family: monospace;">       
<span style="font-weight: bold;">5</span>374<span style="font-weight: bold;">6</span>12</span><br>
<span style="font-family: monospace;">       
<span style="font-weight: bold;">6</span>3745<span style="font-weight: bold;">12</span></span><br>
<span style="font-family: monospace;"><span style="font-weight: bold;">       
</span>1<span style="font-weight: bold;">37</span>4562</span><br>
<span style="font-family: monospace;">       
1<span style="font-weight: bold;">7</span>3456<span style="font-weight: bold;">2</span></span><br>
<span style="font-family: monospace;"><span style="font-weight: bold;">       
</span>1234567<span style="font-weight: bold;"> </span></span><br>
<span style="font-family: monospace;"><span style="font-weight: bold;"></span></span>Броят
на
размените
не
недвишава
<span style="font-style: italic;">n</span>,
а броят на сравненията - 2<span style="font-style: italic;">n.<br>
</span></big><big><span style="font-weight: bold;"></span></big>
<hr style="width: 100%; height: 2px;">
<h3>Бързо сортиране</h3>
<font size="+1"> А. Разделяне на дялове:
<br>
 1. Избираме случаен елемент </font><font size="+1"><span style="font-family: monospace;">x</span></font><font size="+1"> от
масива </font><font size="+1"><span style="font-family: monospace;">a</span></font><font size="+1">
<br>
 2. Преглеждаме масива отляво (от началото), докато достигнем
до елемент </font><font size="+1"><span style="font-family: monospace;">&gt;</span></font><font style="font-family: monospace;" size="+1"> x</font><font size="+1">
</font><font size="+1"><br>
 3. Преглеждаме масива отдясно (от края), докато достигнем до
елемент </font><font size="+1"><span style="font-family: monospace;">&lt;
x
</span></font><font size="+1"><br>
 4. Разменяме местата на двата елемента
<br>
<b><tt><font color="#006600">vector&lt;int&gt; a(n);</font></tt></b><br>
<b><tt><font color="#006600">void partition(int x)</font></tt></b><br>
<b><tt><font color="#006600">{</font></tt></b><br>
<b><tt><font color="#006600"> int i=1, j=n;</font></tt></b><br>
<b><tt><font color="#006600"> do</font></tt></b><br>
<b><tt><font color="#006600"> {</font></tt></b><br>
<b><tt><font color="#006600">  while (a[i] &lt; x) i++;</font></tt></b><br>
<b><tt><font color="#006600">  while (a[j] &gt; x) j--;</font></tt></b><br>
<b><tt><font color="#006600">  if (i&lt;=j)</font></tt></b><b><tt><font color="#006600"> { swap(a[i], a[j]);  i++;
j--; }</font></tt></b><br>
<b><tt><font color="#006600"> }</font></tt></b><br>
<b><tt><font color="#006600"> while (i&lt;=j);</font></tt></b><br>
<b><tt><font color="#006600">}</font></tt></b></font>
<p><font size="+1">Б. Сортиране - след като масивът се раздели, двата
му дяла се
подлагат
на същата
обработка и това продължава, докато се получат дялове само с по един
елемент.
</font><br>
</p>
<p><b><tt><font color="#000099"><span style="color: rgb(204, 0, 0);">//
<big><a href="sources/qsort.cpp">qsort.cpp</a></big></span><br>
<font size="+1">void quicksort(int left, int right)</font></font></tt></b>
<font size="+1"><br>
<b><tt><font color="#000099">{</font></tt></b><br>
<b><tt><font color="#000099"> int i=left, j=right;</font></tt></b><br>
<b><tt><font color="#000099"> int x=a[(i + j)/2];</font></tt></b><br>
<b><tt><font color="#000099"> do</font></tt></b><br>
<b><tt><font color="#000099"> {</font></tt></b><br>
<b><tt><font color="#000099">  while (a[i] &lt; x) i++;</font></tt></b><br>
<b><tt><font color="#000099">  while (a[j] &gt; x) j--;</font></tt></b><br>
<b><tt><font color="#000099">  if (i&lt;=j)</font></tt></b><br>
<b><tt><font color="#000099">  { swap(a[i], a[j]); i++; j--; }</font></tt></b><br>
<b><tt><font color="#000099"> }</font></tt></b><br>
<b><tt><font color="#000099"> while (i&lt;=j);</font></tt></b><br>
<b><tt><font color="#000099"> if (left&lt;j) quicksort(left, j);</font></tt></b><br>
<b><tt><font color="#000099"> if (i&lt;right) quicksort(i, right);</font></tt></b><br>
<b><tt><font color="#000099">}</font></tt></b></font>
<br>
</p>
<p><big>qsort от STL <br>
</big></p>
<p><big>Сортиране чрез сливане<br>
</big></p>
<a style="font-family: monospace;" href="sources/mergesort.cpp"><big>mergesort.cpp</big></a><br>
<br>
<hr style="width: 100%; height: 2px;">
<h3><font color="#000000">Последователно
търсене [4, стр. 231]<br>
</font></h3>
<big>** Човешката дейност търсене<br>
<br>
** Опростен модел на търсене<br>
<br>
** Фундаментални операции над елемнтите на множество (правилна оценка
на ефективността на алгоритмите за търсене)<br>
-- инициализиране<br>
-- търсене<br>
-- вмъкване<br>
-- изтриване<br>
-- обединяване на множества<br>
--  сортиране.<br>
<br>
** Ключ, повтарящи се ключове<br>
-- има ли елемент с даден ключ? <span style="font-family: monospace;">[bool
exists(unsigned
key)]</span><br>
-- индекс на елемент (обект) с даден ключ? <span style="font-family: monospace;">[unsigned find_one(unsigned key)]<br>
</span>-- брой елементи с даден ключ? <span style="font-family: monospace;">[unsigned count(unsigned key)]</span><br>
-- индекси на всички елементи (обекти) с даден ключ? <span style="font-family: monospace;">[vector&lt;unsigned&gt;
find_all(unsigned key)]</span><br>
<br>
** Последователно (линейно) търсене<br>
Проверяваме последователно
елементите на множеството (което е линейно наредено), докато или
намерим търсения елемент или стигнем
до края на редицата.
<br>
Ефективност на алгоритъма за линейно
търсене:<br>
Броят на обръщенията към елементите на масива зависи
от търсеното число, но в най-лошия случай, когато числото не се среща в
масива, е равен на дължината на масива. Следователно сложността на
алгоритъма
е <i>O</i>(<i>n</i>).
<br>
</big><b><tt><font color="#993300">// <a href="sources/lsearch.cpp"><big>lsearch.cpp</big></a></font></tt></b><a href="sources/lsearch.cpp"><big>
</big></a><b><tt><font color="#000099"><br>
</font></tt></b>
<p><font size="+1"><b><tt><font color="#000099">int
linear_search(vector&lt;int&gt; v,
int
a)</font></tt></b><br>
<b><tt><font color="#000099">{</font></tt></b><br>
<b><tt><font color="#000099">   int i;</font></tt></b><br>
<b><tt><font color="#000099">   for (i = 0; i &lt; v.size();
i++)</font></tt></b><br>
<b><tt><font color="#000099">       if
(v[i] == a) return i;</font></tt></b><br>
<b><tt><font color="#000099">   return -1;</font></tt></b><br>
<b><tt><font color="#000099">}</font></tt></b></font>
</p>
<big>** Последователно търсене в сортиран списък с поддържане на
сортирания
списък при вмъкване на нов елемент.<br>
<br>
** Последователно търсене с преподреждане<br>
</big><br>
<h3>Двоично търсене (разделай и владей) [4.3, стр. 239]</h3>
<p><b><tt><font color="#993300">// <a href="sources/bsearch.cpp"><big>bsearch.cpp</big></a></font></tt></b><a href="sources/bsearch.cpp"><big>
</big></a><b><tt><font color="#000099"><br>
</font></tt></b></p>
<p><font size="+1"><b><tt><font color="#000099">int
binary_search(vector&lt;int&gt; v,
int
from, int to, int a)</font></tt></b><br>
<b><tt><font color="#000099">{</font></tt></b><br>
<b><tt><font color="#000099">   if (from &gt; to) 
return
-1;</font></tt></b><br>
<b><tt><font color="#000099">   int mid = (from + to) / 2;</font></tt></b><br>
<b><tt><font color="#000099">   int diff = v[mid] - a;</font></tt></b><br>
<b><tt><font color="#000099">   if (diff == 0) return
mid;         
/* v[mid] == a */</font></tt></b><br>
<b><tt><font color="#000099">   else if (diff &lt;
0)                 
/*
v[mid]
&lt;
a
*/</font></tt></b><br>
<b><tt><font color="#000099">      return
binary_search(v, mid + 1, to, a);</font></tt></b><br>
<b><tt><font color="#000099">   else</font></tt></b><br>
<b><tt><font color="#000099">      return
binary_search(v, from, mid - 1, a);</font></tt></b><br>
<b><tt><font color="#000099">}</font></tt></b></font>
</p>
<p><font size="+1">Търсене и
сортиране на реални данни
</font><br>
<b><tt><font color="#993300">// <a href="sources/esearch.cpp"><big>esearch.cpp</big></a></font></tt></b><a href="esearch.cpp"><big>
</big></a><br>
</p>
<p><font size="+1"><b><tt><font color="#000099">int
binary_search(vector&lt;Employee&gt; v,
int from, int to, string n)</font></tt></b><br>
<b><tt><font color="#000099">{</font></tt></b><br>
<b><tt><font color="#000099">   if (from &gt; to) return -1;</font></tt></b><br>
<b><tt><font color="#000099">   int mid = (from + to) / 2;</font></tt></b><br>
<b><tt><font color="#000099">   if (v[mid].get_name() ==
n)  return mid;</font></tt></b><br>
<b><tt><font color="#000099">   else if (v[mid].get_name()
&lt; n)</font></tt></b><br>
<b><tt><font color="#000099">      return
binary_search(v, mid + 1, to, n);</font></tt></b><br>
<b><tt><font color="#000099">   else</font></tt></b><br>
<b><tt><font color="#000099">      return
binary_search(v, from, mid - 1, n);</font></tt></b><br>
<b><tt><font color="#000099">}</font></tt></b></font>
</p>
<h3>Хеширане</h3>
<font size="+1">** Структура от данни речник (dictionary): ключ-елемент<br>
<br>
** Търсене в речник<br>
<br>
** Хеш-функция <span style="font-style: italic;">h</span>: key <span style="font-family: monospace;">-&gt;</span> [0, <span style="font-style: italic;">N</span>-1], пример</font> <span class="Apple-style-span" style="border-collapse: separate; color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; font-size: medium;"><span class="Apple-style-span" style="font-size: 19px;"><span style="font-style: italic;">h</span>(<span style="font-style: italic;">x</span>)
=<span class="Apple-converted-space"> </span><span style="font-style: italic;">x</span><span class="Apple-converted-space"> </span>mod<span class="Apple-converted-space"> </span><span style="font-style: italic;">N<br>
<br>
</span></span></span>
<hr style="width: 100%; height: 2px;">
</body>
</html>
