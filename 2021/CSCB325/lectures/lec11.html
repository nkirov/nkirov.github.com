<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="Author" content="Nikolay Kirov">
    <meta name="GENERATOR" content="Mozilla/4.75 [en] (Win98; U)
      [Netscape]">
    <title>lec11</title>
  </head>
  <body>
    <h2>11. Кодиране и компресиране<br>
    </h2>
    <p><i>План:</i><i><i><br>
        </i><i>Задачи за домашно 13 и 14</i></i><br>
      Кодиране и компресиране<br>
      Премахване на нулите<br>
      Кодиране на редици<br>
      Алгоритъм на Хъфман<br>
      Код с разделители<br>
    </p>
    <hr size="2" width="100%">Кодиране - декодиране<br>
    Компресиране - декомпресиране<br>
    <br>
    Без загуба на информация<br>
    Със загуба на информация (закръгляване)<br>
    <br>
    Кодиране на редици<br>
    Статистически (вероятностни) методи<br>
    Речникови методи <br>
    Вълнови методи<br>
    Фрактални методи<br>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Програмиране = ++Алгоритми; (Programming = ++Algorithms;)</title>
    Адаптивно компресиране<br>
    <hr size="2" width="100%">**<b>Премахване на нулите </b>[10.3.1]<b><br>
    </b><i>Задача: </i>Кодиране на числови редици с много поредни нули<b>.<br>
    </b><i>Алгоритъм: </i>Дългите последователности от нули да се
    заменят с кодираща двойка, състояща се от специален символ, указващ
    наличието на компресия, последван от брояч, указващ броя
    последователни нули. Процесът на декодиране е тривиален и се свежда
    до просто заместване на кодиращата двойка със съответния брой
    нули.<b><br>
    </b><i>Пример:</i> <font size="+1"><tt><br>
        12 17 86 93 0 0 1 2 0 0 0 0 0 19 20 0 8 3 12 0 0 0 6</tt></font><br>
    След кодиране със специален символ 0 се получава: <br>
    <font size="+1"><tt>12 17 86 93 0 1 1 2 0 4 19 20 0 0 8 3 12 0 2 6</tt></font><br>
    Използва се 1 бийт за кодиране на едно число.<br>
    <hr size="2" width="100%"><b>** Кодиране на редици </b>[10.3.9]<b><br>
    </b><i>Задача</i>: Кодиране на редици от символи (букви) с много
    поредни еднакви символи.<br>
    <i>Алгоритъм:</i> Заменяиме всяка редица от еднакви символи с
    един-единствен негов екземпляр, предшестван от число, указващо броя
    на срещанията му.<br>
    <i>Пример: </i><font size="+1"><tt>BBBBBBBCCCCCAAAAAAAAAAAAACCCABABBCCAAAAAAAAAAAAAAAAAAAA</tt></font><br>
    След кодиране: <font size="+1"><tt>7B5C13A3CABABB2C20A<br>
        <br>
      </tt></font><i>Задача</i>: Кодиране на редици от латински букви с
    поредни еднакви букви.<br>
    <i>Алгоритъм:</i><font size="+1"><tt> </tt></font>Избира се
    произволен символ от азбуката за escape (ESC) символ. Всяка негова
    поява означава началото на нова "ESC редица" -&nbsp; следващите два
    символа се интерпретират като двойка от вида XY
    (брой_срещания,символ). Броят срещания на Y се дава от поредния
    номер на X в азбуката. Пример:&nbsp; Нека Z e ESC символ. <br>
    В кода <font size="+1"><tt>7B5C13A3CABABB2C20A</tt></font> вместо 7
    пишем G, вместо 5 — E, вместо 13 — M,&nbsp; вместо 20 — T и т.н.<br>
    Получаваме: <font size="+1"><tt>ZGBZECZMACCCABABBCCZTA</tt></font><br>
    <br>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Програмиране = ++Алгоритми; (Programming = ++Algorithms;)</title>
    <i>Задача</i>: Кодиране на редици от&nbsp; единици и нули с много
    поредни еднакви символи.<br>
    <i>Алгоритъм: </i>Записваме само броя на поредните нули, после броя
    на поредните единици и т.н.<br>
    <i>Пример: </i><br>
    <font size="+1"><tt>000000001111111000000 -&gt; 8 7 6 </tt><tt><br>
      </tt><tt>000000011111111110000 -&gt; 7 10 4 </tt><tt><br>
      </tt><tt>000001111111111111000 -&gt; 5 13 3 </tt><tt><br>
      </tt><tt>000001111111111111000 -&gt; 5 13 3<br>
      </tt></font>
    <hr size="2" width="100%"><b>** Алгоритъм на Хъфман </b>[10.4.2]<b><b>&nbsp;</b></b>
    (<a href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman
      coding</a>)<b><br>
    </b><i>Задача:</i> Код, при който по-често срещаните символи се
    кодират с по-къси кодове (редици от битов<b>e).</b><br>
    <i>Алгоритъм:</i> <br>
    1. Пресмятаме вероятностите за срещане на всеки символ (честота).<br>
    2. Построяваме дърво на Хъфман:<br>
    &nbsp;&nbsp; 2a. Построяваме гора - от всеки символ тривиално дърво,
    в корена (единствения връх) на което записваме вероятността на
    срещане на съответния символ.<br>
    &nbsp;&nbsp; 2b. Намираме двата върха с най-малки вероятности и ги
    обединяваме в ново дърво с корен, съдържащ сумата от вероятностите
    им.<br>
    &nbsp;&nbsp; 2c. Ако има поне две дървета, преход към 2b.<br>
    3. Поставяме 0 на ляв клон и 1 на десен клон.<br>
    4а. Кодиране: За всяко листо (символ) определяме код от единици и
    нули, получени оп пътя от корена до това листо.<br>
    4b. Декодиране: Тръгваме от корена и вървим по ляво или дясно
    поддърво, докато стигнем листо - кодирания символ<br>
    <i>Пример:</i> <font size="+1"><tt>afbabcdefacbabcdecde </tt></font>(дължина




    20)<br>
    Пресмятаме вероятностите:<br>
    a - 4 пъти: вероятност 4/20 = 0.2<br>
    b - 4 пъти:&nbsp; вероятност 4/20 = 0.2<br>
    c - 4 пъти:&nbsp; вероятност 4/20 = 0.2<br>
    d - 3 пъти: вероятност 3/20 = 0.15<br>
    e - 3 пъти: вероятност 3/20 = 0.15<br>
    f - 2 пъти - вероятност 2/20 = 0.10<br>
    <br>
    Началнa гора (6 дървета):<br>
    &nbsp;(a: 0,20)&nbsp; <br>
    (b: 0,20)&nbsp; <br>
    (c: 0,20)&nbsp; <br>
    (d: 0,15)&nbsp; <br>
    (e: 0,15)&nbsp; <br>
    (f: 0,10)<br>
    Обединяваме e и f (5 дървета) - в [] са наследниците на възела:<br>
    (a: 0.20)&nbsp; <br>
    (b: 0.20)&nbsp; <br>
    (c: 0.20)&nbsp; <br>
    (d: 0.15)&nbsp; &nbsp; <br>
    (e,f: 0.25)[(e: 0.15) , (f: 0.10)]<br>
    Обединяваме c и d (4 дървета):<br>
    (a: 0.20)&nbsp; <br>
    (b: 0.20)&nbsp; <br>
    (cd: 0.35)[(c: 0.20), (d: 0.15)]&nbsp; &nbsp; <br>
    (ef: 0.25)[(e: 0.15) , (f: 0.10)]<br>
    Обединяваме a и b (3 дървета):<br>
    (ab: 0.40)[(a: 0.20), (b: 0.20)]&nbsp; <br>
    (cd: 0.35)[(c: 0.20), (d: 0.15)]&nbsp; &nbsp; <br>
    (ef: 0.25)[(e: 0.15), (f: 0.10)]<br>
    Обединяваме cd и ef (2 дървета):<br>
    (ab: 0.40)[(a: 0.20), (b: 0.20)]<br>
    (cdef, 0.60)[(cd: 0.35)[(c: 0.20), (d: 0.15)], (ef: 0.25)[(e: 0.15),
    (f: 0.10)]]<br>
    Обединяваме двете дървета:<br>
    (abcdef, 1.00)[(ab: 0.40)[(a: 0.20), (b: 0.20)], (cdef, 0.60)[(cd:
    0.35)[(c: 0.20), (d: 0.15)], (ef: 0.25)[(e: 0.15), (f: 0.10)]]]<br>
    <img src="images/hufman.png" alt="hufman" width="463" height="274"><br>
    Кодиране:<br>
    Кодовете на символите са:&nbsp; a = 00, b = 01, c = 100, d = 101, e
    = 110 и f = 111.<br>
    Кодът на съобщението от условието на задачата е:<br>
    00 111 01 00 01 100 101 110 111 00 100 01 00 01 100 101 110 100 101
    110<br>
    или <br>
    0011101000110010111011100100010001100101110100101110<br>
    Компресия на Хъфман: 52 бита за 20 символа - 52/20 = 2.6 бита на
    символ срещу 8 бита (min 4 бита) за символ.<br>
    Декодиране:<br>
    От корена 00 значи ляво-ляво, достигаме до a, отново тръгваме от
    корена 111, достигаме до f и т.н.<br>
    <a href="https://demo.tinyray.com/huffman">Визуализация</a><br>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Програмиране = ++Алгоритми; (Programming = ++Algorithms;)</title>
    <hr size="2" width="100%"><b>** Код с разделители</b> [10.4.4]<b><br>
    </b><i>Задача:</i><b> </b>Кодиране с надежден код - промяна на един
    бит да довежда до невъзможност за декодиране на най-много една-две
    букви.<br>
    <i>Алгоритъм:</i> Всяка буква се записва в еднакъв брой битове
    (равномерни кодове).<br>
    <i>Пример:</i> Дадено е входно съобщение със следните символи и
    честоти: (a: 0,4), (b: 0,2), (c: 0,2), (d: 0,15) и (e: 0,05). Ако
    използваме 3 бита за всяка буква (равномерен код), получаваме цена
    3.<br>
    При кодиране по Хъфман, получаваме кода: (a = 11), (b = 10), (c =
    01), (d = 001), (e = 000) с цена:<br>
    L = 2.0,4 + 2.0,2 + 2.0,2 + 3.0,15 + 3.0,05 = 2,2<br>
    <br>
    Не бихме ли могли да получим код, съчетаващ висока надеждност и
    относително добра ефективност, заемащ междинно положение между
    равномерните кодове и кодирането по Хъф- ман? Пример за такъв код е
    така нареченият код с разделители (англ. comma code). <br>
    <i>Алгоритъм:</i> Кодът на всеки символ завършва с разделител,
    указващ края му (код с разделители). Сортираме буквите по вероятност
    на срещане. На първия символ съпоставяме код 1, на втория - 01, на
    третия - 001, на четвъртия - 0001 и т.н. Очевидно така
    конструираният код е префиксен, позволява бързо и еднозначно
    декодиране и в общия случай е по-ефективен от равномерните кодове.
    Повреждането на единствен бит води до невъзможност за декодиране на
    най-много две букви.<br>
    <i>Пример:</i> За горния пример получаваме кода: a = 1, b = 01, c =
    001, d = 0001, e = 00001 с цена:<br>
    L = 1.0,4 + 2.0,2 + 3.0,2 + 4.0,15 + 5.0,05 = 2,25<br>
    Получихме сравнително надежден код с ефективност, близка до тази на
    кода на Хъфман.<br>
    <hr size="2" width="100%">
  </body>
</html>
