<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>lec3</title>
  </head>
  <body>
    <font size="+1"> </font>
    <h3><font size="+1">3. Динамично оптимиране - други задачи</font></h3>
    <p><i>План:<br>
        Задачи за домашно 1 и 2<br>
      </i>Домино подредица<br>
      Разстояние на Левенщайн<br>
      <i>Задачи за домашно 3 и 4<br>
      </i></p>
    <hr size="2" width="100%"><font size="+1">**<b>Домино подредица</b>
      [8.4.12, стр. 541] <br>
      <br>
      Домино-редица ще наричаме редица от естествени числа, за която
      най-старшата цифра на i-тия член съвпада <br>
      с най-младшата на (i–1)-ия. <br>
      <br>
      <i>Пример 1: </i><br>
      34 402 2 29 91 11 1<br>
      <br>
      Задача: По зададена редица X(n)&nbsp; x<sub>1</sub>, x<sub>2</sub>,
      ..., x<sub>n</sub> от естествени числа да се намери нейна
      максимална по дължина домино-подредица.<br>
      <br>
      <i>Пример 2:</i><br>
      &nbsp;25 62 36 51 12 6 33 22 <br>
      [1&nbsp;&nbsp; 2&nbsp;&nbsp; 3&nbsp;&nbsp; 4&nbsp;&nbsp;
      5&nbsp;&nbsp; 6&nbsp; 7&nbsp;&nbsp; 8]<br>
      <br>
      Да разгледаме редицата X(k)&nbsp; x<sub>k</sub>, x<sub>k+1</sub>,
      ..., x<sub>n</sub>. С F(i, k) означаваме максималната дължина на
      домино-редица, подредица на X(k),&nbsp; и с първа цифра i на
      първия член на домино-редицата.<br>
      i = 0, 1, 2, ...., 9; k = 1, 2, ..., n<br>
      <i><br>
        Пример 2:</i><br>
      F(1, 8) = F(1, 7) = F(1, 6) = 0;&nbsp; F(1, 5) = F(1, 4) = F(1, 3)
      = F(1, 2) = F(1, 1) = 2; 12 22<br>
      F(2, 8) = F(2, 7) = F(2, 6) =&nbsp; F(2, 5) = F(2, 4) = F(2, 3) =
      F(2, 2) = 1, F(2, 1) = 4; 25 51 12 22<br>
      ...<br>
      Решението на задачата ще бъде най-голямото от числата F(1, 1),
      F(2, 1), ..., F(9, 1).<br>
      <br>
      Означаваме с l(k) първата цифра на числото x<sub>k</sub> и с r(k)
      - последната цифра на x<sub>k</sub>.<br>
      <br>
      Рекурентните равенства са:<br>
      <br>
      F(i, k) = F(i, k + 1), ако l(k) != i;<br>
      F(i, k) = max{F(i, k + 1), 1 + F(r(k), k + 1)}, ако&nbsp; l(k) =
      i;<br>
      F(i, 1) е или 0 или 1.<br>
      <i><br>
        Пример 2:<br>
      </i>F(1, 5) = max{F(1, 6), 1 + F(2, 6)} = 2<br>
      F(2, 1) = max{F(2, 2), 1 + F(5, 2)} = 4<br>
    </font>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Програмиране = ++Алгоритми; (Programming = ++Algorithms;)</title>
    <hr style="width: 100%; height: 2px;"><font size="+1"> ** <b>Разстояние








        на Левенщайн</b> [Edit distance, AL p. 74]<br>
      <br>
      Разстояние на Левенщайн между два низа е минималният брой операции
      за редактиране, необходими за преобразуване на низ в друг низ.
      Операциите за редактиране са:<br>
      <br>
      • insert - добавя символ (например ABC -&gt; ABCA)<br>
      • remove - изтрива символ (например ABC -&gt; AC)<br>
      • modify - замества един символ с друг (например ABC -&gt; ADC)<br>
      <br>
      Например разстоянието между LOVE и MOVIE е 2, защото можем първо
      да извършим операцията LOVE -&gt; MOVE (modify) и след това
      операцията MOVE -&gt; MOVIE (insert). <br>
      Това е най-малкият възможен брой операции, защото е ясно, че само
      една операция не е достатъчна.<br>
      <br>
    </font>
    <hr size="2" width="100%">
  </body>
</html>
