<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <title>lec8</title>
  </head>
  <body>
    <h2>8.&nbsp; Sorting by comparison and transformation<br>
    </h2>
    Sorting
    <p><big>Sorting - General; sort by comparison<br>
        <br>
        ** Classifications of sorting algorithms [Chapter 3, p.187]<br>
        <br>
        * Depending on the location of the data:<br>
        &nbsp;- internally (direct/random access), eg Quicksort, and<br>
        &nbsp;- external (sequential access), eg Mergesort.<br>
        * Depending on the operation:<br>
        &nbsp;- by comparing (&lt;, &gt; and ==) pairs of elements and<br>
        &nbsp;- by transformation, e.g. sort by count.<br>
        * Sorting algorithm property:<br>
        &nbsp;- stable - the relative order of the elements with equal
        keys remains unchanged and<br>
        &nbsp;- unstable - moving elements with equal keys<br>
        * Sorting algorithms efficiency - number of comparisons and
        swaps (assignments).<br>
        * Use of extra memory.<br>
      </big></p>
    <p><big>** Comparison tree; sort 3 numbers.<br>
        <br>
        ** Classical universal "elementary" </big><font size="+1"><span
          style="font-style: italic;">O</span>(<span style="font-style:
          italic;">n</span><sup>2</sup>)</font> <big>sorting methods:<br>
        &nbsp;- Insertionsort - we find an item that is "not sorted" and
        put it in its place in the sorted part;<br>
        &nbsp;- Selectionsort - we find the smallest element and put it
        in its place in the finally sorted part;<br>
        &nbsp;- the bubble - pairs of elements are examined sequentially
        and possibly swaps.<br>
        <br>
        ** Quick sort of Hooray - <i>O</i>(<i>n</i>log<i>n</i>) average
        and <i>O</i>(<i>n</i><sup>2</sup>) at worst case.<br>
        <br>
        ** Pyramidsort, Mergesort: </big><font size="+1"><i>O</i>(<i>n</i>log<i>n</i>)
        a</font><big>nd this estimate cannot be improved by sorting by
        comparison.<br>
      </big></p>
    <big> </big>
    <h4 style="font-weight: normal;"><big>** <font color="#000000">Sorting
          by transformation [3.2]</font> </big></h4>
    <big>** Sorting by set [3.2.1]<br>
      &nbsp;&nbsp;&nbsp; Let&nbsp; <span style="font-style: italic;">M</span>
      be a set of numbers in the closed interval [<span
        style="font-style: italic;">a, b</span>] and и инективна функция
      за нареждане <span style="font-style: italic;">f:</span> <span
        style="font-style: italic;">M <span style="font-family:
          monospace;">-&gt;</span> </span>[<span style="font-style:
        italic;">a, b</span>] be a injective ordering function,
      i.e.&nbsp; if <span style="font-style: italic;">x</span><sub>1</sub>
      and <span style="font-style: italic;">x</span><sub>2</sub> are
      different, then <span style="font-style: italic;">f</span> (<span
        style="font-style: italic;">x</span><sub>1</sub>) and <span
        style="font-style: italic;">f</span> (<span style="font-style:
        italic;">x</span><sub>2</sub>) are different too.<span
        style="font-style: italic;"><br>
      </span>We construct a zero array S with indices from <i>a</i> to
      <i>b</i> and with one pass through the set <i>M</i> we set values
      1 to <i>S</i> [<i>f</i> (<i>x</i>)] for each <i>x</i> of <i>M</i>.
      Then we pass through the array <i>S</i> to arrange the elements
      of <i>M</i>.</big><br>
    <big>
      <meta charset="utf-8">
      <a href="https://en.wikipedia.org/wiki/Injective_function">https://en.wikipedia.org/wiki/Injective_function</a></big><br>
    <big>
      <meta charset="utf-8">
      <a href="https://en.wikipedia.org/wiki/Surjective_function">https://en.wikipedia.org/wiki/Surjective_function</a></big><br>
    <big>
      <meta charset="utf-8">
      <a href="https://en.wikipedia.org/wiki/Bijection">https://en.wikipedia.org/wiki/Bijection</a><br>
      Runtime is <span style="font-style: italic;">O</span>(<span
        style="font-style: italic;">m+n</span>)<span style="font-style:
        italic;">, </span>where<span style="font-style: italic;"> n </span>is
      the number of elements of<span style="font-style: italic;"> M</span>,&nbsp;<span
        style="font-style: italic;"> m = b - a +</span> 1<span
        style="font-style: italic;">.</span><span style="font-style:
        italic;"></span> <br>
      ** Sorting by counting [3.2.2] <br>
      ** Bit sorting [3.2.3] <br>
      ** Numerical systems method [3.2.4] <br>
      ** Sorting by permutation [3.2.5]<br>
      <br>
      &nbsp;&nbsp; Let <span style="font-style: italic;">M</span> be a
      set of<span style="font-style: italic;"> n</span> elements. Denote
      by <span style="font-style: italic;">S</span> the set {1, 2, 3,
      ..., <span style="font-style: italic;">n</span>}<span
        style="font-style: italic;">.</span>&nbsp; The ordering
      function&nbsp; <span style="font-style: italic;">f:</span> <span
        style="font-style: italic;">S <span style="font-family:
          monospace;">-&gt;</span> </span><span style="font-style:
        italic;">S</span> is bijective (injective and surjective), i.e.
      if <span style="font-style: italic;">x</span><sub>1</sub> and <span
        style="font-style: italic;">x</span><sub>2</sub> are </big><big>different,
      then <span style="font-style: italic;">f</span> (<span
        style="font-style: italic;">x</span><sub>1</sub>) and <span
        style="font-style: italic;">f</span> (<span style="font-style:
        italic;">x</span><sub>2</sub>) are different too and for every</big><big>
      <span style="font-style: italic;">y</span> in <span
        style="font-style: italic;">S</span> there exists <span
        style="font-style: italic;">x</span> in <span
        style="font-style: italic;">S</span> such thst&nbsp; <span
        style="font-style: italic;">y</span> = <span style="font-style:
        italic;">f</span> (<span style="font-style: italic;">x</span>).<br>
      <br>
      &nbsp;&nbsp;&nbsp; Разменяме <span style="font-family:
        monospace;">m[1]</span> с <span style="font-family: monospace;">m[m[1]]</span>
      докато на <span style="font-family: monospace;">1</span>-во място
      не дойде <span style="font-family: monospace;">1</span>. После по
      същия начин с втория елемент и т.н.<br>
      <span style="font-family: monospace;">позиции <span
          style="text-decoration: underline;">1234567</span></span><br
        style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

















        <span style="font-weight: bold;">4</span>37<span
          style="font-weight: bold;">5</span>612</span><br>
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

















        <span style="font-weight: bold;">5</span>374<span
          style="font-weight: bold;">6</span>12</span><br>
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

















        <span style="font-weight: bold;">6</span>3745<span
          style="font-weight: bold;">12</span></span><br>
      <span style="font-family: monospace;"><span style="font-weight:
          bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>1<span
          style="font-weight: bold;">37</span>4562</span><br>
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

















        1<span style="font-weight: bold;">7</span>3456<span
          style="font-weight: bold;">2</span></span><br>
      <span style="font-family: monospace;"><span style="font-weight:
          bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>1234567<span
          style="font-weight: bold;"> </span></span><br>
      <span style="font-family: monospace;"><span style="font-weight:
          bold;"></span></span>Броят на размените не недвишава <span
        style="font-style: italic;">n</span>, а броят на сравненията - 2<span
        style="font-style: italic;">n.<br>
      </span></big><big><span style="font-weight: bold;"></span></big>
    <hr style="width: 100%; height: 2px;">
    <h3>Бързо сортиране</h3>
    <font size="+1">&nbsp;А. Разделяне на дялове: <br>
      &nbsp;1. Избираме случаен елемент </font><font size="+1"><span
        style="font-family: monospace;">x</span></font><font size="+1">
      от масива </font><font size="+1"><span style="font-family:
        monospace;">a</span></font><font size="+1"> <br>
      &nbsp;2. Преглеждаме масива отляво (от началото), докато достигнем
      до елемент </font><font size="+1"><span style="font-family:
        monospace;">&gt;</span></font><font style="font-family:
      monospace;" size="+1"> x</font><font size="+1"> </font><font
      size="+1"><br>
      &nbsp;3. Преглеждаме масива отдясно (от края), докато достигнем до
      елемент </font><font size="+1"><span style="font-family:
        monospace;">&lt; x </span></font><font size="+1"><br>
      &nbsp;4. Разменяме местата на двата елемента <br>
      <b><tt><font color="#006600">vector&lt;int&gt; a(n);</font></tt></b><br>
      <b><tt><font color="#006600">void partition(int x)</font></tt></b><br>
      <b><tt><font color="#006600">{</font></tt></b><br>
      <b><tt><font color="#006600">&nbsp;int i=1, j=n;</font></tt></b><br>
      <b><tt><font color="#006600">&nbsp;do</font></tt></b><br>
      <b><tt><font color="#006600">&nbsp;{</font></tt></b><br>
      <b><tt><font color="#006600">&nbsp; while (a[i] &lt; x) i++;</font></tt></b><br>
      <b><tt><font color="#006600">&nbsp; while (a[j] &gt; x) j--;</font></tt></b><br>
      <b><tt><font color="#006600">&nbsp; if (i&lt;=j)</font></tt></b><b><tt><font
            color="#006600"> { swap(a[i], a[j]);&nbsp; i++; j--; }</font></tt></b><br>
      <b><tt><font color="#006600">&nbsp;}</font></tt></b><br>
      <b><tt><font color="#006600">&nbsp;while (i&lt;=j);</font></tt></b><br>
      <b><tt><font color="#006600">}</font></tt></b></font>
    <p><font size="+1">Б. Сортиране - след като масивът се раздели,
        двата му дяла се подлагат на същата обработка и това продължава,
        докато се получат дялове само с по един елемент. </font><br>
    </p>
    <p><b><tt><font color="#000099"><span style="color: rgb(204, 0, 0);">//

















              <big><a href="sources/qsort.cpp">qsort.cpp</a></big></span><br>
            <font size="+1">void quicksort(int left, int right)</font></font></tt></b>
      <font size="+1"><br>
        <b><tt><font color="#000099">{</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;int i=left, j=right;</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;int x=a[(i + j)/2];</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;do</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;{</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp; while (a[i] &lt; x) i++;</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp; while (a[j] &gt; x) j--;</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp; if (i&lt;=j)</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp; { swap(a[i], a[j]); i++;
              j--; }</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;}</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;while (i&lt;=j);</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;if (left&lt;j)
              quicksort(left, j);</font></tt></b><br>
        <b><tt><font color="#000099">&nbsp;if (i&lt;right) quicksort(i,
              right);</font></tt></b><br>
        <b><tt><font color="#000099">}</font></tt></b></font> <br>
    </p>
    <p><big>Сортиране чрез сливане<br>
      </big></p>
    <a style="font-family: monospace;" href="sources/mergesort.cpp"><big>mergesort.cpp</big></a><br>
    <hr size="2" width="100%">
    <h3><a href="../../../2012/WCP/STL/STL.pdf">Въведение в STL</a></h3>
    <h3>Deitel&amp;Deitel,&nbsp; <a
        href="../../../2005/oop/deitel/cpphtp4_PPT_21.ppt">Chapter 21 -
        Standard Template Library (STL)</a><br>
    </h3>
    <h3>Сортиране в STL <br>
    </h3>
    <big>- <tt>sort, qsort </tt><br>
      - контейнер <tt>set</tt></big><br>
    <hr style="width: 100%; height: 2px;">
  </body>
</html>
