/*
 Дадена е числова редица $a_1, a_2, ..., a_n$ от която можем да получим нова редица $b_1, b_2, ..., b_m$ по следния начин:
        $b_1 = |a_1 - a_2|, b_2 = |a_3 - a_4|, b_3 = |a_5 - a_6|$, и т.н.
 Ако $n$ четно число, $m = n/2$ и $b_m = |a_{n-1} - a_n|$. Ако $n$ е нечетно число, тогава $b_m = a_n$.
 Напишете програма, която прилага описания алгоритъм няколко пъти, докато редицата остане само с един елемент.
 
 Вход
 На стондартния вход за всеки тестов пример се задва числото $n$ и елементите на редицата -- $n$ цели положителни числа.
 
 $0 < n < 1000$<br>
 $0 < a_i < 1000, i = 1, 2, ..., n$
 
 Изход
 За всеки тестов пример на отделен ред да се изведе стойността на единствения елемент на последната получена редица.
 
 Пример
 Вход
 4
 1 6 20 11
 3
 8 7 5
 Изход
 4
 4
 
 Обяснение:
 За първия пример редиците са:
 1 6 20 10
 5 9
 4
 За втория пример са:
 8 7 5
 1 5
 4
 */

#include <iostream>
#include <vector>
using namespace std;

int aabs(int k)
{
    return (k > 0 ? k : -k);
}

int n;
int a[1001];

int main(void)
{
    while (cin >> n)
    {
        for (int i=0; i<1001; i++) a[i] = 0;
        for (int i=0; i<n; i++) cin >> a[i];
        do
        {
            if (n%2) n++;
            for (int j=0, jj = 0; j < n; j+=2, jj++)
            {
                a[jj] = aabs(a[j] - a[j+1]);
                a[j+1] = 0;
//                cout << a[jj] << " ";
            }
//            cout << endl;
            n = n/2;
        }
        while(n > 1);
        cout << a[0] << endl;
    }
    return 0;
}
