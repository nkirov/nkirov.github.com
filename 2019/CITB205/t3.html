<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="GENERATOR" content="Mozilla/4.75 [en] (Win98; U)
      [Netscape]">
    <title>Тest 3</title>
  </head>
  <body>
    <center>ТЕСТ 3<br>
      <b>въпросите на теста, един верен отговор (да), и един грешен
        "отговор" (не)</b> </center>
    <hr size="2" width="100%">Отбележете верни/грешни твърдения от
    текста на програмата за реализация на двусвързан списък, дадена във
    файла <font size="+1"><tt>list1.cpp</tt></font><br>
    (да)
    <meta name="qrichtext" content="1">
    Конструкторът по подразбиране (без параметри) на класа <font
      size="+1"><tt>List&lt;T&gt;</tt></font>конструира празен свързан
    списък.
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
p, li { white-space: pre-wrap; }
</style><br>
    (не) Деструкторът на класа <font size="+1"><tt>List&lt;T&gt;</tt></font>
    се извиква автоматично във функцията <font size="+1"><tt>erase</tt></font>.<br>
    <hr size="2" width="100%">Може ли в текста на програмата, дадена във
    файла <font size="+1"><tt>inh_t.cpp</tt></font> да се добави
    следната дефиниция на нов клас:<br>
    (да)
    <meta name="qrichtext" content="1">
    <font size="+1"><tt>class Boo : public A&lt;int&gt; {...};</tt></font>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
p, li { white-space: pre-wrap; }
</style><br>
    (не)
    <meta name="qrichtext" content="1">
    <font size="+1"><tt>class Bee : public A&lt;T&gt; {...};</tt></font>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
p, li { white-space: pre-wrap; }
</style>
    <hr size="2" width="100%">Управлението на паметта е важна част от
    ООП. Нека даден клас използва динамична памет. Вярно ли е?<br>
    (да)
    <meta name="qrichtext" content="1">
    Почленната операция присвояване (между обекти от този клас) води до
    загуба на памет (memory leak).
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
p, li { white-space: pre-wrap; }
</style><br>
    (не)
    <meta name="qrichtext" content="1">
    Управлението на паметта се отнася и за системния стек.
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
p, li { white-space: pre-wrap; }
</style>
    <hr size="2" width="100%">
    <meta name="qrichtext" content="1">
    <p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><!--StartFragment-->Има ли синтактична грешка дадения оператор?<!--EndFragment--></p>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
p, li { white-space: pre-wrap; }
</style>(не)
    <meta name="qrichtext" content="1">
    <font size="+1"><tt>if(catch &gt; 2) do = 2;</tt></font>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
p, li { white-space: pre-wrap; }
</style><br>
    (да) <font size="+1"><tt>class B;</tt></font><br>
    <hr size="2" width="100%">Даден е класа:<br>
    <font size="+1"><tt>class&nbsp; Btree{</tt><tt><br>
      </tt><tt> public:</tt><tt><br>
      </tt><tt> &nbsp;&nbsp;&nbsp; Btree();</tt><tt><br>
      </tt><tt> &nbsp;&nbsp;&nbsp; Btree(const Btree&amp; b);</tt><tt><br>
      </tt><tt> &nbsp;&nbsp;&nbsp; ~Btree();</tt><tt><br>
      </tt><tt> &nbsp;&nbsp;&nbsp; Btree&amp; operator=(const Btree&amp;
        b);</tt><tt><br>
      </tt><tt> private:</tt><tt><br>
      </tt><tt> ...</tt><tt><br>
      </tt><tt> };</tt></font><br>
    и обект <font size="+1"><tt>b </tt></font>от този клас. Проверете
    твърденията за оператори от функция <tt><font size="+1">main</font></tt>:<br>
    (да) В оператора <font size="+1"><tt>Btree b1(b);</tt></font> се
    извиква конструктора за копиране.<br>
    (не) В оператора <font size="+1"><tt>Btree b1 = b;</tt></font> се
    извиква предефинираната операция присвояване.<br>
    <hr size="2" width="100%">Може ли даденият ред от програма да бъде
    дефиниция на деструктор? <br>
    (да) <font size="+1"><tt>Department::~Department() {}</tt> </font><br>
    (не) <font size="+1"><tt>Dep::~Dep(int i) { cout &lt;&lt; i; }</tt></font><br>
    <hr size="2" width="100%">
    <meta name="qrichtext" content="1">
    <p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><!--StartFragment-->Даден е клас-шаблон:</p>
    <p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font size="+1"><tt>template&lt;typename T, int R, int C&gt;</tt></font></p>
    <font size="+1"><tt> </tt></font>
    <p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font size="+1"><tt>class Matrix {</tt></font></p>
    <font size="+1"><tt> </tt></font>
    <p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font size="+1"><tt>public:</tt></font></p>
    <font size="+1"><tt> </tt></font>
    <p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font size="+1"><tt>     Matrix();</tt></font></p>
    <font size="+1"><tt> </tt></font>
    <p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font size="+1"><tt>private:</tt></font></p>
    <font size="+1"><tt> </tt></font>
    <p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font size="+1"><tt>     T* data[R][C];</tt></font></p>
    <font size="+1"><tt> </tt></font>
    <p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font size="+1"><tt>};</tt></font></p>
    <p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Определете верни и неверни дефиниции на обекти от този клас.<br>(да) <font size="+1"><tt>Matrix&lt;int, 2, 2&gt; m;</tt></font><br>(не) <font size="+1"><tt>Matrix mm;</tt></font><br><!--EndFragment--></p>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
p, li { white-space: pre-wrap; }
</style>
    <hr size="2" width="100%">Отбележете верни/неверни твърдения за
    класове-шаблони. <br>
    (да) Клас-шаблон е механизъм, който позволява да се създават
    класове, чиито членове-данни са от произволен тип. <br>
    (не) Член-функция на клас-шаблон може да се дефинира като обикновена
    (не шаблон) функция.
    <hr size="2" width="100%">Нека е даден следния клас-шаблон: <br>
    <tt>template </tt><typename t=""><tt>&lt;typename T&gt;<br>
        class Temp { </tt><tt><br>
      </tt><tt>public: </tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp; </tt><tt>Temp(T t) <br>
        &nbsp;&nbsp;&nbsp; { <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; data = new T(t); <br>
        &nbsp;&nbsp;&nbsp; } </tt><tt><br>
      </tt><tt>private: </tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp; </tt><tt>T* data; </tt><tt><br>
      </tt><tt>}; </tt><br>
      Може ли в класа да се добави деклaрация/дефиниция на следната
      функция: <br>
      (да) <tt>T get() const { return *data; } </tt><br>
      (не) <tt>Temp go();</tt> <br>
      <hr size="2" width="100%">Даден е клас <tt><font size="+1">A</font></tt>
      и вложен в него клас </typename><typename t=""><tt><font
          size="+1">B</font></tt>. <br>
      <font size="+1"><tt>template &lt;typename T&gt;</tt><tt><br>
        </tt></font><font size="+1"><tt>class А {</tt></font><font
        size="+1"><tt><br>
        </tt></font><font size="+1"><tt>public:</tt></font><font
        size="+1"><tt><br>
        </tt></font><font size="+1"><tt>&nbsp;&nbsp; class B;</tt></font><font
        size="+1"><tt><br>
        </tt></font><font size="+1"><tt>&nbsp;&nbsp;&nbsp; ...</tt></font><font
        size="+1"><tt><br>
        </tt></font><font size="+1"><tt>};</tt></font><br>
      Верни ли са твърденията?<br>
      (да) Дефиниция на обект <font size="+1"><tt>b</tt></font> от клас
      <font size="+1"><tt>B</tt></font> главната функция може да бъде <font
        size="+1"><tt>A::B b</tt></font>.<br>
      (не) Дефиниция на обект <font size="+1"><tt>b</tt></font> от клас
      <font size="+1"><tt>B</tt></font> главната функция може да бъде <font
        size="+1"><tt>B b</tt></font>.<br>
      <hr size="2" width="100%">Отбележете верни/неверни твърдения за
      обработка на изключения.<br>
      (да) Когато дадена функция открие грешка, тя може да изхвърли
      изключение към някоя друга част на програмата, чиято работа е да
      обработва грешки.&nbsp; <br>
      &nbsp;(не) Ключовата дума <tt>throw</tt> показва, че изпълнението
      на функциятя спира незабавно и управлението се предава на
      извикващата функция.<br>
      <hr size="2" width="100%">Дадена е следната част от програма:<br>
      <tt>void fun3() <br>
        { <br>
        &nbsp;&nbsp;&nbsp; throw runtime_error("RTE" ); <br>
        }<br>
        void fun2() throw(runtime_error) <br>
        { <br>
        &nbsp;&nbsp;&nbsp; // блок на функцията<br>
        }<br>
        void fun1() throw(runtime_error) <br>
        { <br>
        &nbsp;&nbsp;&nbsp; fun2(); <br>
        } <br>
        int main()<br>
        { <br>
        &nbsp;&nbsp;&nbsp; try <br>
        &nbsp;&nbsp;&nbsp; { <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fun1(); <br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; catch (runtime_error e) <br>
        &nbsp;&nbsp;&nbsp; { <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cout&lt;&lt;e.what(); <br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return 0; <br>
        }</tt><br>
      Поставете в блока на функцията f<tt>un2</tt> дадения оператор или
      дадените оператори и отбележете с "да" случая на отпечатване на
      съобщение <tt>RTE</tt> при изпълнението на програмата. <br>
      (да) <tt>fun3();</tt><br>
      (не) <tt>fun1();</tt><br>
      <hr width="100%">Дадена е част от програма:<br>
      <tt>class Vec {<br>
        public:<br>
        &nbsp;&nbsp; class Range {<br>
        &nbsp;&nbsp; public:<br>
        &nbsp;&nbsp;&nbsp;&nbsp; int index;<br>
        &nbsp;&nbsp;&nbsp;&nbsp; Range(int j):index(j) {} <br>
        &nbsp;&nbsp; };<br>
        &nbsp;&nbsp; int&amp; operator[](int i)<br>
        &nbsp;&nbsp; { <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (0&lt;=i &amp;&amp;
        i&lt;100) return p[i]; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw Range(i); <br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; ... <br>
        };<br>
        void do_any(Vec&amp; w);<br>
        void do_some(Vec&amp; w);<br>
        void f(Vec&amp; v)<br>
        { <br>
        &nbsp; do_any(v);<br>
        &nbsp; try <br>
        &nbsp; { <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do_some(v); <br>
        &nbsp; }<br>
        &nbsp; catch(Vec::Range r)<br>
        &nbsp; { <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cerr &lt;&lt; "ERROR" &lt;&lt;
        r.index; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... <br>
        &nbsp; }<br>
        &nbsp; ...<br>
        }</tt><br>
      Верни ли са следните твърдения?<br>
      (да) <tt>r</tt> е обект от тип <tt>Vec::Range</tt>.<br>
      (не) <tt>r</tt> е обект от тип <tt>Range.<br>
      </tt>
      <hr size="2" width="100%">Посочете верните твърдения за
      многократна и виртуална наследственост.<br>
      (да) Многократна наследственост има, когато производния клас има
      два или повече базови класове.<br>
      (не) <font size="+1"><tt>virtual class E : public P</tt></font>
      определя виртуална наследственост.<br>
      <hr size="2" width="100%">Посочете верните твърдения за получаване
      на информация за типа по време на изпълнение. <br>
    </typename><typename t="">(да) Унарната операция <font size="+1"><tt>dynamic_cast</tt></font>
      изисква тип като параметър на шаблон, и аргумент, който трябва да
      бъде указател или псевдоним (референция). <br>
      (не)<tt><font size="+1"> </font></tt><font size="+1"><tt>typeid</tt></font>
      е бинарна операция. <tt> </tt>
      <hr width="100%"> </typename>
  </body>
</html>
