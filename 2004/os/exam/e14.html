<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
   <meta name="Author" content="Nikolay Kirov">
   <meta name="GENERATOR" content="Mozilla/4.75 [en] (Win98; U) [Netscape]">
   <title>os4</title>
</head>
<body>
<b>14. Конкуренция: взаимно изключване и синхронизация</b>
<br><b>Монитори. Предаване на съобщения. Задачата на бръснаря</b>
<p>5.5 Монитори.
<br>** Монитор със сигнал.
<br>&nbsp;&nbsp;&nbsp; Мониторите са програмни модули, състоящи се от една
или повече процедури, инициализация и локални данни. Главни характеристики:
<br>&nbsp;&nbsp; 1. Локалните данни са достъпни само от процедурите на
монитора.
<br>&nbsp;&nbsp; 2. Един процес "влиза в монитора" като извика някоя от
процедурите му.
<br>&nbsp;&nbsp; 3. Само един процес може да се изпълнява в монитора, всеки
друг процес чака да се "освободи" монитора.
<br>&nbsp;&nbsp;&nbsp; Променливи на условия (condition variables). Функции
с тези променливи:
<br><b><tt><font color="#006600">- cwait(c)</font></tt></b>:&nbsp; Прекратяване
изпълнението на процеса с условие <b><tt><font color="#006600">c</font></tt></b>.&nbsp;
Мониторът е достъпен за друг процес;
<br><b><tt><font color="#006600">- csignal(c)</font></tt></b>: Въобновяване
на изпълнението на процеса, прекратен с <b><tt><font color="#006600">cwait</font></tt></b>
със същото условие. Ако има няколко такива процеса се избира един от тях,
ако няма - нищо не се прави.
<br>&nbsp;&nbsp;&nbsp; Разлика със семафорите - сигналът се "загубва",
ако няма чакащи процеси за този сигнал.
<br>--- <a href="http://www.math.bas.bg/~nkirov/bfu/Os/F5-22.PDF">FIGURE
5.22</a> ---
<br><b><tt><font color="#003300">/* program producerconsumer */</font></tt></b>
<br><b><tt><font color="#003300">monitor boundedbuffer;</font></tt></b>
<br><b><tt><font color="#003300">char buffer[N];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* space for N items */</font></tt></b>
<br><b><tt><font color="#003300">int nextin, nextout;&nbsp;&nbsp;&nbsp;
/* buffer pointers */</font></tt></b>
<br><b><tt><font color="#003300">int count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* number of items in buffer */</font></tt></b>
<br><b><tt><font color="#003300">int notfull, notempty;&nbsp; /* for synchronization
*/</font></tt></b>
<table BORDER CELLSPACING=0 CELLPADDING=4 COLS=2 WIDTH="100%" >
<tr>
<td VALIGN=TOP><b><tt><font color="#003300">void append (char x)</font></tt></b>
<br><b><tt><font color="#003300">{</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;if (count == N)</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;cwait(notfull); /* buffer is оull;*/</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* avoid overflow */</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;buffer[nextin] = x;</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;nextin = (nextin + 1) % N;</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;count++; /* one more item in buffer
*/</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;csignal(notempty);&nbsp;</font></tt></b>
<br><b><tt><font color="#003300">/* resume any&nbsp; waiting consumer */</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b></td>

<td VALIGN=TOP><b><tt><font color="#003300">void take (char x)</font></tt></b>
<br><b><tt><font color="#003300">{</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;if (count == 0)</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;cwait(notempty); /* buffer is empty;*/</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* avoid underflow */</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;x = buffer[nextout];</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;nextout = (nextout + 1) % N;</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;count--; /* one fewer item in buffer
*/</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;csignal(notfull);&nbsp;</font></tt></b>
<br><b><tt><font color="#003300">/* resume any&nbsp; waiting producer */</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b></td>
</tr>
</table>
<b><tt><font color="#003300">{</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;/* monitor body */</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;nextin = 0; nextout = 0; count =
0; /* buffer initially empty */</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b>
<table BORDER CELLSPACING=0 CELLPADDING=4 COLS=2 WIDTH="100%" >
<tr>
<td><b><tt><font color="#003300">void producer()</font></tt></b>
<br><b><tt><font color="#003300">{ char x;</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; while (true)</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; {</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;&nbsp; produce(x);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;&nbsp; append(x);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; }</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b></td>

<td><b><tt><font color="#003300">void consumer()</font></tt></b>
<br><b><tt><font color="#003300">{ char x;</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; while (true)</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; {</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;&nbsp; take(x);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;&nbsp; consume(x);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; }</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b></td>
</tr>
</table>
<b><tt><font color="#003300">void main()</font></tt></b>
<br><b><tt><font color="#003300">{ parbegin(producer, consumer);</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b>
<br>** Монитори със съобщения и разпространение.
<br>
<hr WIDTH="100%">
<br>5.6 Предаване на съобщения.
<br>&nbsp;&nbsp;&nbsp; Синхронизация и комуникация са двата проблема на
взаимодействащи си процеси - взаимно изключване и обмен на информация.
Двете задачи се решават с обмен на съобщения. Дефинират се два примитива
(процедури):
<br><b><tt><font color="#006600">send(destination, message)</font></tt></b>
<br><b><tt><font color="#006600">receive(source, message)</font></tt></b>
<br>Съществуват различини възможности за реализация на тези 2 процедури:
<br>&nbsp;
<table BORDER CELLPADDING=4 WIDTH="100%" >
<tr>
<td><b>Synchronization</b></td>

<td><b>Addressing&nbsp;</b></td>

<td><b>Format</b></td>
</tr>

<tr>
<td>Send</td>

<td>Direct</td>

<td>Content</td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; blocking</td>

<td>&nbsp;&nbsp;&nbsp; send</td>

<td>Length&nbsp;</td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; nonblocking</td>

<td>&nbsp;&nbsp;&nbsp; receive</td>

<td>&nbsp;&nbsp;&nbsp; fixed</td>
</tr>

<tr>
<td>Receive</td>

<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; explicit</td>

<td>&nbsp;&nbsp;&nbsp; variable</td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; blocking</td>

<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implicit</td>

<td></td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; nonblocking</td>

<td>Indirect</td>

<td></td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; test for arrival</td>

<td>&nbsp;&nbsp;&nbsp; static</td>

<td><b>Queuing Discipline</b></td>
</tr>

<tr>
<td></td>

<td>&nbsp;&nbsp;&nbsp; dynamic</td>

<td>FIFO</td>
</tr>

<tr>
<td></td>

<td>&nbsp;&nbsp;&nbsp; ownership</td>

<td>Priority</td>
</tr>
</table>
** Синхронизация.
<br><b><tt>&nbsp;&nbsp;&nbsp; Send</tt></b> -&nbsp; процесът се блокира,
докато събощението бъде получено (blocking send) или процесът не се блокира
(nonblocking send).
<br><b><tt>&nbsp;&nbsp;&nbsp; Receive</tt></b> - ако съобщението е изпратено,
то се получава и процесът продължава. Ако не е изпратено: процесът се блокира
до изпращане и получавене на съобщението (blocking receive) или процесът
продължава, изоставяйки опитите за получаването му (nonblocking receive).
<br>&nbsp;&nbsp;&nbsp; Възможни са 3 комбинации :
<br>-- Blocking send, blocking receive;
<br>-- Nonblocking send, blocking receive - най-често срещано, при грешка,
могат де се генерират много съобщения;
<br>-- Nonblocking send, nonblocking receive.
<br>** Адресиране.
<br>--- FIGURE 5.24 ---
<br>** Формат на съобщенията.
<br>--- FIGURE 5.25 ---
<br>** Дисциплина на опашките.
<p><b>5.6 Задачата на бръснаря.</b>
<br>--- FIGURE 5.16 ---
<br>
<hr WIDTH="100%">
</body>
</html>
