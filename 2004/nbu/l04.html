<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
   <meta name="Author" content="Nikolay Kirov">
   <meta name="GENERATOR" content="Mozilla/4.75 [en] (Win98; U) [Netscape]">
   <title>l04</title>
</head>
<body>

<h4>
4. Оценка и сложност на алгоритми [1.4] - <font color="#990000">28.10.2003</font></h4>
<font color="#000000">Три главни свойства на компютърен алгоритъм:</font>
<li>
<font color="#000000">простота и елегантност;</font></li>

<li>
<font color="#000000">коректност;</font></li>

<li>
<font color="#000000">бързодействие.</font></li>

<br><font color="#000000">&nbsp;&nbsp;&nbsp; Нека разгледаме следния програмен
фрагмент:</font>
<p><b><tt><font color="#006600">n = 100;</font></tt></b>
<br><b><tt><font color="#006600">sum = 0;</font></tt></b>
<br><b><tt><font color="#006600">for (i=0; i&lt;n; i++)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;for (j=0; j&lt;n; j++) sum++;</font></tt></b>
<br>&nbsp;
<table CELLPADDING=6 COLS=2 WIDTH="100%" >
<tr>
<td VALIGN=TOP><font color="#000000">Колко бързо ще работи горната програма,
т.е. какви са критериите по-които се определя бързината й? Това, което
можем да направим експериментално е да проверим за колко време ще се изпълни
и ще завърши работата си. За да изследваме по-общо нейното поведение е
възможно да я изпълним за други стойности на <b><tt>n</tt></b> - нека резултатите
от последното са обобщени в следната таблица:</font></td>

<td>
<center><table BORDER CELLSPACING=0 CELLPADDING=6 >
<tr>
<td>Размер на входа
<br><b><tt>n</tt></b></td>

<td>Време за изпълнение
<br>сек.</td>
</tr>

<tr>
<td>10</td>

<td>10<sup>-6</sup></td>
</tr>

<tr>
<td>100</td>

<td>10<sup>-4</sup></td>
</tr>

<tr>
<td>1000</td>

<td>0.01</td>
</tr>

<tr>
<td>10<sup>4</sup></td>

<td>1.071</td>
</tr>

<tr>
<td>10<sup>6</sup></td>

<td>106.5</td>
</tr>

<tr>
<td>10<sup>8</sup></td>

<td>10663.6</td>
</tr>
</table></center>
</td>
</tr>
</table>
<font color="#000000">От таблицата се вижда, че когато увеличаваме <b><tt>n</tt></b>
10 пъти, времето за изпълнение се увеличава 100 пъти.</font>
<br><font color="#000000">Времето за изпълнение е пророрционално на <i>f
</i>(<i>n</i>)<i>=
c</i><sub>1</sub><i>n</i><sup>2 </sup>+ <i>c</i><sub>2</sub><i>n</i>+
<i>c</i><sub>3</sub>,
където <i>c</i><sub>1</sub>, <i>c</i><sub>2</sub>,
<i>c</i><sub>3</sub>
са константи, които могат лесно да се определят от дадената част от програмата.</font>
<br>&nbsp;
<table BORDER=0 CELLPADDING=6 COLS=2 WIDTH="100%" >
<tr>
<td VALIGN=TOP><font color="#000000">Сравняване на двете функции
<i>f
</i>(<i>n</i>)<i>=
</i>2<i>n</i><sup>2
</sup>и
<i>g</i>(<i>n</i>)<i>=
</i>200<i>n</i>,
които показват времето за изпълнение на два дадени алгоритъма А<sub>1</sub>
и A<sub>2</sub>, в зависимост от
<i>n</i>.&nbsp;</font>
<br>&nbsp;
<br>&nbsp;
<p>Асимптотично алгоритъмът A<sub>2</sub> е по-бърз и неговата сложност
е линейна, докато тази на A<sub>1</sub> е квадратична.</td>

<td>
<center><table BORDER CELLSPACING=0 CELLPADDING=6 >
<tr>
<td><i><font color="#000000">n</font></i></td>

<td><font color="#000000"><i>f
</i>(<i>n</i>)</font></td>

<td><font color="#000000"><i>g</i>(<i>n</i>)</font></td>
</tr>

<tr>
<td>1</td>

<td>2</td>

<td>200</td>
</tr>

<tr>
<td>10</td>

<td>200</td>

<td>2000</td>
</tr>

<tr>
<td>100</td>

<td>2.10<sup>4</sup></td>

<td>2.10<sup>4</sup></td>
</tr>

<tr>
<td>1000</td>

<td>2.10<sup>6</sup></td>

<td>2.10<sup>5</sup></td>
</tr>

<tr>
<td>10<sup>4</sup></td>

<td>2.10<sup>8</sup></td>

<td>2.10<sup>6</sup></td>
</tr>

<tr>
<td>10<sup>6</sup></td>

<td>2.10<sup>12</sup></td>

<td>2.10<sup>8</sup></td>
</tr>
</table></center>
</td>
</tr>
</table>

<p><font color="#000000">&nbsp;Размер на входните данни</font>
<p><font color="#000000">&nbsp;&nbsp;&nbsp; Нека е дадена задача, в която
размерът на входните данни е определен от дадено цяло число <i>n</i>. Почти
всички задачи, които ще разглеждаме, притежават това свойство. Ще поясним
последното като разгледаме няколко примера:</font>
<p><font color="#000000">Пример 1.</font>
<br><font color="#000000">Да се сортира масив с <i>n</i> елемента.</font>
<br><font color="#000000">Размерът на входните данни се определя от броя
<i>n
</i>на
елементите на масива .</font>
<p><font color="#000000">Пример 2.</font>
<br><font color="#000000">Да се намери най-големият общ делител на <i>a</i>
и <i>b</i>.</font>
<br><font color="#000000">В този пример размерът на входните данни се определя
от броя на двоичните цифри (битовете) на по-голямото от числата <i>a</i>
и <i>b</i>.</font>
<p><font color="#000000">Пример 3.</font>
<br><font color="#000000">Да се намери покриващо дърво на граф.</font>
<br><font color="#000000">В този случай характеризираме размера на входа
с две числа: брой на върховете и брой на ребрата.</font>
<p><font color="#000000">Асимптотична нотация</font>
<p><font color="#000000">&nbsp;&nbsp;&nbsp; Когато се интересуваме от сложността
на алгоритъм най-често се интересуваме как ще работи при достатъчно голям
размер n на входните данни. При формалното оценяване на сложността на алгоритмите
ще се интересуваме от поведението им при <i>n</i> клонящо към безкрайност.</font>
<p><font color="#000000">1.<i> O</i>(<i>F</i>) определя множеството от
всички функции&nbsp; <i>f</i>, които нарастват <b>не</b> по-бързо от <i>F</i>,
т.е. съществува константа <i>c </i>> 0 такава, че <i>f </i>(<i>n</i>) &lt;=
<i>cF</i>(<i>n</i>),
за всички достатъчно големи стойности на
<i>n.</i></font>
<p>2. <i><font face="Symbol">Q </font></i><font color="#000000">(<i>F</i>)
определя множеството от всички функции <i>f</i>, които нарастват толкова
бързо, колкото и <i>F</i> (с точност до константен множител), т.е. съществуват
константи <i>c</i><sub>1</sub><i> </i>> 0 и <i>c</i><sub>2</sub><i> </i>>
0 такава, че <i>c</i><sub>1</sub><i>F</i>(<i>n</i>) &lt;=&nbsp; <i>f </i>(<i>n</i>)
&lt;= <i>c</i><sub>2</sub><i>F</i>(<i>n</i>), за всички достатъчно големи
стойности на
<i>n.</i></font>
<p><font color="#000000">3. <i><font face="Symbol">W </font></i>(<i>F</i>)определя
множеството от всички функции <i>f</i>, които нарастват <b>не</b> по-бавно
от <i>F</i>, т.е. съществува константа <i>c </i>> 0 такава, че
<i>f </i>(<i>n</i>)
>= <i>cF</i>(<i>n</i>), за всички достатъчно големи стойности на
<i>n.</i></font>
<p><font color="#000000"><i>O</i>(<i>F</i>): Свойства и примери</font>
<p><font color="#000000">Нотацията <i>О</i>(<i>F</i>) е най-често използваната
при оценка на сложност на алгоритми и програми.</font>
<br><font color="#000000">По-важни свойства на <i>O</i>(<i>F</i>):</font>
<li>
<font color="#000000">рефлексивност: <i>f</i> <font face="Symbol">О</font><i>О</i>(
<i>f
</i>);</font></li>

<li>
<font color="#000000">транзитивност: ако <i>f</i> <font face="Symbol">О</font><i>О</i>(<i>g</i>),<i>
g</i> <font face="Symbol">О</font><i>О</i>(<i>h</i>), то&nbsp; <i>f</i><font face="Symbol">О</font>
<i>О</i>(<i>h</i>);</font></li>

<li>
<font color="#000000">транспонирана симетрия:&nbsp; ако <i>f</i> <font face="Symbol">О<i>W
</i></font>(<i>g</i>),
то <i>g</i> <font face="Symbol">О</font><i>O</i>(
<i>f </i>) и обратно;</font></li>

<li>
<font color="#000000">константите могат да бъдат игнорирани: за всяко <i>k
> </i>0, <i>kF</i><font face="Symbol">О</font><i>О</i>(<i>F</i>);</font></li>

<li>
<font color="#000000"><i>n</i>, повдигнато в по висока степен, нараства
по-бързо: <i>n<sup>r</sup></i><font face="Symbol">О</font><i>О</i>(<i>n<sup>s</sup></i>),
за 0 &lt; <i>r</i> &lt; <i>s</i>.</font></li>

<li>
<font color="#000000">нарастването на сума от функции се определя от най-бързо
нарастващата от тях: <i>f + g</i> <font face="Symbol">О</font> max(<i>O</i>(
<i>f
</i>),
<i>O</i>(<i>g</i>));</font></li>

<li>
<font color="#000000">ако <i>f</i>(<i>n</i>) е полином от степен <i>d</i>,
то <i>f</i><font face="Symbol">О</font><i>О</i>(<i>n<sup>d</sup></i>);</font></li>

<li>
<font color="#000000">ако <i>f</i> нараства по-бързо от <i>g</i>, а <i>g</i>
нараства по-бързо от <i>h</i>, то следва, че <i>f</i> нараства по-бързо
от <i>h.</i></font></li>

<br>&nbsp;
<p>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p><font color="#000000">Нарастване на най-често използваните функции:</font>
<center><table BORDER CELLSPACING=0 CELLPADDING=4 COLS=6 WIDTH="59%" >
<tr>
<td>
<center>Функция</center>
</td>

<td>
<center>1</center>
</td>

<td>
<center>2</center>
</td>

<td>
<center>10</center>
</td>

<td>
<center>100</center>
</td>

<td>
<center>1000</center>
</td>
</tr>

<tr>
<td>
<center>5</center>
</td>

<td>
<center>5</center>
</td>

<td>
<center>5</center>
</td>

<td>
<center>5</center>
</td>

<td>
<center>5</center>
</td>

<td>
<center>5</center>
</td>
</tr>

<tr>
<td>
<center>log <i>n</i></center>
</td>

<td>
<center>0</center>
</td>

<td>
<center>1</center>
</td>

<td>
<center>3.32</center>
</td>

<td>
<center>6.64</center>
</td>

<td>
<center>9.96</center>
</td>
</tr>

<tr>
<td>
<center><i>n</i></center>
</td>

<td>
<center>1</center>
</td>

<td>
<center>2</center>
</td>

<td>
<center>10</center>
</td>

<td>
<center>100</center>
</td>

<td>
<center>1000</center>
</td>
</tr>

<tr>
<td>
<center><i>n</i> log <i>n</i></center>
</td>

<td>
<center>0</center>
</td>

<td>
<center>2</center>
</td>

<td>
<center>33.2</center>
</td>

<td>
<center>664</center>
</td>

<td>
<center>9996</center>
</td>
</tr>

<tr>
<td>
<center><i>n</i><sup>2</sup></center>
</td>

<td>
<center>1</center>
</td>

<td>
<center>4</center>
</td>

<td>
<center>100</center>
</td>

<td>
<center>10<sup>4</sup></center>
</td>

<td>
<center>10<sup>6</sup></center>
</td>
</tr>

<tr>
<td>
<center><i>n</i><sup>3</sup></center>
</td>

<td>
<center>1</center>
</td>

<td>
<center>8</center>
</td>

<td>
<center>1000</center>
</td>

<td>
<center>10<sup>6</sup></center>
</td>

<td>
<center>10<sup>9</sup></center>
</td>
</tr>

<tr>
<td>
<center>2<i><sup>n</sup></i></center>
</td>

<td>
<center>2</center>
</td>

<td>
<center>4</center>
</td>

<td>
<center>1024</center>
</td>

<td>
<center>10<sup>30</sup></center>
</td>

<td>
<center>10<sup>300</sup></center>
</td>
</tr>

<tr>
<td>
<center><i>n</i>!</center>
</td>

<td>
<center>1</center>
</td>

<td>
<center>2</center>
</td>

<td>
<center>3628800</center>
</td>

<td>
<center>10<sup>157</sup></center>
</td>

<td>
<center>10<sup>2567</sup></center>
</td>
</tr>

<tr>
<td>
<center><i>n<sup>n</sup></i></center>
</td>

<td>
<center>1</center>
</td>

<td>
<center>4</center>
</td>

<td>
<center>10<sup>10</sup></center>
</td>

<td>
<center>10<sup>200</sup></center>
</td>

<td>
<center>10<sup>3000</sup></center>
</td>
</tr>
</table></center>

<p><font color="#000000">Определяне на сложност на алгоритъм:</font>
<br><font color="#000000">- елементарна операция - не зависи от размера
на обработваните данни { <i>O</i>(1) };</font>
<br><font color="#000000">- последователност от оператори - определя се
от асимтотично най-бавния { <i>f + g</i> <font face="Symbol">О</font> max(<i>O</i>(
<i>f
</i>),
<i>O</i>(<i>g</i>)) };</font>
<br><font color="#000000">- композиция на оператори - произведение от сложностите
{ <i>f&nbsp; g</i> <font face="Symbol">О</font> <i>O</i>(
<i>f g</i>) };</font>
<br>- условни оператори - <font color="#000000">определя се от асимтотично
най-бавния измежду условието и различните случаи;</font>
<br><font color="#000000">- цикли, вложени цикли - { <i>O</i>(<i>n</i>),

<i>O</i>(<i>n<sup>p</sup></i>) }.</font>
<p><font color="#000000">Примери:</font>
<br><b><tt><font color="#000099">/* Брой цифри на число */</font></tt></b>
<br><b><tt><font color="#000099">// digits.c</font></tt></b>
<br><b><tt><font color="#000099">#include &lt;stdio.h></font></tt></b>
<br><b><tt><font color="#000099">unsigned n=9800;</font></tt></b>
<br><b><tt><font color="#000099">int main(void)</font></tt></b>
<br><b><tt><font color="#000099">{</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;unsigned d, m=n;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;for (d=0; m>0; m/=10, d++);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;printf("numb of dig %u is %u\n",n,d);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;return 0;</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<p><b><tt><font color="#000099">/* Сума от цифрите на число */</font></tt></b>
<br><b><tt><font color="#000099">// sdigits.c</font></tt></b>
<br><b><tt><font color="#000099">#include &lt;stdio.h></font></tt></b>
<br><b><tt><font color="#000099">unsigned n=9800;</font></tt></b>
<br><b><tt><font color="#000099">int main(void)</font></tt></b>
<br><b><tt><font color="#000099">{</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;unsigned m, s=0;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;for (m=n; m>0; s+=m%10, m/=10);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;printf("sum of digits=%u\n", s);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;return 0;</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<p><b><tt><font color="#000099">/* Брой цифри на число */</font></tt></b>
<br><b><tt><font color="#000099">// ldigit.c</font></tt></b>
<br><b><tt><font color="#000099">#include &lt;stdio.h></font></tt></b>
<br><b><tt><font color="#000099">#include &lt;math.h></font></tt></b>
<br><b><tt><font color="#000099">unsigned n=9800;</font></tt></b>
<br><b><tt><font color="#000099">int main(void)</font></tt></b>
<br><b><tt><font color="#000099">{</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;printf("int(1+log10 (%u)) = %d\n",
n, (int)(1+log10(n)));</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;return 0;</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<p><font color="#000000">Оценка на сложността на Решето на Ератостен и
алгоритъма за намиране последователно на простите числа.</font>
<br><font color="#000000">Оценка на сложността на следните цикли:</font>
<br><b><tt><font color="#000099">/</font><font color="#006600">/ 1</font></tt></b>
<br><b><tt><font color="#006600">for (i=0; i&lt;n; i++)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;for (j=0; j&lt;n, j==i; j++, sum++);</font></tt></b>
<br><b><tt><font color="#006600">// 2</font></tt></b>
<br><b><tt><font color="#006600">for (i=0; i&lt;n; i++)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;for (j=0; j&lt;n; j++) if (a[i]==a[j])
return;</font></tt></b>
<br><b><tt><font color="#006600">// 3</font></tt></b>
<br><b><tt><font color="#006600">for (i=0; i&lt;n; i++)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;for (j=0; j&lt;n; j++) if (a[i]!=a[j])
return;</font></tt></b>
<br><b><tt><font color="#006600">// 4</font></tt></b>
<br><b><tt><font color="#006600">for (i=0; i&lt;n; i++)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;for (j=0; j&lt;n; j++) if (a[i]==a[j])
return;</font></tt></b>
<br><b><tt><font color="#006600">// 5</font></tt></b>
<br><b><tt><font color="#006600">for (i=0; i&lt;n; i++)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;for (j=0; j&lt;i; j++) sum++;</font></tt></b>
<br><b><tt><font color="#006600">// 6</font></tt></b>
<br><b><tt><font color="#006600">for (i=0; i&lt;n; i++)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;for (j=0; j&lt;n*n; j++) sum++;</font></tt></b>
<br><b><tt><font color="#006600">// 7</font></tt></b>
<br><b><tt><font color="#006600">for (i=0; i&lt;n; i++)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;for (j=0; j&lt;i*i; j++) sum++;</font></tt></b>
<br><b><tt><font color="#006600">// 8</font></tt></b>
<br><b><tt><font color="#006600">for (i=0; i&lt;n; i++)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;for (j=0; j&lt;i*i; j++)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; for (k=0; k&lt;j*j; k++)
sum++;</font></tt></b>
<br>
<hr WIDTH="100%">
<br>Problem B
<br>Hidden Password
<p>Input File: B.IN
<br>Output File: standard output
<br>Program Source File: B.PAS or B.C or B.CPP or B.JAVA
<p>Some time the programmers have very strange ways to hide their passwords.
See for example how Billy "Hacker" Geits hide his password. Billy chooses
a string <i>S</i> composed of small Latin letters with length <i>L</i>.
Then he makes all <i>L - </i>1 one-letter left cyclic shifts of the string
and takes as a password one prefix of the lexicographically first of the
obtained strings (including <i>S</i>). For example let consider the string
<b><tt>alabala</tt></b>. The cyclic one-letter left shifts (including the
initial string) are:
<p>&nbsp;&nbsp;&nbsp;&nbsp; <b><tt>alabala</tt></b>
<br><b><tt>&nbsp; labalaa</tt></b>
<br><b><tt>&nbsp; abalaal</tt></b>
<br><b><tt>&nbsp; balaala</tt></b>
<br><b><tt>&nbsp; alaalab</tt></b>
<br><b><tt>&nbsp; laalaba</tt></b>
<br><b><tt>&nbsp; aalabal</tt></b>
<p>and lexicographically first of them is the string aalabal. The first
letter of this string is in position 6 in the initial string (the positions
in the string are counted from 0).
<p>Write a program that for given string <i>S</i> finds the start position
of the smallest lexicographically one-letter left cyclic shift of this
string. If the smallest lexicographically left shift appears more than
once then the program have to output the smallest initial position.
<p>Your program has to be ready to solve more than one test case. The first
line of the input file will contains only the number <i>T</i> of the test
cases. Each of the following <i>T</i> lines will describe one test case
– first the length <i>L</i> of the string (5 &lt; <i>L</i> &lt; 100000)
and then, separated by one space, the string <i>S</i> itself.
<p>The output file have to contain exactly <i>T</i> lines with a single
number each – the initial position found by your program.
<p>EXAMPLE
<p>Input&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Output
<br><b><tt>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1</tt></b>
<br><b><tt>6 baabaa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
6</tt></b>
<br><b><tt>7 alabala</tt></b>
<p>
<hr WIDTH="100%">
</body>
</html>
