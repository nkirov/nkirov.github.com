<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
   <meta name="Author" content="Nikolay Kirov">
   <meta name="GENERATOR" content="Mozilla/4.75 [en] (Win98; U) [Netscape]">
   <title>l10</title>
</head>
<body>
<b>10. Динамично оптимиране - задача за раницата [8.2.1] - <font color="#660000">23.12.2003
от 14:40 до 17:00 часа</font></b><b></b>
<p>&nbsp;&nbsp;&nbsp; Класическа задача за раницата:
<br>&nbsp;&nbsp;&nbsp; Дадена е раница с вместимост <i>M</i> килограма
и <i>N</i> предмета, всеки от които се характеризира с две числа - тегло
<i>m<sub>i</sub></i> и стойност <i>c<sub>i</sub></i>. Да се избере такова
множество от предмети, чиято сумарна стойност е максимална, а сумата от
теглата не надвишава <i>M</i>.
<p>&nbsp;&nbsp;&nbsp; Дефинираме рекурентна целева функция:
<center>
<p><i>F</i>(0) = 0;&nbsp; <i>F</i>(<i>i</i>) = max { <i>c<sub>j</sub></i>
+ <i>F</i>(<i>i-m<sub>j</sub></i>),&nbsp; <i>j = </i>1, 2, ..., <i>N</i>,&nbsp;
<i>m<sub>j</sub> &lt;= i </i>},<i> i > </i>0</center>

<p>&nbsp;&nbsp;&nbsp; Методът на динамичното оптимиране изисква последователно
пресмятане на стойностите на <i>F</i>(<i>i</i>), като за това пресмятане
се използват вече пресметнатите стойности за по-малки <i>i</i>.<b></b>
<p><b><tt><font color="#000099">// knapsack.c</font></tt></b>
<br><b><tt><font color="#000099">#include &lt;string.h></font></tt></b>
<br><b><tt><font color="#000099">#include &lt;stdio.h></font></tt></b><b><tt><font color="#000099"></font></tt></b>
<p><b><tt><font color="#000099">#define MAXN 30&nbsp;&nbsp;&nbsp;</font><font color="#660000">
/* max брой предмети */</font></tt></b>
<br><b><tt><font color="#000099">#define MAXM 1000&nbsp; </font><font color="#660000">/*
max вместимост на раницата */</font></tt></b><b><tt><font color="#000099"></font></tt></b>
<p><b><tt><font color="#000099">char set[MAXM][MAXN];</font></tt></b>
<br><b><tt><font color="#660000">/* ако set[i][j]==1, то на стъпка i (вместимост
i) в раницата е предмет j */</font></tt></b><b><tt><font color="#000099"></font></tt></b>
<p><b><tt><font color="#000099">unsigned Fn[MAXM]; </font><font color="#660000">/*
стойност на целевата функция */</font></tt></b><b><tt><font color="#000099"></font></tt></b>
<p><b><tt><font color="#660000">/* ПРЕДМЕТИ */</font></tt></b>
<br><b><tt><font color="#000099">const unsigned m[MAXN] = {0, 30, 15, 50,
10, 20, 40, 5, 65}; </font><font color="#660000">/* тегло */</font></tt></b>
<br><b><tt><font color="#000099">const unsigned c[MAXN] = {0,&nbsp; 5,&nbsp;
3,&nbsp; 9,&nbsp; 1,&nbsp; 2,&nbsp; 7, 1, 12}; </font><font color="#660000">/*
стойност */</font></tt></b><b><tt><font color="#000099"></font></tt></b>
<p><b><tt><font color="#000099">const unsigned M = 70; </font><font color="#660000">/*
вместимост на раницата */</font></tt></b>
<br><b><tt><font color="#000099">const unsigned N = 8;&nbsp;</font><font color="#660000">
/* брой предмети */</font></tt></b><b><tt><font color="#000099"></font></tt></b>
<p><b><tt><font color="#000099">void calculate(void)</font></tt></b>
<br><b><tt><font color="#000099">{ unsigned maxValue, maxIndex, i, j;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; memset(set,0,sizeof(set)); </font><font color="#660000">/*
set[i][j] = 0 */</font></tt></b><b><tt><font color="#000099"></font></tt></b>
<p><b><tt><font color="#000099">&nbsp; for (i=1; i&lt;=M; i++)</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; { maxValue = maxIndex = 0;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp; for (j=1; j&lt;=N;
j++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#660000">
/* опит с предмета с номер j */</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp; if (m[j]&lt;=i
&amp;&amp; !set[i-m[j]][j])</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (c[j]
+ Fn[i-m[j]] > maxValue)</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp; { maxValue = c[j] +
Fn[i-m[j]];</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxIndex
= j;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp; }</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp; if (maxIndex>0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#660000">
/* има успешен опит */</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp; { Fn[i] = maxValue;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy(set[i],set[i-m[maxIndex]],
N);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set[i][maxIndex]
= 1;</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp; }</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp; if (Fn[i] &lt; Fn[i-1])</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp; { Fn[i] = Fn[i-1];</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy(set[i],set[i-1],
N);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp; }</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; }</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; printf("No:");</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; for (i=1; i&lt;=N; i++)</font></tt></b>
<br><b><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp; if (set[M][i])
printf("%5u", i);</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; printf("\n Max value: %u", Fn[M]);</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b><b><tt><font color="#000099"></font></tt></b>
<p><b><tt><font color="#000099">int main()</font></tt></b>
<br><b><tt><font color="#000099">{ calculate();</font></tt></b>
<br><b><tt><font color="#000099">&nbsp; return 0;</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<br><font color="#000000">&nbsp;&nbsp;&nbsp; Да разгледаме примера:</font>
<br><b><tt><font color="#000000">N = 8;</font></tt></b>
<br><b><tt><font color="#000000">index&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;
1&nbsp; 2&nbsp; 3&nbsp; 4&nbsp; 5&nbsp; 6&nbsp; 7&nbsp; 8</font></tt></b>
<br><b><tt><font color="#000000">m[MAXN] = {0, 3, 7, 6, 1, 2, 4, 5, 5};</font></tt></b>
<br><b><tt><font color="#000000">c[MAXN] = {0, 5, 3, 9, 1, 1, 2, 5, 2}</font></tt></b>
<br><b><tt><font color="#000000">M = 7;</font></tt></b><b><tt><font color="#000000"></font></tt></b>
<p><b><tt><font color="#000000">Fn[0] = 0;</font></tt></b>
<br><b><tt><font color="#000000">Fn[1] = max { </font><font color="#993300">c[4]+Fn[0]</font><font color="#000000">
} = 1 /4/</font></tt></b>
<br><b><tt><font color="#000000">Fn[2] = max { </font><font color="#993300">c[5]+Fn[0]</font><font color="#000000">
} = 1 /5/</font></tt></b>
<br><b><tt><font color="#000000">Fn[3] = max { </font><font color="#993300">c[1]+Fn[0]</font><font color="#000000">,
c[4]+Fn[2], c[5]+Fn[1] } = max{5,3,2} = 5 /1/</font></tt></b>
<br><b><tt><font color="#000000">Fn[4] = max { </font><font color="#993300">c[1]+Fn[1]</font><font color="#000000">,
c[4]+Fn[3], c[6]+Fn[0] } = max{6,6,2} = 6 /1,4/</font></tt></b>
<br><b><tt><font color="#000000">Fn[5] = max { </font><font color="#993300">c[1]+Fn[2]</font><font color="#000000">,
c[5]+Fn[3], c[6]+Fn[1], c[7]+Fn[0], c[8]+Fn[0] } = max{</font><font color="#993300">6</font><font color="#000000">,6,3,5,2}
= 6 /1,5/</font></tt></b>
<br><b><tt><font color="#000000">Fn[6] = max { </font><font color="#993300">c[3]+Fn[0]</font><font color="#000000">,
c[4]+Fn[5], c[5]+Fn[4], c[6]+Fn[2], c[7]+Fn[2], c[8]+Fn[1] } = max{</font><font color="#993300">9+0</font><font color="#000000">,1+5,1+6,2+1,5+1,2+1}
= 9 /3/</font></tt></b>
<br><b><tt><font color="#000000">Fn[7] = max { c[2]+Fn[0], </font><font color="#993300">c[3]+Fn[1]</font><font color="#000000">,
c[4]+Fn[6], c[6]+Fn[5], c[7]+Fn[2], c[8]+Fn[5] } = {5+0,</font><font color="#993300">9+1</font><font color="#000000">,1+9,2+6,5+1,2+6}
= 10 /3,4/</font></tt></b><b><tt><font color="#000099"></font></tt></b>
<p><font color="#000000">Задача, дадена на Шести междууниверситетски турнир
по програмиране - Шумен, 10 май 2003 г.</font><font color="#000000"></font>
<p><font color="#000000">Задача F.&nbsp; Зайче в беда</font><font color="#000000"></font>
<p><font color="#000000">&nbsp;&nbsp;&nbsp; Веднъж малкото бяло зайче,
гонено от един ловец попаднало в горния ляв ъгъл на лабиринт, които имал
форма на квадратна дъска <i>N</i> x <i>N</i>. В него чакал големия лош
вълк, които предварително изкопал дупки, където зайчето да падне, а той
да го хване по-лесно. В последния момент зайчето с ужас разбрало, че може
да се движи само в посока надолу и надясно, и че изхода от лабиринта е
чак в долния десен ъгъл на дъската.</font>
<br><font color="#000000">&nbsp;&nbsp;&nbsp; Зайчето трябвало да разбере
каква е вероятността да излезе от лабиринта без да падне в някоя дупка.
За целта трябвало да изчисли броя пътища от входа до изхода на лабиринта,
като успяло да се снабди с картата на този лабиринт. Местата на дупките
на картата са означени с 0, а проходимите места с 1. Напишете програма
F.EXE, която пресмята търсения брой пътища.</font>
<br><font color="#000000">&nbsp;&nbsp;&nbsp; Данните се четат от стандартния
вход, където на първия ред е записано цялото число <i>К</i> - броя на тестовите
примери, а за всеки тестов пример се дава числото <i>N &lt;= </i>40;&nbsp;
следват <i>N</i> реда с по&nbsp; <i>N</i> числа, като на всяка клетка съответства
по едно число 1 или 0 (проходима клетка или дупка).</font>
<br><font color="#000000">&nbsp;&nbsp;&nbsp; На стандартния изход се извеждат
<i>К</i> числа - по едно за всеки тестов пример, показващи броя на пътищата
за съответния тестов пример. Всяко едно от числата се извежда на отделен
ред.</font><font color="#000000"></font>
<p><font color="#000000">Пример.</font>
<br><font color="#000000"></font>&nbsp;
<table BORDER=0 COLS=2 WIDTH="100%" >
<tr>
<td><font color="#000000">Вход:</font>
<br><b><tt><font color="#000000">1</font></tt></b>
<br><b><tt><font color="#000000">4&nbsp;&nbsp;&nbsp;</font></tt></b>
<br><b><tt><font color="#000000">1 1 1 1&nbsp;</font></tt></b>
<br><b><tt><font color="#000000">1 1 0 1</font></tt></b>
<br><b><tt><font color="#000000">1 0 1 1</font></tt></b>
<br><b><tt><font color="#000000">1 1 1 1</font></tt></b></td>

<td VALIGN=TOP><font color="#000000">Изход:</font>
<br><b><tt><font color="#000000">2</font></tt></b></td>
</tr>
</table>

<p>Допълнителна литература:
<br>[3] Лендерт Амерал, Алгоритми и структури от данни в С++, ИК "Софтех",
София,&nbsp; 2001, стр. 340
<br>[4] Емил Келеведжиев, Динамично опримиране, Мусала Софт и Анубис, София
2001.
<br>[6] Робърт Седжуик, Алгоритми на С. Том 1, ИК "Софтех", София, 2002,
стр. 229.
<p>
<hr WIDTH="100%">
<br><font color="#000000">&nbsp;</font>
</body>
</html>
