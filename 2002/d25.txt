/* D. Млеконадой
Козарят Тодор иска да раздели своето стадо от N (1 < N < 32) кози на две стада.
i-тата коза дава Mi литра мляко месечно и козарят Тодор иска да раздели козите
така, че двете стада да дават еднакво количество мляко за месец. Тъй като
такова разделяне не винаги е възможно, козарят Тодор решава най-напред да
отстрани някои кози от стадото и после да извърши делението му на две части
с еднакъв месечен млеконадой. Нека T е общото количество мляко, което ще даде
едно от двете новосформирани стада. Напишете програма, която ще намери
максимално възможната стойност на T.

Вход - файл D.IN:
Файлът съдържа няколко примера,първият ред от всеки пример съдържа числото N.
Следващите редове съдържат N-те цели числа Mi.
Числото 0 за стойност на N задава край на файла.

Изход - файл D25.OUT:
На всеки пример от входния файл съответства ред от изходния файл,
съдържащ числото T. Ако няма начин да се отстранят някои кози така,
че после да се раздели стадата на две с еднаква продукция от мляко,
в изходния файл се записва 0.

Примерен вход (съдържание на файла D.IN):
6
1 2 39 6 1 0 7
2
1 20
0
Примерен изход (съдържание на файла D25.OUT):
13
0

*/
#include <iostream>
#include <fstream>

using namespace std;

typedef unsigned long lint;

lint two_p(int n)
{ lint ip=1;
  for (int i=1; i<=n; i++) ip*=2;
  return ip;
}

int buffer[1000]={0}, ib=0;
int N, sn;
int M[100], sm[100];
int SUM, NN;

bool check()
{
 int snn=two_p(sn);
 lint i, j;
 for(i=1; i<snn; i++)
 {
  int sum=0;
  for(j=0; j<sn; j++) if (two_p(j) & i) sum+=sm[j];
  if (sum==SUM) return true;
 }
 return false;
}

int find()
{
 lint unsi, uj;
 int T=0;
 for(unsi=1; unsi<NN; unsi++)
 {
  sn=0; SUM=0;
  for(uj=0; uj<N; uj++) if (two_p(uj) & unsi)
  {
   sm[sn]=M[uj]; SUM+=sm[sn]; sn++;
  }
  if ((SUM%2==0) && (SUM>2*T))
  {
   int i=0;
   while ((buffer[i]!=SUM) && (i<ib)) i++;
   if (buffer[i]!=SUM)
   {
    if (ib<999) { ib++; buffer[ib]=SUM; }

    SUM=SUM/2;
    if (check() && (SUM>T)) T=SUM;
   }
  }
 }
 return T;
}

int main()
{
 ifstream fin("d.in");
 ofstream fout("d25.out");
 do
 {
  fin >> N;
  NN=two_p(N);
  ib=0;
  if (N>0)
  {
   for (int i=0; i<N; i++) fin >> M[i];
   fout << find() << "\n";
  }
 }
 while (N>0);
 return 0;
}
-------------------------------------------------------------

1 2 39 6 1 0 7
2
1 20
5
5 10 3 1 2 
2
2 2
4
1 2 4 1
4
1 1 2 1
12
1 2 3 4 5 6 7 8 9 10 5 6
20
2 2 2 2 2 2 2 2 2 2 4 4 4 4 4 4 4 4 4 4
0
-------------------------------------------------------------
2
23
0
2
4
2
33
30
-------------------------------------------------------------

