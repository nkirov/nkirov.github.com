<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="GENERATOR" content="Mozilla/4.75 [en] (Win98; U)
      [Netscape]">
    <title>Тest 1</title>
  </head>
  <body>
    <center>
      <h3>ТЕСТ 2<br>
      </h3>
      <p><b>(въпросите на теста, един верен и един грешен отговор</b>)</p>
    </center>
    <meta name="qrichtext" content="1">
    Отбележете верни и грешни твърдения за функцията <big><tt>generate_permutations</tt></big>,
    дадена във файла <font size="+1"><tt>permute.cpp</tt></font>.<br>
    (да) <big><tt>generate_permutations</tt></big> e функция, която
    генерира всички пермутации на една дума.<br>
    (не) Рекурсивното извикване връща една пермутация на по-къса дума.<br>
    <hr size="2" width="100%">Дадени са свързан списък и итератор:<br>
    &nbsp;&nbsp; <big><tt> list&lt;int&gt; bip;</tt></big><big><tt><br>
        &nbsp;list&lt;int&gt;::iterator it;</tt></big> <br>
    Списъкът съдържа 10 елемента и итераторът сочи втория елемент на
    свързания списък. Верни ли са (синтактично и/или логически) дадените
    изрази?<br>
    (да) <big><tt>*it &gt; 0</tt></big><br>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
p, li { white-space: pre-wrap; }
</style>
    <meta name="qrichtext" content="1">
    (не)<big><tt> *it != *bip.end()</tt></big> <br>
    <hr size="2" width="100%"> Верни ли са твърденията за достъп на
    член-функции от един клас до членове на друг клас за класовете,
    дефинирани във файла <tt>list2.cpp</tt>? <br>
    (да) Член-функциите на класа <big><tt>List</tt></big> имат достъп
    до частните членове на класа <big><tt>Node</tt></big>. <br>
    (не) Член-функциите на класа <big><tt>Iterator</tt></big> имат
    достъп до частните членове на класа <big><tt>List</tt></big>.<br>
    <hr size="2" width="100%"> Даден е свързан списък от цели числа,
    състоящ се от 3 елемента. Полето <big><tt>next</tt></big> сочи към
    следващия елемент, полето <big><tt>prev</tt></big> - предишния
    елемент от списъка, а <big><tt>h </tt></big>е указател за началото
    на списъка. <br>
    &nbsp;&nbsp; <big><tt>struct Item </tt><tt> </tt></big><br>
    &nbsp;&nbsp; <big><tt>{ </tt></big><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <big><tt> Item *next, *prev;
        int data; </tt></big><br>
    &nbsp;&nbsp; <big><tt>}; </tt></big><br>
    &nbsp;&nbsp; <big><tt>Item *h;</tt></big> <br>
    Определете верните и неверните твърдения. <br>
    (да) <big><tt>(h-&gt;next)-&gt;next</tt></big> е адресът на
    последния елемент от списъка. <br>
    (не) <big><tt>(h-&gt;next)-&gt;prev</tt></big> е <big><tt>NULL</tt></big>.<br>
    <hr size="2" width="100%"> Определете верните и неверните дефиниции
    и твърдения за структури от данни и свързан списък. <br>
    (да) Опашката е линейна структура от данни. <br>
    (не) Стекът е нелинейна структура от данни.
    <meta name="qrichtext" content="1">
    <br>
    <hr size="2" width="100%"> Посочете верните и грешни твърдения от
    текста на програмата <tt>list2.cpp</tt> за реализация на свързан
    списък.<br>
    (да) Операторът <big><tt>friend class List;</tt></big> в
    дефиницията на класа <big><tt>Node</tt></big> дава достъп на
    член-фукциите на класа <big>List</big> до частните членове на класа
    <big><tt>Node</tt></big>.<br>
    (не) <big><tt>class Iterator;</tt></big> е оператор за дефиниране
    на класа <big><tt>Iterator.</tt></big>
    <hr size="2" width="100%">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
p, li { white-space: pr</style>Проверете твърденията за стандартната
    библиотека шаблони (STL) на езика С++. <br>
    (да) Контейнерът <big><tt>map</tt></big> осигурява пряк и ефективен
    достъп до елементите. <br>
    (не) Контейнерът <big><tt>list </tt></big>осигурява пряк достъп
    (операция индекс) до елементите на свързания списък. <br>
    <hr size="2" width="100%"> Заместете многоточието (<big><tt>...</tt></big>)
    с дадения оператор. <br>
    <big><tt>void rec(int i) </tt><tt><br>
      </tt><tt> { </tt><tt><br>
        &nbsp; </tt><tt> ... </tt><tt><br>
        &nbsp; </tt><tt> if (i/10 != 0) rec(i/10); </tt><tt><br>
      </tt><tt> } </tt><tt><br>
      </tt><tt> int main() </tt><tt><br>
      </tt><tt> { </tt><tt><br>
        &nbsp; </tt><tt> rec(122); </tt><tt><br>
        &nbsp; </tt><tt> return 0; </tt><tt><br>
      </tt><tt> } </tt></big><br>
    Съдържа ли се низът <big><tt>121</tt></big> в изхода на програмата?
    <br>
    (да) <big><tt>cout &lt;&lt; i; </tt></big><br>
    (не) <big><tt>cout &lt;&lt; i%10;</tt></big><br>
    <hr size="2" width="100%">
    <meta name="qrichtext" content="1">
    Отбележете верни и грешни твърдения относно сортиране и търсене.<br>
    (да) За метода сортиране чрез избор удвояване на броя на елементите
    води до четирикратно учеличаване на времето за сортиране.<br>
    (не) За метода сортиране чрез сливане удвояване на броя на
    елементите води до четирикратно учеличаване на времето за сортиране.<br>
    <hr size="2" width="100%">
    <meta name="qrichtext" content="1">
    Ако 10000 записа се сортират за 4 секунди от двата метода за
    сортиране (избор и сливане), то<br>
    (да) методът сортиране чрез сливане ще сортира 1000000 записа за
    около 10 минути.<br>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
p, li { white-space: pre-wrap; }</style>
    <meta name="qrichtext" content="1">
    (не) методът сортиране чрез избор ще сортира 1000 записа за повече
    от 1 секунда.<br>
    <meta name="qrichtext" content="1">
    <hr size="2" width="100%"> Намерете броят <i>N</i>(<i>b</i>) на
    посещенията на елементите на масива<br>
    <big><tt>int a[10] = {14,43,76,100,115,290,400,511,512,601};</tt></big><br>
    необходими за намиране на стойност <i>b</i> при прилагане на
    алгоритъма за двоично търсене. Отговорете със стойността на
    математическия израз <i>N</i>(<i>b</i>) mod 2 за дадените стойности
    на <i>b</i>. <br>
    (0) <i>b </i>= 90<br>
    (1)<i> b</i> = 10<br>
    <meta name="qrichtext" content="1">
    <hr size="2" width="100%"> Пребройте посещенията на елементите на
    дадения масив, необходими за сортиране на масива по метода сортиране
    чрез избор и отбележете с ,,да'', ако този брой съвпада с числото,
    написано след елементите на масива.<br>
    (да) {5, 8, 7} 7<br>
    (не) {5, 7, 8} 7<br>
    <hr size="2" width="100%">
    <meta name="qrichtext" content="1">
    Отбележете с ,,да'' случаите, когато числото в скобите е броят на
    размените в алгоритъма за сортиране чрез селекция на дадения масив.<br>
    (да) {1, 2, 4, 5} (0)<br>
    (не) {1, 4, 2, 5} (2)<br>
    <meta name="qrichtext" content="1">
    <hr size="2" width="100%"> Дадени са две взаимно рекурсивни функции.<br>
    <big><tt>int s(int n)</tt></big><br>
    <big><tt> </tt></big> <big><tt>{ </tt></big><br>
    &nbsp;&nbsp;&nbsp; <big><tt> </tt></big> <big><tt> if (n != 0)
        return n + m(n - 1);</tt></big><br>
    &nbsp;&nbsp;&nbsp; <big><tt> </tt></big> <big><tt> else return 1;</tt></big><br>
    &nbsp;<big><tt>}</tt></big><br>
    <big><tt> </tt></big> <big><tt>int m(int n)</tt></big><br>
    <big><tt> </tt></big> <big><tt>{ </tt></big><br>
    &nbsp;&nbsp;&nbsp; <big><tt> </tt></big> <big><tt> if (n != 0)
        return n * s(n - 1);</tt></big><br>
    &nbsp;&nbsp;&nbsp; <big><tt> </tt></big> <big><tt> else return 0;</tt></big><br>
    <big><tt> </tt></big> <big><tt>}</tt></big><br>
    Пресметнете стойността на следния израз: <br>
    (true) <big><tt>s(2) == 3</tt></big><br>
    (false) <big><tt>s(0) == 0</tt></big><br>
    <hr size="2" width="100%"> Дадена е рекурсивната функция:<br>
    <tt><big>bool s_is_p(string s, int start, int end)</big></tt><br>
    <tt><big> </big></tt> <tt><big>{ </big></tt><br>
    &nbsp;&nbsp;&nbsp; <tt><big> </big></tt> <tt><big> if (start
        &gt;= end) return true;</big></tt><br>
    &nbsp;&nbsp;&nbsp; <tt><big> </big></tt> <tt><big> if (s[start]
        == s[end])</big></tt> <tt><big>return s_is_p(s, start + 2, end
        - 2);</big></tt><br>
    &nbsp;&nbsp;&nbsp; <tt><big> </big></tt> <tt><big> else</big></tt>
    <tt><big>return false;</big></tt><br>
    <tt><big> </big></tt> <tt><big>}</big></tt><br>
    Намерете върнатата от функцията стойност при следното извикване:: <br>
    &nbsp;&nbsp;&nbsp; <big><tt> s_is_p(s, 0, s.length() - 1);</tt></big><br>
    Стойността на променливата <big><tt>s</tt></big> е дадена по-долу.<br>
    (true) <big><tt>aaaa </tt></big><br>
    (false) <big><tt>aaaabbbb</tt></big><br>
    <hr size="2" width="100%">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
p, li { white-space: p</style><br>
  </body>
</html>
