<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="GENERATOR" content="Mozilla/4.75 [en] (Win98; U)
      [Netscape]">
    <title>Тest 4</title>
  </head>
  <body>
    <center>
      <h3>ТЕСТ 4<br>
      </h3>
      <b>въпросите на теста, един верен отговор (да), и един грешен
        "отговор" (не)<br>
        <br>
      </b> </center>
    Дадени са следните дефиниции: <tt><br>
      int b[3] = {10, 20, 30};</tt> <tt><br>
      int* pb = b;</tt><br>
    Посочете с "да" изразите със стойност 30.<br>
    (да) <tt>b[0] + b[1]</tt> <br>
    (не) <tt>*pb</tt>
    <hr size="2" width="100%"> Отбележете с "да" операторите за
    дефиниране на обекти и указатели към обекти от класовете <tt>Time</tt>
    и <tt>Employee</tt>, дадени в учебника на К. Хорстман (Chapter 3).<br>
    (да) <tt>Time* t = new Time; </tt><br>
    (не) <tt>Employee* e = new Employee</tt>; <br>
    <hr size="2" width="100%">Нека класът <tt>D</tt> наследява класа <tt>B</tt>,
    <tt>b</tt> е обект от класа <tt>B</tt>,&nbsp; <tt>d </tt>е обект
    от класа <tt>D</tt>, <tt>pb</tt> е указател от класа <tt>B</tt> и
    <tt>pd</tt> е указател от класа <tt>D</tt>. И в двата класа е
    дефинирана виртуална функция <tt>f</tt>. Кои от следните оператори
    са верни и кои - не?<br>
    (да) <tt>pd = dynamic_cast&lt;D*&gt;(pb);</tt><br>
    (не) <tt>d = b;</tt><br>
    <hr size="2" width="100%"> Дадени са следните дефиниции на класове:
    <br>
    <tt>class Employee {</tt><br>
    <tt> ... <br>
      };</tt><br>
    <tt> class Manager : public Employee {</tt><br>
    <tt> ... <br>
      };</tt> <br>
    Определете верните и неверните твърдения. <br>
    (да) Класът <tt>Employee</tt> е базов клас и класът <tt>Manager</tt>
    е производен клас. <br>
    (не) Класът <tt>Manager</tt> е базов клас и класът <tt>Employee</tt>
    е производен клас.
    <hr size="2" width="100%"> Дадени са следните дефиниции:<tt><br>
      ifstream inp;</tt> <tt> <br>
      ofstream out;</tt> <tt> <br>
      int k = 10;</tt> <tt> <br>
      char ch = 'Z';</tt> <tt> <br>
      const double PIN = 5.0;</tt> <br>
    Отбележете правилните и неправилните оператори относно синтаксис. <br>
    (да) <tt>inp.get(ch);</tt> <br>
    (не) <tt>inp.get(PIN);</tt>
    <hr size="2" width="100%"> Отбележете с "да" случаите, когато
    дадената редица от цифри съответства на дадения вход на програмата.
    <tt><br>
      int dig(int n)</tt> <tt> <br>
      { <br>
      &nbsp;&nbsp;&nbsp; cout &lt;&lt; n;</tt> <tt> <br>
      &nbsp;&nbsp;&nbsp; if (n &gt; 9) return dig(n/10) + 1;</tt> <tt>
      <br>
      &nbsp;&nbsp;&nbsp; else return 1; </tt> <tt> <br>
      }</tt> <tt> <br>
      int main()</tt> <tt> <br>
      { <br>
      &nbsp;&nbsp;&nbsp; int k; <br>
      &nbsp;&nbsp;&nbsp; cin &gt;&gt; k;</tt> <br>
    <tt> &nbsp;&nbsp;&nbsp; cout &lt;&lt; dig(k);</tt> <tt> <br>
      &nbsp;&nbsp;&nbsp; return 0;</tt> <br>
    <tt> }</tt> <br>
    Означението е: &lt;входно число&gt; -&gt; &lt;изходна редица&gt;. <br>
    (да) 122 -&gt; 1221213<br>
    (не) 13 -&gt; 1332
    <hr size="2" width="100%">Отбележете верни и грешни твърдения
    относно сортиране и търсене.<br>
    (да) За метода сортиране чрез избор удвояване на броя на елементите
    води до четирикратно учеличаване на времето за сортиране.<br>
    (не) За метода сортиране чрез сливане удвояване на броя на
    елементите води до четирикратно учеличаване на времето за сортиране.<br>
    <hr size="2" width="100%"> Даден е свързан списък и итератор: <tt><br>
      list&lt;int&gt; slist;</tt> <br>
    <tt> list&lt;int&gt;::iterator lit;</tt> <br>
    Списъкът съдържа 10 елементи и итераторът сочи втория елемент. Верен
    ли е даденият израз? <br>
    (да) <tt>*lit &gt; 0<br>
    </tt>(не) <tt>slist++</tt>
    <hr size="2" width="100%"> Даден е класа:<br>
    <tt>class&nbsp; Btree{</tt><tt><br>
    </tt><tt>public:</tt><tt><br>
    </tt><tt>&nbsp;&nbsp;&nbsp; Btree();</tt><tt><br>
    </tt><tt>&nbsp;&nbsp;&nbsp; Btree(const Btree&amp; b);</tt><tt><br>
    </tt><tt>&nbsp;&nbsp;&nbsp; ~Btree();</tt><tt><br>
    </tt><tt>&nbsp;&nbsp;&nbsp; Btree&amp; operator=(const Btree&amp;
      b);</tt><tt><br>
    </tt><tt>...</tt><tt><br>
    </tt><tt>};</tt><br>
    и обект <tt>b</tt> от този клас. Проверете твърденията за оператори
    от функция <tt>main</tt>:<br>
    (не) В оператора <tt>Btree b1 = b; </tt>се извиква предефинираната
    операция присвояване.<br>
    (да) В оператора <tt>Btree b1(b); </tt>се извиква конструктора за
    копиране.<br>
    <hr size="2" width="100%">Възможно ли е да се предефинира следващата
    операция за обекти от класа <tt>Time</tt>, като използваме следната
    декларация на обикновена функция?<br>
    (не) <tt>bool operator&gt;(Time);</tt><br>
    (да) <tt>long operator-(Time, Time); </tt><br>
    <hr size="2" width="100%">Възможно ли е да се предефинира следващата
    операция за обекти от класа <tt>Time</tt>, като използваме следната
    декларация на член-функция?<br>
    (да) <tt>bool Time::operator==(Time);</tt><br>
    (не)<tt> istream&amp; Time::operator&gt;&gt;(Time&amp;);</tt><br>
    <hr size="2" width="100%"> Отбележете верни/неверни твърдения за
    предефиниране на операции и шаблони. <br>
    (да) Клас-шаблон е механизъм, който позволява да се създават
    класове, чиито членове данни са от произволен тип. <br>
    (не) Функцията <tt>operator=</tt> може да не бъде член-функция. <br>
    <hr size="2" width="100%">Нека е даден следния клас-шаблон: <br>
    <tt>template </tt><typename t=""><tt>&lt;typename T&gt;<br>
        class Temp { </tt><tt><br>
      </tt><tt>public: </tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp; </tt><tt>Temp(T t) <br>
        &nbsp;&nbsp;&nbsp; { <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; data = new T(t); <br>
        &nbsp;&nbsp;&nbsp; } </tt><tt><br>
      </tt><tt>private: </tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp; </tt><tt>T* data; </tt><tt><br>
      </tt><tt>}; </tt><br>
      Може ли в класа да се добави деклaрация/дефиниция на следната
      функция: <br>
      (да) <tt>T get() const { return *data; } </tt><br>
      (не) <tt>Temp go();</tt> <br>
      <hr size="2" width="100%">Дадена е следната част от програма:<br>
      <tt>void fun3() <br>
        { <br>
        &nbsp;&nbsp;&nbsp; throw runtime_error("RTE" ); <br>
        }<br>
        void fun2() throw(runtime_error) <br>
        { <br>
        &nbsp;&nbsp;&nbsp; // блок на функцията<br>
        }<br>
        void fun1() throw(runtime_error) <br>
        { <br>
        &nbsp;&nbsp;&nbsp; fun2(); <br>
        } <br>
        int main()<br>
        { <br>
        &nbsp;&nbsp;&nbsp; try <br>
        &nbsp;&nbsp;&nbsp; { <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fun1(); <br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; catch (runtime_error e) <br>
        &nbsp;&nbsp;&nbsp; { <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cout&lt;&lt;e.what(); <br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return 0; <br>
        }</tt><br>
      Поставете в блока на функцията f<tt>un2</tt> дадения оператор или
      дадените оператори и отбележете с "да" случая на отпечатване на
      съобщение <tt>RTE</tt> при изпълнението на програмата.<br>
      (да) <tt>fun3();</tt><br>
      (не) <tt>fun1();</tt><br>
      <hr width="100%">Дадена е част от програма:<br>
      <tt>class Vec {<br>
        public:<br>
        &nbsp;&nbsp; class Range {<br>
        &nbsp;&nbsp; public:<br>
        &nbsp;&nbsp;&nbsp;&nbsp; int index;<br>
        &nbsp;&nbsp;&nbsp;&nbsp; Range(int j):index(j) {} <br>
        &nbsp;&nbsp; };<br>
        &nbsp;&nbsp; int&amp; operator[](int i)<br>
        &nbsp;&nbsp; { <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (0&lt;=i &amp;&amp;
        i&lt;100) return p[i]; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw Range(i); <br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; ... <br>
        };<br>
        void do_any(Vec&amp; w);<br>
        void do_some(Vec&amp; w);<br>
        void f(Vec&amp; v)<br>
        { <br>
        &nbsp; do_any(v);<br>
        &nbsp; try <br>
        &nbsp; { <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do_some(v); <br>
        &nbsp; }<br>
        &nbsp; catch(Vec::Range r)<br>
        &nbsp; { <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cerr &lt;&lt; "ERROR" &lt;&lt;
        r.index; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... <br>
        &nbsp; }<br>
        &nbsp; ...<br>
        }</tt><br>
      Верни ли са следните твърдения?<br>
      (да) <tt>r</tt> е обект от тип <tt>Vec::Range</tt>.<br>
      (не) <tt>r</tt> е обект от тип <tt>Range.</tt>
      <hr width="100%"> </typename>
  </body>
</html>
