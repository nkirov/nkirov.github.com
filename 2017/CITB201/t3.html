<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="GENERATOR" content="Mozilla/4.75 [en] (Win98; U)
      [Netscape]">
    <title>Тest 3</title>
  </head>
  <body>
    <br>
    <br>
    <center>ТЕСТ 3<br>
      <b>въпросите на теста, един верен отговор (да), и един грешен
        "отговор" (не)</b> </center>
    <hr size="2" width="100%">Посочете верните твърдения за параметрите
    на функциите, предефиниращи операции и за аргументите на самите
    предефинирани операции.<br>
    (да) Първият на аргумент на предефинирана операция с член-функция е
    текущият обект.<br>
    (не) Унарна операция се предефинира с член-функция с един&nbsp;
    параметър.<br>
    <hr size="2" width="100%">Отбележете верни/неверни твърдения за
    предефиниране на операции.<br>
    (да) Операция се предефинира като са дeфинира функция с име <font
      size="+1"><tt>operator</tt></font> и знака на операцията.<br>
    (не) Функцията <font size="+1"><tt>Time&amp; operator++(Time&amp;)</tt></font>
    предефинира постфиксната операция ++ за обекти от клас <font
      size="+1"><tt>Time</tt></font>. <br>
    <hr size="2" width="100%">Даден е класа:<br>
    <font size="+1"><tt>class&nbsp; Btree{</tt><tt><br>
      </tt><tt> public:</tt><tt><br>
      </tt><tt> &nbsp;&nbsp;&nbsp; Btree();</tt><tt><br>
      </tt><tt> &nbsp;&nbsp;&nbsp; Btree(const Btree&amp; b);</tt><tt><br>
      </tt><tt> &nbsp;&nbsp;&nbsp; ~Btree();</tt><tt><br>
      </tt><tt> &nbsp;&nbsp;&nbsp; Btree&amp; operator=(const Btree&amp;
        b);</tt><tt><br>
      </tt><tt> private:</tt><tt><br>
      </tt><tt> ...</tt><tt><br>
      </tt><tt> };</tt></font><br>
    и обект <font size="+1"><tt>b </tt></font>от този клас.<br>
    Проверете твърденията за оператори от функция <tt><font size="+1">main</font></tt>:<br>
    (да) В оператора <font size="+1"><tt>Btree b1(b);</tt></font> се
    извиква конструктора за копиране.<br>
    (не) В оператора <font size="+1"><tt>Btree b1 = b;</tt></font> се
    извиква предефинираната операция присвояване.<br>
    <hr size="2" width="100%"> Разгледайте главната функция на
    програмата, дадена във файла <font size="+1"><tt>overload.cpp</tt></font>
    и отбележете с "да" изразите, в които има предефинирана операция. <br>
    (да) <font size="+1"><tt>now + 1000</tt></font> <br>
    (не) <font size="+1">cout &lt;&lt; "Another "</font><br>
    <hr size="2" width="100%">Може ли даденият ред от програма да бъде
    дефиниция на деструктор? <br>
    (да) <font size="+1"><tt>Department::~Department() {}</tt> </font><br>
    (не) <font size="+1"><tt>Dep::~Dep(int i) { cout &lt;&lt; i; }</tt></font><br>
    <hr size="2" width="100%">Възможно ли е да се предефинира следващата
    операция за обекти от класа <font size="+1"><tt>Time</tt></font>,
    като използваме следната декларация на обикновена функция?<br>
    (не) <font size="+1"><tt>bool operator&gt;(Time);</tt></font><br>
    (да) <font size="+1"><tt>long operator-(Time, Time); </tt></font><br>
    <hr size="2" width="100%">Възможно ли е да се предефинира следващата
    операция за обекти от класа <tt>Time</tt>, като използваме следната
    декларация на член-функция?<br>
    (да) <tt>bool Time::operator==(Time);</tt><br>
    (не)<tt> istream&amp; Time::operator&gt;&gt;(Time&amp;);</tt><br>
    <hr size="2" width="100%"> Отбележете верни/неверни твърдения за
    класове-шаблони. <br>
    (да) Клас-шаблон е механизъм, който позволява да се създават
    класове, чиито членове-данни са от произволен тип. <br>
    (не) Член-функция на клас-шаблон може да се дефинира като обикновена
    (не шаблон) функция.
    <hr size="2" width="100%">Нека е даден следния клас-шаблон: <br>
    <tt>template </tt><typename t=""><tt>&lt;typename T&gt;<br>
        class Temp { </tt><tt><br>
      </tt><tt>public: </tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp; </tt><tt>Temp(T t) <br>
        &nbsp;&nbsp;&nbsp; { <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; data = new T(t); <br>
        &nbsp;&nbsp;&nbsp; } </tt><tt><br>
      </tt><tt>private: </tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp; </tt><tt>T* data; </tt><tt><br>
      </tt><tt>}; </tt><br>
      Може ли в класа да се добави деклaрация/дефиниция на следната
      функция: <br>
      (да) <tt>T get() const { return *data; } </tt><br>
      (не) <tt>Temp go();</tt> <br>
      <hr size="2" width="100%">Даден е клас <tt><font size="+1">A</font></tt>
      и вложен в него клас </typename><typename t=""><tt><font
          size="+1">B</font></tt>. <br>
      <font size="+1"><tt>template &lt;typename T&gt;</tt><tt><br>
        </tt></font><font size="+1"><tt>class А {</tt></font><font
        size="+1"><tt><br>
        </tt></font><font size="+1"><tt>public:</tt></font><font
        size="+1"><tt><br>
        </tt></font><font size="+1"><tt>&nbsp;&nbsp; class B;</tt></font><font
        size="+1"><tt><br>
        </tt></font><font size="+1"><tt>&nbsp;&nbsp;&nbsp; ...</tt></font><font
        size="+1"><tt><br>
        </tt></font><font size="+1"><tt>};</tt></font><br>
      Верни ли са твърденията?<br>
      (да) Дефиниция на обект <font size="+1"><tt>b</tt></font> от клас
      <font size="+1"><tt>B</tt></font> главната функция: <font
        size="+1"><tt>A::B b</tt></font>.<br>
      (не) Дефиниция на обект <font size="+1"><tt>b</tt></font> от клас
      <font size="+1"><tt>B</tt></font> главната функция: <font
        size="+1"><tt>B b</tt></font>.<br>
      <hr size="2" width="100%">Отбележете верни/неверни твърдения за
      обработка на изключения.<br>
      (да) Когато дадена функция открие грешка, тя може да изхвърли
      изключение към някоя друга част на програмата, чиято работа е да
      обработва грешки.&nbsp; <br>
      &nbsp;(не) Ключовата дума <tt>throw</tt> показва, че изпълнението
      на функциятя спира незабавно и управлението се предава на
      извикващата функция.<br>
      <hr size="2" width="100%">Дадена е следната част от програма:<br>
      <tt>void fun3() <br>
        { <br>
        &nbsp;&nbsp;&nbsp; throw runtime_error("RTE" ); <br>
        }<br>
        void fun2() throw(runtime_error) <br>
        { <br>
        &nbsp;&nbsp;&nbsp; // блок на функцията<br>
        }<br>
        void fun1() throw(runtime_error) <br>
        { <br>
        &nbsp;&nbsp;&nbsp; fun2(); <br>
        } <br>
        int main()<br>
        { <br>
        &nbsp;&nbsp;&nbsp; try <br>
        &nbsp;&nbsp;&nbsp; { <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fun1(); <br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; catch (runtime_error e) <br>
        &nbsp;&nbsp;&nbsp; { <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cout&lt;&lt;e.what(); <br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return 0; <br>
        }</tt><br>
      Поставете в блока на функцията f<tt>un2</tt> дадения оператор или
      дадените оператори и отбележете с "да" случая на отпечатване на
      съобщение <tt>RTE</tt> при изпълнението на програмата. <br>
      (да) <tt>fun3();</tt><br>
      (не) <tt>fun1();</tt><br>
      <hr width="100%">Дадена е част от програма:<br>
      <tt>class Vec {<br>
        public:<br>
        &nbsp;&nbsp; class Range {<br>
        &nbsp;&nbsp; public:<br>
        &nbsp;&nbsp;&nbsp;&nbsp; int index;<br>
        &nbsp;&nbsp;&nbsp;&nbsp; Range(int j):index(j) {} <br>
        &nbsp;&nbsp; };<br>
        &nbsp;&nbsp; int&amp; operator[](int i)<br>
        &nbsp;&nbsp; { <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (0&lt;=i &amp;&amp;
        i&lt;100) return p[i]; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw Range(i); <br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; ... <br>
        };<br>
        void do_any(Vec&amp; w);<br>
        void do_some(Vec&amp; w);<br>
        void f(Vec&amp; v)<br>
        { <br>
        &nbsp; do_any(v);<br>
        &nbsp; try <br>
        &nbsp; { <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do_some(v); <br>
        &nbsp; }<br>
        &nbsp; catch(Vec::Range r)<br>
        &nbsp; { <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cerr &lt;&lt; "ERROR" &lt;&lt;
        r.index; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... <br>
        &nbsp; }<br>
        &nbsp; ...<br>
        }</tt><br>
      Верни ли са следните твърдения?<br>
      (да) <tt>r</tt> е обект от тип <tt>Vec::Range</tt>.<br>
      (не) <tt>r</tt> е обект от тип <tt>Range.<br>
      </tt>
      <hr size="2" width="100%">Посочете верните твърдения за
      многократна наследственост.<br>
      (да) Многократна наследственост има, когато производния клас има
      два или повече базови класове.<br>
      (не) <font size="+1"><tt>virtual class E : public P</tt></font>
      определя виртуална наследственост.<br>
      <hr size="2" width="100%">Посочете верните твърдения за получаване
      на информация за типа по време на изпълнение. <br>
    </typename><typename t="">(да) Унарната операция <font size="+1"><tt>dynamic_cast</tt></font>
      изисква тип като параметър на шаблон, и аргумент, който трябва да
      бъде указател или псевдоним (референция). <br>
      (не)<tt><font size="+1"> </font></tt><font size="+1"><tt>typeid</tt></font>
      е бинарна операция. <tt> </tt>
      <hr width="100%"> </typename>
  </body>
</html>
