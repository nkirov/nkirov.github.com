<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Test_2</title>
</head>
<body>
<h3 style="text-align: center;"><font size="+1">The questions of Test_2</font></h3>
<h3 style="text-align: center; font-weight: normal;"><font size="+1">with
two model
answers - one correct (yes) and one incorrect (no)</font></h3>
<font size="+1"></font>
Mark the correct and incorrect definitions and assertions about <span
 style="font-weight: bold;">trees</span>.
<br>
(yes) If node <span style="font-style: italic;">u</span> is the parent
of node <span style="font-style: italic;">v</span>, we say that <span
 style="font-style: italic;">v</span> is a child of <span
 style="font-style: italic;">u</span>.
<br>
(no) Nodes that are children of the same parent are called leaves.
<br>
<br>
Let us have a <span style="font-weight: bold;">tree</span> ADT with <span
 style="font-style: italic;">n</span> elements. Let <span
 style="font-family: monospace;">v</span> and <span
 style="font-family: monospace;">w</span> be positions in the tree.
Mark the correct/incorrect
correspondence between a function of this ADT and its run-time
assumptions.
<br>
(yes) <span style="font-family: monospace;">root(v)</span> - <span
 style="font-style: italic;">O</span>(1)
<br>
(no) <span style="font-family: monospace;">parent(v)</span> - <span
 style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span>)
<br>
<br>
Let us have an ordered <span style="font-weight: bold;">tree</span>
ADT in parenthetic string representation <span
 style="font-family: monospace;">T = A(B(H,E(I,J),F),C(G),D)</span> .
Determine the correct/incorrect pairs: <br>
<span style="font-family: monospace;">function,its output value</span>.
<span style="font-family: monospace;">p(X)</span> means the position of
the element <span style="font-family: monospace;">X</span> .
[Hint: See p.268 for "parenthetic string representation".]<br>
(yes)<span style="font-family: monospace;"> root(), p(A) </span><br>
(no) <span style="font-family: monospace;">root(), p(D)</span><br>
<br>
Let us have an ordered <span style="font-weight: bold;">tree</span>
ADT in parenthetic string representation <span
 style="font-family: monospace;">T = A(B(H,E(I,J),F),C(G),D)</span> .
Determine the correct/incorrect substrings of a string of nodes,
obtained in <span style="font-style: italic;">preorder traversal</span>
of the tree.
<br>
(yes) <span style="font-family: monospace;">ABH </span><br>
(no) <span style="font-family: monospace;">EB</span> <br>
<br>
Let us have an ordered&nbsp; <span style="font-weight: bold;">tree</span>
ADT in parenthetic string representation <span
 style="font-family: monospace;">T = A(B(H,E(I,J),F),C(G),D)</span> .
Determine the correct/incorrect substrings of a string of nodes,
obtained in <span style="font-style: italic;">postorder traversa</span>l
of the tree.
<br>
(yes) <span style="font-family: monospace;">HIJ</span><br>
(no) <span style="font-family: monospace;">EB</span> <br>
<br>
Let us have a <span style="font-weight: bold;">binary tree</span> ADT
in parenthetic string representation <span
 style="font-family: monospace;">T = a(b(d(h,i),e),c(f,g(j(l,m),k))</span>
.
Determine the correct/incorrect substrings of a string of nodes,
obtained in <span style="font-style: italic;">inorder traversal</span>
of this binary tree.
<br>
(yes) <span style="font-family: monospace;">hdib </span><br>
(no) <span style="font-family: monospace;">hdie</span> <br>
<br>
Let us have a <span style="font-weight: bold;">binary tree</span> ADT
in parenthetic string representation <span
 style="font-family: monospace;">T = a(b(d(h,i),e),c(f,g(j(l,m),k))</span>
.
Determine the correct/incorrect substrings of a string of nodes,
obtained in <span style="font-style: italic;">Euler tour traversal</span>
of this binary tree.
<br>
(yes) <span style="font-family: monospace;">abdhd</span> <br>
(no) <span style="font-family: monospace;">bdhid</span> <br>
<br>
Create a <span style="font-weight: bold;">binary tree</span>
representation of the following arithmetic expression: <span
 style="font-family: monospace;">(9 * (5 + a) + b) / 2</span> .
Determine the correct/incorrect substrings of a string of nodes,
obtained in <span style="font-style: italic;">preorder traversal</span>
of this binary tree.
[Hint: See p.258, Example 6.5.]<br>
(yes)<span style="font-family: monospace;"> /+* </span><br>
(no) <span style="font-family: monospace;">9/2</span> <br>
<br>
Create a <span style="font-weight: bold;">binary tree</span>
representation of the following <span style="font-style: italic;">arithmetic
expression</span>: <span style="font-family: monospace;">(9 * (5 + a)
+ b) / 2</span> .
Determine the correct/incorrect substrings of a string of nodes,
obtained in <span style="font-style: italic;">postorder traversal</span>
of this binary tree. <br>
(yes) <span style="font-family: monospace;">95a</span> <br>
(no) <span style="font-family: monospace;">9/2</span> <br>
<br>
Mark the correct and incorrect definitions and assertions about <span
 style="font-weight: bold;">priority queues</span> and <span
 style="font-weight: bold;">heaps</span>.
<br>
(yes) A key is an object that is assigned to an element as a specific
attribute for that element and that can be used to identify, rank, or
weight that element.
<br>
(no)&nbsp; In a heap storing <span style="font-style: italic;">n</span>
keys, upheap (bubbling) algorithm runs <span
 style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span>)
time.<br>
<br>
Let us have a <span style="font-weight: bold;">priority queue</span>
ADT <span style="font-family: monospace;">P = {(5,A),(7,D),(9,C)}</span>
.
Determine the
correct/incorrect triples: <span style="font-family: monospace;">function-output-new_P</span>
. A triple is
correct, when applying the given function on <span
 style="font-family: monospace;">P</span> , the second triple
member is its the return value and the third member is the new
priority queue <span style="font-family: monospace;">P</span> .
<br>
(yes) <span style="font-family: monospace;">insertItem(3,B)-NONE-{(3,B),(5,A),(7,D),(9,C)}
</span><br>
(no) <span style="font-family: monospace;">minElement()-5-{(5,A),(7,D),(9,C)}
</span><br>
<br>
Let us have a <span style="font-weight: bold;">priority queue</span>
ADT with <span style="font-style: italic;">n</span> elements
implementation with an <span style="font-style: italic;">unsorted
sequence</span>.
Mark the correct/incorrect
correspondence between a function of this ADT and its performance.
<br>
(yes) <span style="font-family: monospace;">minElement()</span> - <span
 style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span>)
<br>
(no) <span style="font-family: monospace;">minKey()</span> - <span
 style="font-style: italic;">O</span>(1)
<br>
<br>
Let us have a <span style="font-weight: bold;">priority queue</span>
ADT with <span style="font-style: italic;">n</span> elements
implementation with a <span style="font-style: italic;">sorted sequence</span>.
Mark the correct/incorrect
correspondence between a function of this ADT and its performance.
<br>
(yes) <span style="font-family: monospace;">minElement()</span> - <span
 style="font-style: italic;">O</span>(1)
<br>
(no) <span style="font-family: monospace;">minElement()</span> - <span
 style="font-style: italic;">O</span>(n)
<br>
<br>
Let us have a <span style="font-weight: bold;">priority queue</span>
ADT with <span style="font-style: italic;">n</span> elements for the <span
 style="font-style: italic;">heap</span> implementation.
Mark the correct/incorrect
correspondence between a function of this ADT and its performance.
<br>
(yes) <span style="font-family: monospace;">minElement()</span> - <span
 style="font-style: italic;">O</span>(1)
<br>
(no) <span style="font-family: monospace;">minElement()</span> - <span
 style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span>)
<br>
<br>
Mark the correct and incorrect definitions and assertions about the <span
 style="font-weight: bold;">dictionary</span> ADT.
<br>
(yes) A dictionary ADT stores key-element pairs (k,e) which we call
items, where k is the key and e is the element.
<br>
(no) Keys in a dictionary can be arbitrary objects on which a total
order must be defined.
<br>
<br>
Let us have a <span style="font-weight: bold;">dictionary</span> ADT <span
 style="font-family: monospace;">D = {(7,B),(2,C),(2,E)}</span> .
Determine the correct/incorrect triples: <span
 style="font-family: monospace;">function-output-new_D</span> . A
triple is correct, when applying the given function on <span
 style="font-family: monospace;">D</span>, the second triple member is
its the return value and the third member is the new
dictionary <span style="font-family: monospace;">D</span>. The
notation <span style="font-family: monospace;">p(X)</span> indicates
the position of the item storing element <span
 style="font-family: monospace;">X</span> .
<br>
(yes) <span style="font-family: monospace;">insertItem(8,A)-NONE-{(7,B),(2,C),(2,E),(8,A)}
</span><br>
(no) <span style="font-family: monospace;">find(B)-p(7)-{(7,B),(2,C),(2,E)}
</span><br>
<br>
A simple way of realizing a {\bf <span style="font-weight: bold;">dictionary</span>}
is to use an unordered vector, list, or general sequence to store the
key-element pairs. Such an implementation is called a<span
 style="font-style: italic;"> log file</span>}.
Mark the correct/incorrect
correspondence between a function of this ADT and its performance.<br>
(yes) <span style="font-family: monospace;">size()</span> - <span
 style="font-style: italic;">O</span>(1)
<br>
(no) <span style="font-family: monospace;">insertItem(k,e)</span> - <span
 style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span>)
<br>
<br>
A simple open addressing strategy for collision handling in <span
 style="font-weight: bold;">hash tables</span> is <span
 style="font-style: italic;">linear probing</span>. Let us have a
bucket array <span style="font-family: monospace;">A =
{E,E,13,E,26,5,D,16,E,E,21}</span> with capacity <span
 style="font-style: italic;">N=</span>11, where <span
 style="font-family: monospace;">E</span> means "empty" and <span
 style="font-family: monospace;">D</span> means "deattached" (or
"available") item.
The hash function is <span style="font-style: italic;">h</span>(<span
 style="font-style: italic;">k</span>) = <span
 style="font-style: italic;">k</span> mod 11. Find the
correct/incorrect correspondence, where <span
 style="font-family: monospace;">-&gt;</span> means "is equivalent to".
<br>
(yes) <span style="font-family: monospace;">insrtItem(11) -&gt; A[0] =
11 </span><br>
(no) <span style="font-family: monospace;">insrtItem(38) -&gt; A[8] =
38<br>
</span>
<hr style="width: 100%; height: 2px;"><span
 style="font-family: monospace;"></span><font size="+1"><br>
</font>
<br>
</body>
</html>
