<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="Author" content="Nikolay Kirov">
    <meta name="GENERATOR" content="Mozilla/4.75 [en] (Win98; U)
      [Netscape]">
    <title>lec11</title>
  </head>
  <body>
    <h2>Разделяй и владей</h2>
    <i>План:<br>
      <a href="problems_11_12.html">Задачи 11 и 12</a><br>
    </i> Метод на разклоненията и границите<br>
    Подрязване на търсенето<br>
    Пълно изчерпване<br>
    Разделяй и владей<br>
    Мажорант <br>
    Бързо умножение на дълги числа<br>
    <a href="problems_13_14.html"><i>Задачи 13 и 14</i></a><br>
    <hr width="100%" size="2">
    <h3><font size="+1">Метод на разклоненията и границите [6.4] </font></h3>
    <p>* При метода търсене с връщане процесът на решаване на задачата
      може да се представи като дърво на търсенето.</p>
    <p>* Движението по дървото е от корена към листата (търсене) и
      когато се достигне листо (няма възможен ход и не е достигнато
      решението), движението се обръща от листото към корена (връщане).<br>
    </p>
    <p>* Идеята на метода на разклоненията и границите е връщането да
      започне преди да е достигнато листо, т.е. във вътрешен възел, ако
      сме сигурни, че решението не е в необходеното поддърво.<br>
    </p>
    <h3>Подрязване на търсенето [<a href="https://cses.fi/book/book.pdf">AL






        p. 51</a>]<br>
    </h3>
    <p>Даден е квадрат, състоящ се от 7x7 квадрати. Да се пресметне по
      колко начина може да се стигне от горния ляв квадрат до долния
      десен квадрат с хоризонтално и вертикално движение.<br>
    </p>
    <h3>Пълно изчерпване (<a
        href="https://en.wikipedia.org/wiki/Brute-force_search">Brute
        force search</a>)<br>
    </h3>
    <p>Намиране на всички подмножества на едно множество.</p>
    <p>{A, B, C}, 2^3 = 8<br>
      {}, {A}, {B}, {C}, {A,B}, {A,C}, {B,C}, {A,B,C}</p>
    <p>Дадено е множество от цели числа. Да се намерят сумите от
      елементите на всички подмножества.<br>
      <br>
      <a href="../sources/subsets.cpp"><font size="+1"><tt>subsets.cpp</tt></font></a><br>
    </p>
    <p><a href="problems_11_12.html">Задача 12. </a>Суми2021 [Meet in
      the middle, <a href="https://cses.fi/book/book.pdf">AL p. 54</a>]<br>
      Дадена е редица от цели числа. Да се провери дали дадено число
      може да се получи като сума на числа от редицата.<br>
    </p>
    <h3><font size="+1"> </font></h3>
    <hr style="width: 100%;">
    <h3>Разделяй и владей [7]<br>
    </h3>
    <p><font size="+1" color="#000000">* Принципи на "разделяй и
        владей": разбиване на изходната задача на няколко подзадачи
        (разделяй), решаване на подзадачите и конструиране на решение на
        изходната задача (владей).</font> </p>
    <font size="+1"> </font>
    <p><font size="+1">* Двоично търсене.</font></p>
    <p><font size="+1"><font color="#000000"><font color="#000000">*</font></font><font
          color="#000000"><font color="#000000"> Бързо сортиране с
            разделяне на дялове (Хоор, "разделяй и владей") - <i>O</i>(<i>n</i><sup>2</sup>)
            в най-лошия случай, <i>O</i>(<i>n</i>) в най-добрия случай,
            <i>O</i>(<i>n</i> log <i>n</i>) средно. Сложността зависи
            от избора на елемент за разделяне на дялове.<br>
          </font></font></font></p>
    <p><font size="+1"><font color="#000000"><font color="#000000">*
            Сортиране чрез сливане<br>
          </font></font></font></p>
    <hr width="100%" size="2">
    <h3><font size="+1"><font color="#000000"><font color="#000000">Мажорант





            [7.2]</font></font></font><br>
    </h3>
    <p><font size="+1"><font color="#000000"><font color="#000000">Нека
            е дадено <i>n</i>-елементно мултимножество (множество, в
            което се допуска повторение на елементи). Ще казваме, че
            даден елемент на множеството е негов мажорант, ако се среща
            строго повече от <i>n</i>/2 пъти.<br>
          </font></font></font></p>
    <p><font size="+1"><font color="#000000"><font color="#000000"><i>Решение</i>
            с двоен цикъл: броене колко пъти се среща всеки елемент - <i>O</i>(<i>n</i><sup>2</sup>).<br>
          </font></font></font></p>
    <p><font size="+1"><font color="#000000"><font color="#000000"><i>Решение</i>
            със сортиране при линейна наредба на елементите му:
            сортираме и проверяваме средния елемент за мажорант <i>- </i>време<i>
              O</i>(<i>n</i> log <i>n</i>) или по-добро, ако сортираме
            с по-бърз алгоритъм.<br>
          </font></font></font></p>
    <p><font size="+1"><font color="#000000"><font color="#000000"><i>Решение</i>
            с броене: <i>O</i>(<i>n</i> + <i>k</i>), ако в масива има
            <i>k</i> различни стойности.<br>
          </font></font></font></p>
    <p><font size="+1"><font color="#000000"><font color="#000000"><i>Твърдение</i>.
            Ако масивът има мажорант и премахнем два различни елемента,
            мажорантът на новия масив ще съвпада с този на изходния.<br>
          </font></font></font></p>
    <p><font size="+1"><font color="#000000"><font color="#000000"><i>Решение</i>
            с кандидат и брояч:<br>
            - Ако броячът е 0, кандидат става текущият елемент, а
            броячът става 1.<br>
            - Ако броячът е различен от 0:<br>
            &nbsp; -- Ако кандидатът съвпада с текущия елемент, броячът
            се увеличава с 1. <br>
            &nbsp; -- Ако са различни, броячът се намалява с 1.<br>
            Ако брoячът е 0 - няма мажорант, иначе проверяваме дали
            кандидатът е мажорант.<i><br>
              Пример</i>:<br>
            C е мажорант<tt><br>
              A A A C C B B C C C B C C</tt></font></font></font><font
        size="+1"><font color="#000000"><font color="#000000"><br>
          </font></font></font></p>
    <p><font size="+1"><font color="#000000"><font color="#000000">А(А,1),





            А(А,2), А(А,3), C(А,2), C(А,1), B(?,0), B(B,1), C(?,0),
            C(C,1), C(C,2), B(C,1), C(C,2), C(C,3)<br>
          </font></font></font></p>
    <p><font size="+1"><font color="#000000"><font color="#000000">C не
            е мажорант</font></font></font><font size="+1"><font
          color="#000000"><font color="#000000"><tt><br>
              A A A A C B B C C C B C C</tt></font></font></font><font
        size="+1"><font color="#000000"><font color="#000000"><br>
          </font></font></font></p>
    <p><font size="+1"><font color="#000000"><font color="#000000"><font
              size="+1"><font color="#000000"><font color="#000000">А(А,1),





                  А(А,2), А(А,3), A(A,4), C(A,3), C(A,2), B(A,1),
                  B(?,0), C(C,1), C(C,2) C(C,3), B(C,2), C(C,3),&nbsp;
                  C(C,4)&nbsp;</font></font></font> </font></font></font></p>
    <p><font size="+1"><font color="#000000"><font color="#000000"> </font></font></font></p>
    <hr width="100%" size="2">
    <h3>Бързо умножение на дълги числа [7.7]&nbsp;</h3>
    <p><big><font color="#000000">* Класическият алгоритъм за умножение
          на цели числа има сложност <i>O</i>(<i>n</i><sup>2</sup>).</font>
      </big></p>
    <p><big><font color="#000000">* Алгоритъм за умножение на две <i>n</i>-цифрени




















          числа <i>X</i> и <i>Y</i>, като <i>n</i> е степен на 2.</font>
      </big></p>
    <center><big><font color="#000000"><i>X = </i>2<sup><i>n</i>/2</sup>
          <i>A + B</i>,&nbsp;&nbsp;&nbsp; <i>Y = </i>2<sup><i>n</i>/2</sup>
          <i>C + D</i></font> <br>
        <font color="#000000"><i>XY = </i>2<i><sup>n</sup></i> <i>AC +
          </i>2<sup><i>n</i>/2</sup> [(<i>A - B</i>)(<i>D - C</i>) <i>+
            AC + BD</i>]<i> + BD</i></font></big></center>
    <big>Числата <i>A, B, C</i> и <i>D</i> са <i>n</i>/2 цифрени
      числа (разделяй) - може да се използва рекурсия, като тривиалният
      случай е (директно) умножение на едноцифрени числа. </big>
    <p><big>* Тази формула изисква 3 умножения, 6 събирания и 2
        премествания вляво (умножения на степени на 2). От рекурентната
        формула </big></p>
    <center><big><i>T</i>(1) = 1,&nbsp; <i>T</i>(<i>n</i>) = 3<i>T</i>(<i>n</i>/2)




















        + <i>cn</i>, <i>n &gt;</i> 0</big></center>
    <big>получаваме, че сложността на алгоритъма е <font
        color="#000000"><i>O</i>(<i>n<sup>r</sup></i>), <i>r = </i>log<sub>2</sub>3.



















        Тъй като log<sub>2</sub>3 &lt; 2, то този алгоритъм е по-добър
        от класическия.</font></big>
    <p><big><font color="#000000">* <i>Пример 1</i>: 15 x 8 =
          120,&nbsp; <i>X</i> = 15 = 1111<sub>2</sub></font>,&nbsp;<i>
          Y</i> = 8 = 1000<sub><font color="#000000">2</font></sub>, <i>n</i>
        = 4 = 2<sup>2</sup> <br>
        <i>&nbsp;A = </i>11, <i>B =</i> 11, <i>C =</i> 10, <i>D =</i>
        00 <br>
        <font color="#000000">&nbsp;<i>AC = </i>110,&nbsp;<i> </i>(<i>A
            - B</i>)(<i>D - C</i>) = 0.10 = 0, <i>BD = </i>0</font> <br>
        <font color="#000000"><i>&nbsp;XY =</i> 110 &lt;&lt; 4 + 110
          &lt;&lt; 2 = 1100000 + 11000 = 1111000<sub>2</sub> =
          8+16+32+64 = 120<sub>10</sub></font> </big></p>
    <p><big>* Когато числата са с различен брой цифри и/или този брой не
        е степен на 2, допълваме отляво с незначещи нули и използваме
        горния алгоритъм. </big></p>
    <p><big>* <i>Пример 2</i>. 50 x 25 = 1250, <font color="#000000"><i>X</i>
          = 50 = 110010<sub>2</sub></font>,&nbsp;<i> Y</i> = 25 = 11001<sub><font
            color="#000000">2</font></sub>, <i>n</i> = 8 = 2<sup>4</sup>
        с допълване до най-близката степен на 2. <br>
        <i>&nbsp;A = </i>0011 (3), <i>B =</i> 0010 (2), <i>C =</i>
        0001 (1), <i>D =</i> 1001 (9) <br>
        <font color="#000000">&nbsp;<i>AC = </i>0011 (3),&nbsp;<i> </i>(<i>A
            - B</i>)(<i>D - C</i>) = 0001.1000 = 1000 (8), <i>BD = </i>10010




















          (18)</font> <br>
        <font color="#000000"><i>&nbsp;XY =</i> 3.256 + (8 + 3 + 18).16
          + 18 =</font> <br>
        <font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
11
&lt;&lt;
8
+
11101
&lt;&lt;
4




















          = 11 0000 0000 + 1 1101 0000 + 10010 = 10011100010<sub>2</sub>
          =</font> <br>
        <font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;




















          2+32+64+128+1024 = 1250<sub>10</sub></font> <br>
        * Подзадачи: <br>
        &nbsp; - представяне на дълги числа (низ или вътрешно); <br>
        &nbsp; - брой на битовете на цяло число; <br>
        &nbsp; - разделяне на десните от левите битове на числото; <br>
        &nbsp; - сума и разлика на две числа. <br>
      </big></p>
    <hr width="100%">
  </body>
</html>
