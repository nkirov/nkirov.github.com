<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>Chapter 8</title>
  </head>
  <body>
    <h2>12. Речници - втора част<br>
    </h2>
    <ul>
    </ul>
    <p><big>Речник АТД<br>
        Хеш таблици<br>
        Клетъчни масиви (bucket arrays)<br>
        Хеш функции<br>
        Хеш кодове<br>
        Компресиращи изображения<br>
        Схеми за решаване на колизии<br>
        Реализация на хеш-таблица със C++ <br>
      </big></p>
    <hr width="100%" size="2">
    <h3><big><span style="font-weight: bold;">Речник АТД</span></big></h3>
    <ul>
    </ul>
    <ul>
      <li><big>Речник АТД съхранява <b>двойки</b> ключ-елемент (<span
            style="font-style: italic;">k</span>,<span
            style="font-style: italic;"> e</span>), които ще наричаме <b>членове</b>
          на речника (items), където <span style="font-style: italic;">k</span>
          е ключ и <span style="font-style: italic;">e</span> е
          елемент. </big></li>
      <li><big>Речник АТД използва позиции и поддържа следните функции
          за речника D:</big></li>
    </ul>
    <table style="width: 100%; text-align: left;" cellspacing="0"
      cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top;"><big>Function<br>
            </big></td>
          <td style="vertical-align: top;"><big>Input<br>
            </big></td>
          <td style="vertical-align: top;"><big>Output<br>
            </big></td>
          <td style="vertical-align: top;"><big>Description<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>size()<br>
            </big></td>
          <td style="vertical-align: top;"><big>-<br>
            </big></td>
          <td style="vertical-align: top;"><big>Integer<br>
            </big></td>
          <td style="vertical-align: top;"><big>Връща броя на елементите
              на <span style="font-style: italic;">D.</span><br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>isEmpty()<br>
            </big></td>
          <td style="vertical-align: top;"><big>-<br>
            </big></td>
          <td style="vertical-align: top;"><big>Boolean<br>
            </big></td>
          <td style="vertical-align: top;"><big>Проверява дали <span
                style="font-style: italic;">D</span> е празен.<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>elements()<br>
            </big></td>
          <td style="vertical-align: top;"><big>-<br>
            </big></td>
          <td style="vertical-align: top;"><big>Iterator of objects
              (elements)<br>
            </big></td>
          <td style="vertical-align: top;"><big>Връща елементите,
              записани в <span style="font-style: italic;">D</span>.<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>keys()<br>
            </big></td>
          <td style="vertical-align: top;"><big>-<br>
            </big></td>
          <td style="vertical-align: top;"><big>Iterator of objects
              (keys)</big></td>
          <td style="vertical-align: top;"><big>Връща ключовете,
              записани в <span style="font-style: italic;">D</span>.</big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>find(k)<br>
            </big></td>
          <td style="vertical-align: top;"><big>Object (key)</big></td>
          <td style="vertical-align: top;"><big>Position<br>
            </big></td>
          <td style="vertical-align: top;"><big>Ако <span
                style="font-style: italic;">D</span> съдържа член с
              ключ, равен на <span style="font-family: monospace;">k</span>,
              връща позицията на този член. Ако не, връща nullposition .<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>findAll(k)<br>
            </big></td>
          <td style="vertical-align: top;"><big>Object (key)</big></td>
          <td style="vertical-align: top;"><big>Iterator of Positions</big></td>
          <td style="vertical-align: top;"><big>Връща итератор от
              позициите на всички членове, чийто ключове са равни на <span
                style="font-family: monospace;">k</span>.<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>insertItem(k,e)<br>
            </big></td>
          <td style="vertical-align: top;"><big>Objects <span
                style="font-family: monospace;">k</span> (key) and<span
                style="font-family: monospace;"> e</span><span
                style="font-family: monospace;"></span> (element) </big></td>
          <td style="vertical-align: top;"><big>-<br>
            </big></td>
          <td style="vertical-align: top;"><big>Вмъква двойка с елемент
              <span style="font-family: monospace;">e</span> и ключ <span
                style="font-family: monospace;">k</span> в <span
                style="font-style: italic;">D</span>.<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>removeElement(k)<br>
            </big></td>
          <td style="vertical-align: top;"><big>Object (key)<br>
            </big></td>
          <td style="vertical-align: top;"><big>-<br>
            </big></td>
          <td style="vertical-align: top;"><big>Премахва член с ключ
              равен на <span style="font-family: monospace;">k</span>
              от <span style="font-style: italic;">D</span>. Ако в <span
                style="font-style: italic;">D</span> няма такъв член се
              генерира грешка (error condition).<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>removeAllElements(k)<br>
            </big></td>
          <td style="vertical-align: top;"><big>Object (key)</big></td>
          <td style="vertical-align: top;"><big>-<br>
            </big></td>
          <td style="vertical-align: top;"><big>Премахва всички двойки с
              ключове равни на <span style="font-family: monospace;">k</span>
              от <span style="font-style: italic;">D</span>.</big></td>
        </tr>
      </tbody>
    </table>
    <br>
    <hr style="width: 100%; height: 1px;">
    <h2>Хеш таблици<br>
    </h2>
    <ul>
      <li><big>Един от най-ефективните начини за реализация на речник
          АТД е използването на <b>хеш таблица</b>. </big></li>
      <li><big>Въпреки, че хеш таблици имат голямо време за изпълнение
          за операциите на речник АТД<font size="+1"> </font></big><big><font
            size="+1">в най-лошия случай</font> (теоретична оценка), ще
          видим, че тяхното очаквано време за изпълнение в повечето
          случаи е отлично.</big></li>
      <li><big>Ако <span style="font-style: italic;">n</span> означава
          броя на членовете на речника, времето за работа в най-лошия
          случай е <span style="font-style: italic;">O</span>(<span
            style="font-style: italic;">n</span>), но очакваното време
          за работа в общия случай е само <span style="font-style:
            italic;">O</span>(1).</big></li>
    </ul>
    <big><span style="font-weight: bold;">Клетъчни масиви (bucket
        arrays)</span><br>
    </big>
    <ul>
      <li><big><b>К</b><b>летъчен масив</b> за хеш таблица е масив <span
            style="font-style: italic;">A</span> с размер <span
            style="font-style: italic;">N</span> (капацитет), където
          всеки елемент на <span style="font-style: italic;">A</span>
          се разглежда като клетка (т.е. контейнер за двойката
          ключ-елемент)<span style="font-style: italic;"></span><span
            style="font-style: italic;"></span>. </big></li>
      <li><big>Ако ключовете са цели положителни числа, <i>добре
            разпределени</i> в интервала [0, <span style="font-style:
            italic;">N</span> <span style="font-style: italic;">-</span>
          1], този клетъчен масив е всичко, от което се нуждаем -
          двойката (<i>k</i>, <i>e</i>)<span style="font-style:
            italic;"></span>&nbsp;<span style="font-style: italic;"></span>
          просто се поставя в клетка <span style="font-style: italic;">A</span>[<span
            style="font-style: italic;">k</span>].</big></li>
      <li><big>Ако ключовете не са уникални, тогава два елемента може да
          попаднат е една и съща клетка от <span style="font-style:
            italic;">A</span>. В този случай казваме, че се появява <i>колизия</i>.</big></li>
    </ul>
    <big><b>Анализ на структурата клетъчен масив</b><br>
    </big>
    <ul>
      <li><big>Достижение: <span style="font-style: italic;">O</span>(1)



























          за всички функции, няма колизии за различни ключове. </big></li>
      <li><big>Недостатък 1: Използва памет <i>О</i>(<span
            style="font-style: italic;">N</span>), твърде разточително
          когато <span style="font-style: italic;">N</span> е голямо
          спрямо <span style="font-style: italic;">n.</span></big></li>
      <li><big>Недостатък 2: Ключовете са цели числа в интервала [0, <span
            style="font-style: italic;">N -</span> 1], което често не е
          така.</big></li>
    </ul>
    <p><font size="+1"><i>Пример:</i> Речник, състоящ се от (FN, name) -
        факултетен номер и име на студент, като речникът съхранява данни
        за студентите от този курс&nbsp; (<i>n</i> &lt; 100, <i>N</i> =
        100000)</font>.<br>
    </p>
    <ul>
    </ul>
    <h2><span style="font-weight: bold;"></span></h2>
    <hr width="100%" size="2">
    <h2><span style="font-weight: bold;">Хеш функции</span></h2>
    <h2><big> </big></h2>
    <ul>
      <li><big><b>Хеш функция</b> <span style="font-style: italic;">h</span>
          изобразява ключове от даден тип&nbsp; в цели числа от
          интервала [0, <span style="font-style: italic;">N</span> −
          1].</big></li>
      <li><big><i><span style="color: rgb(0, 102, 0);">Пример:</span></i><span
            style="font-style: italic;"> </span></big><br>
        <big><span style="font-style: italic;">h</span>(<span
            style="font-style: italic;">x</span>) = <span
            style="font-style: italic;">x</span> mod <span
            style="font-style: italic;">N</span> е хеш функция за цели
          числа (напр. FN mod 100)<br>
        </big></li>
      <li><big>Цялото число <span style="font-style: italic;">h</span>(<span
            style="font-style: italic;">x</span>) се нарича <b>хеш
            стойност</b> на ключа <span style="font-style: italic;">x.</span></big></li>
      <li><big><b>Хеш таблица</b> за даден тип ключове се състои от:</big></li>
      <ul>
        <li><big>хеш функция <span style="font-style: italic;">h,<br>
            </span></big></li>
        <li><big>масив с размер <span style="font-style: italic;">N.</span></big></li>
      </ul>
      <li><big>Когато се реализира речник с хеш таблица, целта е да се
          постави обекта (<span style="font-style: italic;">k</span>, <span
            style="font-style: italic;">e</span>) в масива с индекс <span
            style="font-style: italic;">i</span> =&nbsp; <span
            style="font-style: italic;">h</span>(<span
            style="font-style: italic;">k</span>).</big></li>
      <li style="color: rgb(0, 102, 0);"><i><big>Пример:</big></i></li>
    </ul>
    <table style="text-align: left; width: 100%;" cellspacing="2"
      cellpadding="2" border="0">
      <tbody>
        <tr>
          <td style="vertical-align: top;"><big><img style="width:
                286px; height: 298px;" alt="" src="pic1.jpg"><br>
            </big></td>
          <td style="text-align: left; vertical-align: middle;">
            <ul>
              <li><big>Да се направи хеш таблица за речник, съдържащ
                  двойки (SSN, Name), където SSN (social security
                  number) е 9-цифрово положително число.</big></li>
              <li><big>Ако хеш таблицата използва масив с размер N =
                  10000 и хеш функция <i>h</i>(<i>x</i>) = <i>x</i>
                  mod 10000, т.е. (последните 4 цифри на x), може да
                  възникнат колизии.<br>
                </big></li>
              <li><big>За да се избегнат колизии, ще трябва да се вземе
                  <span style="font-style: italic;">N</span> = 10<sup>9</sup>
                  и хеш функция <span style="font-style: italic;">h</span>(<span
                    style="font-style: italic;">x</span>) = <span
                    style="font-style: italic;">x </span>(Недостатък 1)<span
                    style="font-style: italic;">.<br>
                  </span></big></li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <ul>
      <li> <big>Хеш функцията </big><big><big><span style="font-style:
              italic;"><font size="+1">h</font> </span></big>обикновено
          се разглежда като композиция на две функции:<br>
        </big> </li>
      <ul>
        <li><big><b>Хеш код</b>: <span style="font-style: italic;">h</span><sub>1</sub>:
            keys → integers</big></li>
        <li><big><b>Компресия</b>: <span style="font-style: italic;">h</span><sub>2</sub>:
            integers → [0, <span style="font-style: italic;">N</span> −
            1]</big></li>
      </ul>
      <li><big>Хеш кода се прилага първи и след това компресията се
          прилага върху резултата, т.е.&nbsp;<span style="font-style:
            italic;">h</span>(<span style="font-style: italic;">x</span>)
          = <span style="font-style: italic;">h</span><sub>2</sub>(<span
            style="font-style: italic;">h</span><sub>1</sub>(<span
            style="font-style: italic;">x</span>)).</big></li>
      <li><big>Целта на хеш функцията е да "разпръсне" ключовете по
          (привидно) случаен начин.</big></li>
      <li><big>Хеш функцията е "добра", ако изобразява ключовете на
          речника така, че да <i>минимизира колизиите</i>.</big></li>
      <li><big>Тя трябва да бъде също така <i>бърза и лесна за
            пресмятане</i>.</big></li>
    </ul>
    <h3><big><span style="font-weight: bold;"></span></big></h3>
    <hr width="100%" size="2">
    <h3><big><span style="font-weight: bold;">Хеш кодове</span></big></h3>
    <h3><big> </big></h3>
    <ul>
      <li><big>Цяло число, което съответства на ключа <span
            style="font-style: italic;">k</span> се нарича хеш код или
          хеш стойност за <span style="font-style: italic;">k</span>.</big></li>
    </ul>
    <big><b>Хеш кодове в C++</b><br>
    </big>
    <ul>
      <li><big>Адреси на паметта:<br>
        </big></li>
      <ul>
        <li><big>Преобразува се адреса (в паметта на компютъра) на ключа
            в цяло число - <tt>static_cast&lt;int&gt;(&amp;key).</tt></big></li>
        <li><big>Добър като цяло, с изключение на числови и низови
            ключове (има по-добри хеш кодове).<br>
          </big></li>
      </ul>
      <li><big>Integer cast:</big></li>
      <ul>
        <li> <big>Преобразуват се</big><big> битовете на ключа в цяло
            число.<br>
          </big> </li>
        <li> <big>Подходящ за ключове с дължина по-малка или равна на
            броя на битовете на числовия тип (например, </big><big>char,
















            short, int и float за много машини).<br>
          </big> </li>
      </ul>
      <li><big>Сума на компонентите:</big></li>
      <ul>
        <li><big>Разделят се битовете на ключа на компоненти с фиксирана
            дължина (например 16 или 32 бита) и се сумират компонентите
            (игнорирайки евентуално препълване).</big></li>
        <li> <big>Подходящ за числови ключове с фиксирана дължина,
            по-голяма или равна на броя на битовете на числовия тип
            (например,&nbsp;</big><big><big> <font size="+1">long</font>
            </big> и double за много машини).</big> </li>
      </ul>
    </ul>
    <big><b>C++ примери</b><br>
      32-bit integer if we have 32-bit integer hash function<br>
    </big>
    <pre><big>int hashCode(int x)<br>{ return x; }</big></pre>
    <big>64-bit integer if we have 32-bit integer hash function</big>
    <pre><big>int hashCode(long x)<br>{  typedef unsigned long ulong;<br>   return hashCode(static_cast&lt;int&gt;(static_cast&lt;ulong&gt;(x) &gt;&gt; 32) <br>          + static_cast&lt;int&gt;(x));<br>}</big></pre>
    <big><span style="font-weight: bold;">Полиномен хеш код</span><br>
    </big>
    <ul>
      <li><big>Полиномиално натрупване:</big></li>
      <ul>
        <li><big>Разделят се битовете на ключа на редица от компоненти с
            фиксирана дължина (например, 8, 16 или 32 бита): <span
              style="font-style: italic;">a</span><sub>0</sub> <span
              style="font-style: italic;">a</span><sub>1</sub>… <span
              style="font-style: italic;">a</span><sub><span
                style="font-style: italic;">n</span>−1.</sub></big></li>
        <li><big>Пресмята се стойността на полинома<br>
            <span style="font-style: italic;">p</span>(<span
              style="font-style: italic;">z</span>) =<span
              style="font-style: italic;"> a</span><sub>0</sub> +<span
              style="font-style: italic;"> a</span><sub>1</sub><span
              style="font-style: italic;">z</span> + <span
              style="font-style: italic;">a</span><sub>2</sub> <span
              style="font-style: italic;">z</span><sup><sub>2</sub></sup>
            + … + <span style="font-style: italic;">a<sub>n</sub></span><sub>−1</sub><span
              style="font-style: italic;">z<sup><sub>n</sub></sup></span><sup><sub>−1</sub></sup><br>
            за фиксирана стойност на <span style="font-style: italic;">z</span>,
            игнорирайки препълването.</big></li>
        <li><big>Особено подходящ за низове (напр. изборът <span
              style="font-style: italic;">z</span> = 33 дава най-много 6
            колизии за множество от 50000 английски думи!)</big></li>
      </ul>
      <li><big>Стойността на полиномът <span style="font-style:
            italic;">p</span>(<span style="font-style: italic;">z</span>)
          се смята за време <span style="font-style: italic;">O</span>(<span
            style="font-style: italic;">n</span>) по схемата на Хорнер:</big></li>
      <ul>
        <li> <big>Следните полиноми се изчисляват </big><big><big> <font
                size="+1">последователно</font></big><font size="+1">, </font>като























            всеки от предишния, за време <span style="font-style:
              italic;">O</span>(1) -<br>
            <span style="font-style: italic;">p</span><sub>0</sub>(<span
              style="font-style: italic;">z</span>) = <span
              style="font-style: italic;">a<sub>n</sub></span><sub>−1,&nbsp;</sub><span
              style="font-style: italic;"> p</span><sub><span
                style="font-style: italic;">i</span></sub>(<span
              style="font-style: italic;">z</span>) = <span
              style="font-style: italic;">a<sub>n−i−</sub></span><sub>1</sub>
            + <span style="font-style: italic;">zp<sub>i−</sub></span><sub>1</sub>(<span
              style="font-style: italic;">z</span>) (<span
              style="font-style: italic;">i</span> = 1, 2, …, <span
              style="font-style: italic;">n −</span> 1).</big> </li>
      </ul>
      <li><big>Получаваме <span style="font-style: italic;">p</span>(<span
            style="font-style: italic;">z</span>) =<span
            style="font-style: italic;"> p<sub>n</sub></span><sub>−1</sub>(<span
            style="font-style: italic;">z</span>).</big></li>
    </ul>
    <big> <b>Циклични </b></big><big><b><font size="+1">с преместване
          хеш</font></b><b> кодове </b><br>
    </big>
    <blockquote>
      <pre><big>int hashCode(const char* p, int len) // hash a character array<br>{ unsigned int h = 0;<br>  for (int i = 0; i &lt; len; i++)<len i=""><br>  { h = (h &lt;&lt; 5)|(h &gt;&gt; 27);          // 5-bit cyclic shift<br>    h += (unsigned int)p[i];         // add in next character<br>  }<br>  return hashCode(int(h));<br>}<br></len></big></pre>
    </blockquote>
    <big>Експериментални резултати за 25000 английски думи</big>
    <table style="text-align: left; width: 687px; height: 144px;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top;"><big>Shift<br>
            </big></td>
          <td style="vertical-align: top;"><big>Collisions Total<br>
            </big></td>
          <td style="vertical-align: top;"><big>Collisions Max<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>0<br>
            </big></td>
          <td style="vertical-align: top;"><big>23739<br>
            </big></td>
          <td style="vertical-align: top;"><big>86<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>1<br>
            </big></td>
          <td style="vertical-align: top;"><big>10517<br>
            </big></td>
          <td style="vertical-align: top;"><big>21<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>5<br>
            </big></td>
          <td style="vertical-align: top;"><big>4<br>
            </big></td>
          <td style="vertical-align: top;"><big>2<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>6<br>
            </big></td>
          <td style="vertical-align: top;"><big>6<br>
            </big></td>
          <td style="vertical-align: top;"><big>2<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>11<br>
            </big></td>
          <td style="vertical-align: top;"><big>453<br>
            </big></td>
          <td style="vertical-align: top;"><big>4<br>
            </big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
      <b>Хеширане на типове с плаваща точка</b><br>
    </big>
    <blockquote>
      <pre><big>int hashCode(const double&amp; x)       // hash a double<br>{ int len = sizeof(x);<br>  const char* p = reinterpret_cast&lt;const char *&gt;(&amp;x);<len i=""><br>  return hashCode(p, len);<br>}<br></len></big></pre>
    </blockquote>
    <a href="hash_code.cpp"><big><tt>hash_code.cpp</tt></big></a><br>
    <h3><big> </big></h3>
    <hr width="100%" size="2">
    <h3><big>Компресиращи изображения<br>
      </big></h3>
    <ul>
      <li> <big>Хеш кода за ключ <i>k</i> обикновено не е подходящ за
          незабавнo използване с употреба с </big><big><font size="+1">клетъчния&nbsp;</font>масив,


















          тъй като интервалът от възможни хеш кодове за ключовете
          обикновено надвишава интервала за допустими индекси на масива.</big>
      </li>
    </ul>
    <big><span style="font-weight: bold;">Метод на деленето</span><br>
    </big>
    <ul>
      <li><big><span style="font-style: italic;">h</span><sub>2</sub>(<span
            style="font-style: italic;">y</span>) = | <span
            style="font-style: italic;">y</span> | mod <span
            style="font-style: italic;">N.</span></big></li>
      <li><big>Размерът <span style="font-style: italic;">N</span> на
          хеш таблицата обикновено се избира просто число.<span
            style="font-style: italic;"></span><br>
        </big></li>
      <li><big>Причината за това е свързана с теорията на числата и е
          извън обхвата на този курс.</big></li>
    </ul>
    <big><span style="font-weight: bold;"> Метод MAD</span><br>
      Умножи, събери и раздели (Multiply, Add and Divide - MAD):<br>
    </big>
    <ul>
      <li><big><span style="font-style: italic;">h</span><sub>2</sub>(<span
            style="font-style: italic;">y</span>) = <span
            style="font-style: italic;">|ay</span> + <span
            style="font-style: italic;">b</span>| mod <span
            style="font-style: italic;">N</span></big></li>
      <li><big><span style="font-style: italic;">a</span> и <span
            style="font-style: italic;">b</span> са неотрицателни числа,
          такива че <span style="font-style: italic;">a</span> mod <span
            style="font-style: italic;">N</span> ≠ 0.</big></li>
      <li><big>В противен случай, всяко число ще се изобразява в една и
          съща стойност <span style="font-style: italic;">b.</span></big></li>
    </ul>
    <h3><big><span style="font-weight: bold;"></span></big></h3>
    <hr width="100%" size="2">
    <h3><big><span style="font-weight: bold;">Схеми за решаване на
          колизии</span></big></h3>
    <h3><big> </big></h3>
    <ul>
      <li><big><span style="font-style: italic;">Колизия </span>възниква,






















          когато различни елементи трябва да се поставят в една и съща
          клетка, т.е. ключовете им имат една и съща хеш стойност.</big></li>
    </ul>
    <big><span style="font-weight: bold;">Самостоятелни вериги (separate
        chaining) <br>
      </span></big>
    <ul>
      <li><big>Верижно съставяне: нека всяка клетка от таблицата е адрес
          на първия елемент на свързан списък.</big></li>
      <li><big>Верижно съставяне е просто, но изисква допълнителна памет
          извън таблицата.</big></li>
    </ul>
    <big><span style="font-weight: bold;"><img style="width: 394px;
          height: 163px;" alt="" src="pic2.jpg"><br>
      </span><span style="font-weight: bold;"><br>
        Отворено адресиране<br>
        <br>
      </span>При колизия обектът се поставя в друга клетка на таблицата.<br
        style="font-weight: bold;">
      <span style="font-weight: bold;"></span></big>
    <hr width="100%" size="2"><big><span style="font-weight: bold;">Линейно






        пробване (linear probing)</span><br>
    </big>
    <ul>
      <li><big>Линейното пробване решава колизиите като поставя обекта в
          следващата свободна (кръгово) клетка на таблицата.</big></li>
      <li><big>Всяка проверена клетка на таблицата се разглежда като
          "проба".</big></li>
      <li><big>Недостатък/ Обектите с колизии се струпват, като
          следващите колизии предизвикват по-дълги редици от проби.</big></li>
      <li><big><i>Пример:</i><br>
        </big></li>
    </ul>
    <table style="text-align: left; width: 100%;" cellspacing="2"
      cellpadding="2" border="0">
      <tbody>
        <tr>
          <td style="vertical-align: top;"><big><img style="width:
                379px; height: 178px;" alt="" src="pic3.jpg"><br>
            </big></td>
          <td>
            <ul>
              <li><big><span style="font-style: italic;">h</span>(<span
                    style="font-style: italic;">x</span>) = <span
                    style="font-style: italic;">x</span> mod 13</big></li>
              <li><big>Добавяме ключове 18, 41, 22, 44, 59, 32, 31, 73 в
                  този ред:</big></li>
              <li><font size="+1"><i>h</i>(18) = 18 mod 13 = 5 -&gt;
                  a[5] = 18<br>
                  <i>h</i>(41) = 41 mod 13 = 2 -&gt; a[2] = 41<br>
                  <i>h</i>(22) = 22 mod 13 = 9 -&gt; a[9] = 22<br>
                  <i>h</i>(44) = 44 mod 13 = 5 -&gt; a[5] заета, a[6] =
                  44;<br>
                  <i>h</i>(59) = 59 mid 13 = 7 -&gt; a[7] = 59<br>
                  <i>h</i>(31) = 32&nbsp; mod 13 = 6 -&gt; a[6] заета,
                  a[7]&nbsp; заета, a[8] = 32<br>
                  <i>h</i>(31) = 31 mod 13 = 5 -&gt; a[5]-a[9] заети,
                  a[10] = 31<br>
                  <i>h</i>(73) = 73 mod 13 = 8 -&gt; a[8]-a[10] заети,
                  a[11] = 73</font></li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>
    <big><br>
      find(22), 22 mod 13 = 9, a[9] = 22 -&gt; намерен ключ 22<br>
      find(23), 23 mod 13 = 10, a[10]&nbsp; = 31, a[11] = 73, a[12]
      празно -&gt; няма ключ 23<br>
      find(4), 4 mod 13 = 4, a[4] празно -&gt; няма ключ 4<br>
      find(41), 41 mod 13 = 2, a[2] = 41 -&gt; намерен ключ 41<br>
      find(2), 2 mod 13 = 2, a[2] = 41, a[3] празно -&gt; няма ключ 3<br>
      <br>
      <b>Търсене с линейно пробване</b><br>
    </big>
    <table style="text-align: left; width: 100%;" cellspacing="2"
      cellpadding="2" border="0">
      <tbody>
        <tr>
          <td style="vertical-align: middle;">
            <ul>
              <li><big>Нека хеш таблицата <span style="font-style:
                    italic;">A</span> използва линейно пробване.</big></li>
              <li><big><span style="font-family: monospace;">find</span>(<span
                    style="font-style: italic;">k</span>)</big></li>
              <ul>
                <li><big>Започва се с клетка <span style="font-style:
                      italic;">h</span>(<span style="font-style:
                      italic;">k</span>).</big></li>
                <li><big>Пробват се последователни клетки, докато се
                    появи един от следните случаи:</big></li>
                <ul>
                  <li><big>обект с ключ <span style="font-style:
                        italic;">k</span> е намерен, или<br>
                    </big></li>
                  <li><big>достигната е празна клетка, или<br>
                    </big></li>
                  <li><big><span style="font-style: italic;">N</span>
                      клетки се пробвани без резултат.</big></li>
                </ul>
              </ul>
            </ul>
          </td>
          <td style="vertical-align: top; white-space: nowrap;"><big>Algorithm




























              <span style="color: rgb(204, 0, 0);"><span
                  style="font-style: italic;">find</span>(<span
                  style="font-style: italic;">k</span>)</span><br>
              <span style="color: rgb(51, 102, 102);"><span
                  style="font-style: italic;">&nbsp;&nbsp; i</span> ←<span
                  style="font-style: italic;"> h</span>(<span
                  style="font-style: italic;">k</span>)</span><br
                style="color: rgb(51, 102, 102);">
              <span style="color: rgb(51, 102, 102);"><span
                  style="font-style: italic;">&nbsp;&nbsp; p</span> ← 0</span><br>
              &nbsp;&nbsp; repeat<br>
              <span style="color: rgb(51, 102, 102);"><span
                  style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;



























                  c</span> ← <span style="font-style: italic;">A</span>[<span
                  style="font-style: italic;">i</span>]</span><br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if<span style="color:
                rgb(51, 102, 102);"> <span style="font-style: italic;">c</span>
                = ∅</span><br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              return <span style="color: rgb(51, 102, 102);"><span
                  style="font-style: italic;">Position</span>(<span
                  style="font-style: italic;">null</span></span>)<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if <span
                style="color: rgb(51, 102, 102);"><span
                  style="font-style: italic;">c.key</span>() = <span
                  style="font-style: italic;">k</span></span><br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              return <span style="color: rgb(51, 102, 102);"><span
                  style="font-style: italic;">Position</span>(<span
                  style="font-style: italic;">c</span>)</span><br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
              <span style="color: rgb(51, 102, 102);"><span
                  style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;



























                  i</span> ← (<span style="font-style: italic;">i +</span>
                1) mod <span style="font-style: italic;">N</span></span><br
                style="color: rgb(51, 102, 102);">
              <span style="color: rgb(51, 102, 102);"><span
                  style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;



























                  p</span> ← <span style="font-style: italic;">p +</span>
                1</span><br>
              &nbsp;&nbsp; until <span style="color: rgb(51, 102,
                102);"><span style="font-style: italic;">p</span> = <span
                  style="font-style: italic;">N</span></span><br>
              &nbsp;&nbsp; return <span style="color: rgb(51, 102,
                102);"><span style="font-style: italic;">Position</span>(<span
                  style="font-style: italic;">null</span>)</span><br>
            </big></td>
        </tr>
      </tbody>
    </table>
    <big><span style="font-weight: bold;"><br>
        Обновяване с линейно пробване<br>
      </span></big>
    <ul>
      <li><big>За да се организират вмъквания и изтривания, се въвежда
          специален обект, наречен AVAILABLE (FREE), който замества
          изтритите обекти.</big></li>
      <li><big><span style="font-family: monospace;">removeElement</span>(<span
            style="font-style: italic;">k</span>)</big></li>
      <ul>
        <li><big>Търси се обект с ключ <span style="font-style:
              italic;">k.</span></big></li>
        <li><big>Ако обектът (<span style="font-style: italic;">k</span>,
            <span style="font-style: italic;">e</span>) е намерен, той
            се замества със специалния обект AVAILABLE и се връща
            позицията му.</big></li>
        <li><big>В противен случай се връща nullposition.</big></li>
      </ul>
      <li><big><span style="font-family: monospace;">insertItem</span>(<span
            style="font-style: italic;">k</span>, <span
            style="font-style: italic;">e</span>)</big></li>
      <ul>
        <li><big>Ако таблицата е пълна, се изхвърля изключение.</big></li>
        <li><big>Започва се с клетка <span style="font-style: italic;">h</span>(<span
              style="font-style: italic;">k</span>). </big></li>
        <li><big>Пробват се последователно клетките докато се появи един
            от следните случаи:</big></li>
        <ul>
          <li><big>намерена е клетка <span style="font-style: italic;">i</span>,
              която е празна или съдържа AVAILABLE, или<br>
            </big></li>
          <li><big><span style="font-style: italic;">N</span> клетки са
              пробвани без резултат.</big></li>
        </ul>
        <li><big>В парвия случай обектът (<span style="font-style:
              italic;">k</span>, <span style="font-style: italic;">e</span>)
            се поставя в клетка <span style="font-style: italic;">i.</span></big></li>
      </ul>
    </ul>
    <big><span style="font-weight: bold;"> </span><span
        style="font-weight: bold;"></span></big>
    <hr width="100%" size="2"><big><span style="font-weight: bold;">Двойно






        хеширане</span><br>
    </big>
    <ul>
      <li><big>Двойно хеширане използва втора хеш функция <span
            style="font-style: italic;">d</span>(<span
            style="font-style: italic;">k</span>) и обработва колизии
          чрез поставяне на обекта в първата свободна клетка от серията
          (редицата):<br>
        </big></li>
    </ul>
    <p><big>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;



        (<span style="font-style: italic;">h(k)+ jd</span>(<span
          style="font-style: italic;">k</span>)) mod <span
          style="font-style: italic;">N</span> за <span
          style="font-style: italic;">j </span>= 0, 1, … , <span
          style="font-style: italic;">N</span> −1.</big></p>
    <ul>
      <li><big>Втората хеш функция <span style="font-style: italic;">d</span>(<span
            style="font-style: italic;">k</span>) не трябва да има
          нулеви стойности.</big></li>
      <li><big>Размерът <span style="font-style: italic;">N</span> на
          таблицата трябва да бъде просто число, за да може да се
          пробват всички клетки.</big></li>
      <li><big>За компресията на втората хеш функция обикновено се
          избира функцията <span style="font-style: italic;">d</span><sub>2</sub>(<span
            style="font-style: italic;">k</span>) = <span
            style="font-style: italic;">q − k</span> mod <span
            style="font-style: italic;">q</span> където<br>
        </big></li>
      <ul>
        <li><big><span style="font-style: italic;">q</span> &lt; <span
              style="font-style: italic;">N<br>
            </span></big></li>
        <li><big><span style="font-style: italic;">q</span> е просто
            число.<br>
          </big></li>
      </ul>
      <li><big>Възможни стойности на <span style="font-style: italic;">d</span><sub>2</sub>(<span
            style="font-style: italic;">k</span>) са 1, 2, … , <span
            style="font-style: italic;">q.</span></big></li>
      <li><i><big>Пример:</big></i></li>
    </ul>
    <big> </big>
    <table style="text-align: left; width: 100%;" cellspacing="2"
      cellpadding="2" border="0">
      <tbody>
        <tr>
          <td style="vertical-align: top;"><big><img style="width:
                379px; height: 413px;" alt="" src="pic4.jpg"><br>
            </big></td>
          <td style="vertical-align: middle;">
            <ul>
              <li><big>Разглеждаме хеш таблица за съхранение на
                  целочислени ключове, обработваща колизии с двойно
                  хеширане</big></li>
              <ul>
                <li><big><span style="font-style: italic;">N</span> = 13</big></li>
                <li><big><span style="font-style: italic;">h</span>(<span
                      style="font-style: italic;">k</span>) = <span
                      style="font-style: italic;">k</span> mod 13</big></li>
                <li><big><span style="font-style: italic;">d</span>(<span
                      style="font-style: italic;">k</span>) = 7 − <span
                      style="font-style: italic;">k</span> mod 7</big></li>
              </ul>
              <li><big>Въвеждат се ключове 18, 41, 22, 44, 59, 32, 31,
                  73, в този ред:</big></li>
              <li><big><font size="+1"><i>h</i>(18) = 18 mod 13 = 5
                    --&gt; a[5] = 18, (j = 0)<br>
                    <i>h</i>(41) =&nbsp; 41 mod 13 = 2 --&gt; a[2] = 41,
                    (j = 0)<br>
                    <i>h</i>(22) = 22 mod 13 = 9 --&gt; a[9] = 22, (j =
                    0)<br>
                    <i>h</i>(44) = 44 mod 13 = 5 --&gt; a[5] ,(j = 0),
                    заета,&nbsp;</font></big><br>
                <big><font size="+1"><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;



                      d</i>(44) = 7 - 44 mod 7 = 7 - 2 = 5 -- &gt; 5 +
                    1.5 = 10, a[10] = 44, (j = 1)</font></big> <br>
                <big><font size="+1"><i>h</i>(59) = 59 mod 13 = 7 --&gt;
                    a[7] = 59, (j = 0)</font></big></li>
              <big><font size="+1"> </font></big> <big><font size="+1">
                  <i>h</i>(32) = 32&nbsp; mod 13 = 6 --&gt; a[6] = 32,
                  (j = 0)<br>
                  <i>h</i>(31) = 31 mod 13 = 5 --&gt; a[5] (j = 0),
                  заетa,&nbsp;</font></big><br>
              <big><font size="+1"><i>&nbsp;&nbsp;&nbsp;&nbsp; d</i>(31)
                  = 7 - 31 mod 7 = 7 - 3 = 4 --&gt; 5 + 1.4 = 9, a[9] (j
                  = 1), заета, </font></big><br>
              <big><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                  5 + 2.4 = 13, a[0] = 31, (j = 2);<br>
                  <i>h</i>(73) = 73 mod 13 = 8 --&gt; a[8] = 73, (j = 0)</font><big><br>
                </big></big>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>
    <big><br>
      <hr width="100%" size="2">
      <h4><big>Реализация на хеш-таблица със C++ <br>
        </big></h4>
      <big><a href="8.1_LinearProbeHashTable.h-HashEntry.html">html-8.1</a>
        (HashEntry)<br>
        <a href="8.2_LinearProbeHashTable.h-Position.html">html-8.2</a></big>
      <big>(Position)<br>
        <a href="8.3_LinearProbeHashTable.h-Hash1.html">html-8.3</a></big>
      <big> (Hash1)<br>
        <a href="8.4_LinearProbeHashTable.h-Hash2.html">html-8.</a></big>
      <big><a href="8.4_LinearProbeHashTable.h-Hash2.html">4</a> (Hash2)<br>
        <br>
        <a style="font-family: monospace;" href="hash.cpp">hash.cpp</a></big><span
        style="font-family: monospace;"> </span><big><span
          style="font-weight: bold;"><br>
          <hr style="width: 100%; height: 2px;"></span></big><big><span
          style="font-weight: bold;"></span></big> </big>
  </body>
</html>
