<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">
  <title>Chapter 6</title>
</head>
<body>
<h2>Chapter 6. Trees II<br>
</h2>
<h3> 6.3 Binary Trees</h3>
<big>A <span style="font-weight: bold;">binary tree</span>
is an
ordered tree in which every node has at most two children. </big><big>A
binary tree is <span style="font-weight: bold;">proper</span>
if each internal node has two children.</big><br>
<big><a href="Trees-slides.pdf">Trees.pdf</a>  8</big><br>
<br>
<big>Example: arithmetic expression, decision tree<br>
</big><big><a href="Trees-slides.pdf">Trees.pdf</a>  8</big><br>
<h4><big><span style="font-weight: bold;"> 6.3.1 The Binary Tree ADT</span></big></h4>
<big><a href="Trees-slides.pdf">Trees.pdf</a>  12</big><br>
<h4><big><span style="font-weight: bold;">6.3.2 A Binary Tree Interface</span></big></h4>
<big><span style="font-weight: bold;">
</span><a href="6.14a_InspectableBinaryTree.h-InspectableBinaryTree.html">html-6.14a</a>
(InspectableBinaryTree)<br>
<a href="6.14b_BinaryTree.h-BinaryTree.html">html-6.14b</a> (BinaryTree)<br>
</big>
<h4><big><span style="font-weight: bold;">6.3.3 Properties of Binary
Trees</span></big></h4>
<big>We denote the set of all nodes of a binary tree <span style="font-style: italic;">T</span>, at the same depth <span style="font-style: italic;">d</span>, as the <span style="font-weight: bold;">leve</span>l <span style="font-style: italic;">d</span> of <span style="font-style: italic;">T</span>.</big> <br>
<big><span style="font-weight: bold;">Proposition 6.9:</span> Let <span style="font-style: italic;">T</span> be a proper binary tree with <span style="font-style: italic;">n</span> nodes and let <span style="font-style: italic;">h</span> denote the height of <span style="font-style: italic;">T</span>. Then <span style="font-style: italic;">T</span> has the following properties:<br>
</big>
<ol>
  <li><big>The number of external nodes <span style="font-style: italic;">e</span> in <span style="font-style: italic;">T</span> is: <span style="font-style: italic;">h</span> + 1 &lt;= <span style="font-style: italic;">e</span> &lt;= 2<sup><span style="font-style: italic;">h</span></sup> </big></li>
  <li>
<big>The number of internal nodes <span style="font-style: italic;">i</span> in <span style="font-style: italic;">T</span> is: <span style="font-style: italic;">h</span> &lt;= <span style="font-style: italic;">i</span> &lt;= </big><big> 2<sup><span style="font-style: italic;">h</span></sup> <span style="font-style: italic;">-</span> 1</big>
</li>
  <li>
<big>The total number of nodes <span style="font-style: italic;">n</span>
in T is: 2</big><big><span style="font-style: italic;">h</span> + 1
&lt;= <span style="font-style: italic;">n</span> &lt;= </big><big> 2<sup><span style="font-style: italic;">h+</span>1</sup> <span style="font-style: italic;">-</span> 1</big>
</li>
  <li><big>The height <span style="font-style: italic;">h</span> of T
is: log(<span style="font-style: italic;">n</span> + 1) <span style="font-style: italic;">-</span> 1 &lt;= <span style="font-style: italic;">h</span> &lt;= (<span style="font-style: italic;">n -</span> 1)/2</big></li>
</ol>
<big><span style="font-weight: bold;">Proposition 6.10:</span> In a
proper binary tree  <span style="font-style: italic;">T</span>,
the number of external nodes <span style="font-style: italic;">e</span>
is 1 more than the number of internal nodes <span style="font-style: italic;">i</span>, i.e. <span style="font-style: italic;">e</span> = <span style="font-style: italic;">i</span> + 1.<br>
<br>
</big><big><a href="Trees-slides.pdf">Trees.pdf</a>  11</big><br>
<h4 style="font-weight: bold;"><big> 6.3.4 Traversals of a Binary Tree</big></h4>
<big><span style="font-weight: bold;">Preorder Traversal of a Binary
Tree</span></big><br>
<blockquote>
  <pre><big><font color="#a000a0">void</font> <font color="#000000">binaryPreorderPrint</font>(<font color="#a000a0">const</font> Tree&amp; T, <font color="#a000a0">const</font> Position&amp; v) <br>{ cout &lt;&lt; v.<font color="#000000">element</font>();		<font color="#0000ff">// print element</font><br>  <font color="#00a000">if</font> (isInternal(v))		<font color="#0000ff">// visit children</font><br>  {  cout &lt;&lt; <font color="#0000ff">" "</font>;<br>     <font color="#000000">binaryPreorderPrint</font>(T, T.leftChild(v));<br><font color="#000000">     binaryPreorderPrint</font>(T, T.rightChild(v));<br>  }<br>}</big></pre>
</blockquote>
<big><span style="font-weight: bold;">Postorder Traversal of a Binary
Tree</span><br>
</big>
<blockquote>
  <pre><font color="#a000a0" size="+1">void</font><font size="+1"> </font><font color="#000000" size="+1">binaryPostorderPrint</font><font size="+1">(</font><font color="#a000a0" size="+1">const</font><font size="+1"> Tree&amp; T, </font><font color="#a000a0" size="+1">const</font><font size="+1"> Position&amp; v) <br>{ </font><font color="#00a000" size="+1">if</font><font size="+1"> (isInternal(v)) </font><font color="#0000ff" size="+1">   // visit children</font><font size="+1"><br>  { cout &lt;&lt; </font><font color="#0000ff" size="+1">" "</font><font size="+1">;<br> </font><font color="#000000" size="+1">   binaryPostorderPrint</font><font size="+1">(T, T.leftChild(v));<br></font><font color="#000000" size="+1">    binaryPostorderPrint</font><font size="+1">(T, T.rightChild(v));<br>  }<br></font><font size="+1">  cout &lt;&lt; v.</font><font color="#000000" size="+1">element</font><font size="+1">(); </font><font color="#0000ff" size="+1">// print element</font><br><font size="+1">}</font></pre>
</blockquote>
<big>
<span style="font-weight: bold;">Evaluating an Arithmetic
Expression<br>
</span></big><big><a href="Trees-slides.pdf">Trees.pdf</a>  15<br>
<span style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span>) time algorithm<br>
</big><big><span style="font-weight: bold;"><br style="font-weight: bold;">
</span><span style="font-weight: bold;">Inorder Traversal of a Binary
Tree<br>
</span></big><big><a href="Trees-slides.pdf">Trees.pdf</a>  13<br>
</big>
<blockquote>
  <pre><font color="#a000a0" size="+1">void</font><font size="+1"> </font><font color="#000000" size="+1">binaryInorderPrint</font><font size="+1">(</font><font color="#a000a0" size="+1">const</font><font size="+1"> Tree&amp; T, </font><font color="#a000a0" size="+1">const</font><font size="+1"> Position&amp; v) <br>{ </font><font color="#00a000" size="+1">if</font><font size="+1"> (isInternal(v)) </font><font color="#0000ff" size="+1">       // visit left child</font><font size="+1"><br>  </font><font size="+1"> </font><font color="#000000" size="+1">  binaryInorderPrint</font><font size="+1">(T, T.leftChild(v));<br></font><font size="+1">  cout &lt;&lt; v.</font><font color="#000000" size="+1">element</font><font size="+1">(); </font><font color="#0000ff" size="+1">     // print element<br></font><font color="#00a000" size="+1">  if</font><font size="+1"> (isInternal(v)) </font><font color="#0000ff" size="+1">       // visit right child</font><br><font color="#000000" size="+1">     binaryInorderPrint</font><font size="+1">(T, T.rightChild(v));</font><br><font size="+1">}</font></pre>
</blockquote>
<big>Visit "left to right"</big><br>
<big><br style="font-weight: bold;">
</big><big><span style="font-weight: bold;"></span><span style="font-weight: bold;">Binary Search Trees<br>
    Binary serch tree </span>is a binary tree so that
each internal node <span style="font-style: italic;">v</span> stores
an element <span style="font-style: italic;">e</span>, such that:<br>
</big>
<ul>
  <li><big>the elements stored in the<span style="font-style: italic;">
left</span> subtree of <span style="font-style: italic;">v</span> are <span style="font-style: italic;">less</span> than or equal to <span style="font-style: italic;">e</span>, and </big></li>
  <li><big>the elements stored in the <span style="font-style: italic;">right</span>
subtree of <span style="font-style: italic;">v</span> are <span style="font-style: italic;">greater</span> than or equal to <span style="font-style: italic;">e</span>.</big></li>
</ul>
<blockquote>
  <pre><span style="font-family: mon;"></span><font color="#000000" size="+1">Position searchBinaryTree</font><font size="+1">(</font><font color="#a000a0" size="+1">const</font><font size="+1"> Tree&amp; T, </font><font color="#a000a0" size="+1">const</font><font size="+1"> Position&amp; v, </font><font color="#a000a0" size="+1">const<span style="color: rgb(0, 0, 0);"> Object&amp; e</span></font><font size="+1">)<br>{ </font><font color="#00a000" size="+1">if</font><font size="+1"> (isInternal(v))</font><font color="#000000" size="+1"></font><font size="+1"><br></font><font size="+1">    </font><font color="#00a000" size="+1">if</font><font size="+1"> (v.element() == e) </font><font color="#00a000" size="+1">return</font><font size="+1"> v;</font><font size="+1"> </font><font color="#0000ff" size="+1">                // found!<br>    </font><font color="#00a000" size="+1">else if</font><font size="+1"> (v.element() &lt; e)</font><font color="#000000" size="+1"><br>         searchBinaryTree(T, T.leftChild(v), e); </font><font color="#00a000" size="+1"><font color="#0000ff">   // search left subtree</font></font><font color="#00a000" size="+1"><font color="#000000" size="+1"><br></font>    else </font><font color="#000000" size="+1">searchBinaryTree(T, T.rightChild(v), e);</font><font color="#0000ff" size="+1">   // serch right subtree</font><br><font color="#000000" size="+1">  </font><font color="#00a000" size="+1">else return ...                                   <span style="color: rgb(51, 51, 255);">// not found!</span></font><br><font size="+1">}</font></pre>
</blockquote>
<big>The time for searching is a binary tree <span style="font-style: italic;">T</span> proportional to the height of <span style="font-style: italic;">T</span>, i.e. <span style="font-style: italic;">&gt;= O</span>(log <span style="font-style: italic;">n</span>) and &lt;= <span style="font-family: symbol;">Omega</span>(<span style="font-style: italic;">n</span>)<br>
<span style="font-weight: bold;"></span><span style="font-weight: bold;"><br style="font-weight: bold;">
</span><span style="font-weight: bold;">A Unified Tree Traversal
Framework<br>
<br style="font-weight: bold;">
</span><span style="font-weight: bold;">The Euler Tour Traversal of a
Binary Tree<br>
</span></big><big><a href="Trees-slides.pdf">Trees.pdf</a>  16<br>
</big>??????<br>
<h4><big><span style="font-weight: bold;"> 6.3.5 The Template Function
Pattern</span></big></h4>
<big><span style="font-weight: bold;">Euler Tour with the Template
Function Pattern</span><br>
<br>
<span style="font-weight: bold;">Template Function Examples</span><br>
<br>
<span style="font-weight: bold;">C++ Implementation</span><br>
<a href="6.22_EulerTour.h-TraversalResult.html">html-6.22</a>
(EulerTour-TraversalResult)<br>
<a href="6.23_EulerTour.h-EulerTour1.html">html-6.23</a> (EulerTour1)<br>
<a href="6.24_EulerTour.h-EulerTour2.html">html-6.24</a> (EulerTour2)<br>
<a href="6.25_EvaluateExpressionTour.h-EvaluateExpressionTour.html">html-6.25</a>
(EvaluateExpressionTour)<br>
<a href="6.26_PrintExpressionTour.h-PrintExpressionTour.html">html-6.26</a>
(PrintExpressionTour)<br>
</big>
<hr style="width: 100%; height: 2px;">
<h3> 6.4 Data Structures for Representing Trees</h3>
<h4><big><span style="font-weight: bold;"> 6.4.1 A Vector-Based
Structure for
Binary Trees</span><span style="font-weight: bold;"></span></big></h4>
<h4><big><span style="font-weight: bold;"></span></big></h4>
<h4><big><span style="font-weight: bold;">6.4.2 A Linked Structure for
Binary Trees</span></big></h4>
<big><a href="Trees-slides.pdf">Trees.pdf</a>  20<br>
<br>
</big><big><span style="font-weight: bold;">Nodes and Positions in a
Binary Tree</span><br>
<a href="6.27_LinkedBinaryTree.h-Node.html">html-6.27</a> (Node)<br>
<a href="6.28_LinkedBinaryTree.h-Position.html">html-6.28</a> (Position)<br>
<br>
<span style="font-weight: bold;">Binary Tree Update Functions</span><br>
<a href="6.29_LinkedBinaryTree.h-LinkedBinaryTree1.html">html-6.29</a>
(LinkedBinaryTree1)<br>
<a href="6.30_LinkedBinaryTree.h-LinkedBinaryTree2.html">html-6.30</a>
(LinkedBinartTree2)<br>
<br>
</big><a href="LinkedBinaryTree.cpp"><big>LinkedBinartTree.cpp</big></a><br>
<big><br>
<span style="font-weight: bold;">Copying a Binary Tree</span><br>
</big>
<h4><big><span style="font-weight: bold;">6.4.3 A Linked Structure for
General
Trees</span></big></h4>
<big><a href="Trees-slides.pdf">Trees.pdf</a>  19</big><br>
<br>
<h4><big><span style="font-weight: bold;">6.4.4 Representing General
Trees with Binary Trees</span></big></h4>
<br>
<br>
<h4><span style="font-weight: bold;"></span></h4>
<hr style="width: 100%; height: 2px;">
<br>
<br>
</body>
</html>
