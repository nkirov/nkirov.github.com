/* Политическа сила   uni00.cpp
Всички важне решения в Eвропейския съюз се вземат чрез да-не
гласуване на дадено предложение, като участващите в съюза държави имат
различен брой гласове.
Ето разпределението на гласовете по държави:
Франция, Германия, Италия и Англия - по 10 гласа,
Испания - 8, 
Белгия, Холандия, Португалия и Гърция - 5,
Австрия и Швеция - 4,
Дания, Ирландия и Финландия - 3,
Люксембург - 2 гласа.
Предложение се приема при събрани 62 от общо 87 гласа.

Една мярка са политическата сила на една държава в съюза е
индексът на Банзаф.
Нека p е дадена държава. Обща политическа сила O(p) на p се
нарича броя на коалициите C, изпълняващи следните 3 условия:
1. p е член на коалиция C;
2. C е печеливша коалиция (събира необходимите брой гласове за приемане на
дадено предложение);
3. Когато p излезе от C, получената коалиция е губеща (не е печеливша).
Индекс на Банзаф B(p) за държавата p се пресмята по формулата:
B(p) = O(p)/s, където s е сумата от общата политическа сила на всички
участници в съюза.
Да се напише програма за пресмятане на индекса на Банзаф.

Вход - файл uni.in:
Първият ред от един пример съдържа две цели числа - броя на държавите N в съюза
(1<N<32) и необходимия брой гласове V за вземане на решение.
Следващите N цели числа са гласовете на участниците в съюза.
Във файла се съдържат много примери, като последно число във файла е стойност
0 за N.

Изход - файл uni<номер на отбор>.out:
За всеки пример се извеждат N цели числа - индекса на Банзаф в проценти за
участниците в съюза (закръглен да цяло число). Между примерите се оставя
празен ред.

Примерен вход:
15 62
10 10 10 10 8 5 5 5 5 4 4 3 3 3 2
2 50
49 51
0
Примерен изход:
11
11
11
11
9
6
6
6
6
5
5
4
4
4
2

0
100

*/

#include <iostream>
#include <fstream>
using namespace std;

typedef unsigned long lint;
lint N, NN, SUM;
int A[100], B[100]={0};

lint two_p(int n)
{ lint ip=1;
  for (int i=1; i<=n; i++) ip*=2;
  return ip;
}

void count()
{
 lint i, j;
 for(i=1; i<NN; i++)
 {
  int sum=0;
  for(j=0; j<N; j++) if (two_p(j) & i) sum+=A[j];
  if (sum>=SUM)
  {
   for(j=0; j<N; j++) if (two_p(j) & i)
   {
    lint k, sub_i=(~two_p(j) & i);
    int sum=0;
    for(k=0; k<N; k++) if (two_p(k) & sub_i) sum+=A[k];
    if (sum<SUM)B[j]++;
   }
  }
 }
}

int main()
{
 ifstream fin("uni.in");
 ofstream fout("uni00.out");
 fin >> N;
 while (N>0)
 {
  fin >> SUM;
  NN=two_p(N);
  for (int i=0; i<N; i++)
  {
   fin >> A[i]; B[i]=0;
  }
  count();
  int sum=0;
  for (int i=0; i<N; i++) sum+=B[i];
  for (int i=0; i<N; i++)
  {
   double r = static_cast<double>(B[i])/sum*100;
   fout << static_cast<int>(r+0.5) << "\n";
  }
  fout << "\n";
  fin >> N;
 }
 return 0;
}
