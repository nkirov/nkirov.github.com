<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=windows-1251">
  <meta name="Author" content="Nikolay Kirov">
  <meta name="GENERATOR"
 content="Mozilla/4.75 [en] (Win98; U) [Netscape]">
  <title>l04</title>
</head>
<body>
<h3>5. Оценка и сложност на алгоритми [1.4]</h3>
&nbsp;&nbsp;&nbsp; Три главни свойства на
компютърен алгоритъм:
<li>простота и елегантност;</li>
<li> коректност;</li>
<li> бързодействие.</li>
<br>
&nbsp;&nbsp;&nbsp; Нека разгледаме следния
програмен
фрагмент:
<p><b><tt><font color="#006600">n = 100;</font></tt></b>
<br>
<b><tt><font color="#006600">sum = 0;</font></tt></b>
<br>
<b><tt><font color="#006600">for (i=0; i&lt;n; i++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;for (j=0; j&lt;n; j++) sum++;</font></tt></b>
<br>
&nbsp;
<table cellpadding="6" cols="2" width="100%">
  <tbody>
    <tr>
      <td valign="top">Колко бързо ще работи
горната програма,
т.е. какви са критериите по-които се определя бързината й? Това, което
можем да направим експериментално е да проверим за колко време ще се
изпълни
и ще завърши работата си. За да изследваме по-общо нейното поведение е
възможно да я изпълним за други стойности на <span
 style="font-style: italic;">n.</span> <br>
      <br>
Резултатите
от последното са обобщени в следната таблица:</td>
      <td>
      <center>
      <table border="1" cellpadding="6" cellspacing="0">
        <tbody>
          <tr>
            <td>Размер на входа (<span style="font-style: italic;">n</span>)
            <br>
            <span style="font-style: italic;"></span></td>
            <td>Време за изпълнение (сек).</td>
          </tr>
          <tr>
            <td>10</td>
            <td>10<sup>-6</sup></td>
          </tr>
          <tr>
            <td>100</td>
            <td>10<sup>-4</sup></td>
          </tr>
          <tr>
            <td>1000</td>
            <td>0.01</td>
          </tr>
          <tr>
            <td>10<sup>4</sup></td>
            <td>1.071</td>
          </tr>
          <tr>
            <td>10<sup>6</sup></td>
            <td>106.5</td>
          </tr>
          <tr>
            <td>10<sup>8</sup></td>
            <td>10663.6</td>
          </tr>
        </tbody>
      </table>
      </center>
      </td>
    </tr>
  </tbody>
</table>
От таблицата се вижда, че когато увеличаваме <span
 style="font-style: italic;">n</span><span style="font-style: italic;">
</span>10 пъти, времето за изпълнение се
увеличава 100 пъти.
<br>
Времето за изпълнение е пророрционално на&nbsp; <i>f
</i>(<i>n</i>)<i> =
c</i><sub>1</sub><i>n</i><sup>2 </sup>+ <i>c</i><sub>2</sub><i>n</i>+
<i>c</i><sub>3</sub>,
където <i>c</i><sub>1</sub>, <i>c</i><sub>2</sub>,
<i>c</i><sub>3</sub>
са константи, които могат лесно да се определят от дадената част от
програмата.
<br>
&nbsp;
<table border="0" cellpadding="6" cols="2" width="100%">
  <tbody>
    <tr>
      <td valign="top">Сравняване на двете
функции <i>f </i>(<i>n</i>)<i>= </i>2<i>n</i><sup>2 </sup>и <i>g</i>(<i>n</i>)<i>=
      </i>200<i>n</i>,
които показват времето за изпълнение на два дадени алгоритъма А<sub>1</sub>
и A<sub>2</sub>, в зависимост от <i>n</i>.&nbsp; <br>
&nbsp; <br>
&nbsp;
      <p>Асимптотично алгоритъмът A<sub>2</sub> е по-бърз и неговата
сложност
е линейна, докато тази на A<sub>1</sub> е квадратична.</p>
      </td>
      <td>
      <center>
      <table border="1" cellpadding="6" cellspacing="0">
        <tbody>
          <tr>
            <td><i><font color="#000000">n</font></i></td>
            <td><font color="#000000"><i>f </i>(<i>n</i>)</font></td>
            <td><font color="#000000"><i>g</i>(<i>n</i>)</font></td>
          </tr>
          <tr>
            <td>1</td>
            <td>2</td>
            <td>200</td>
          </tr>
          <tr>
            <td>10</td>
            <td>200</td>
            <td>2000</td>
          </tr>
          <tr>
            <td>100</td>
            <td>2.10<sup>4</sup></td>
            <td>2.10<sup>4</sup></td>
          </tr>
          <tr>
            <td>1000</td>
            <td>2.10<sup>6</sup></td>
            <td>2.10<sup>5</sup></td>
          </tr>
          <tr>
            <td>10<sup>4</sup></td>
            <td>2.10<sup>8</sup></td>
            <td>2.10<sup>6</sup></td>
          </tr>
          <tr>
            <td>10<sup>6</sup></td>
            <td>2.10<sup>12</sup></td>
            <td>2.10<sup>8</sup></td>
          </tr>
        </tbody>
      </table>
      </center>
      </td>
    </tr>
  </tbody>
</table>
</p>
<h4>Размер на входните данни</h4>
<p>&nbsp;&nbsp;&nbsp; Нека е дадена задача, в
която
размерът на входните данни е определен от дадено цяло число <i>n</i>.
Почти
всички задачи, които ще разглеждаме, притежават това свойство. Ще
поясним
последното като разгледаме няколко примера:
</p>
<p><font style="font-weight: bold;">Пример 1.</font><span
 style="font-weight: bold;">
</span><br>
Да се сортира масив с <i>n</i> елемента.
<br>
Размерът на входните данни се определя от броя
<i>n
</i>на
елементите на масива .
</p>
<p><font style="font-weight: bold;">Пример 2.</font><span
 style="font-weight: bold;">
</span><br>
Да се намери най-големият общ делител на <i>a</i>
и <i>b</i>.
<br>
В този пример размерът на входните данни се
определя
от броя на двоичните цифри (битовете) на по-голямото от числата <i>a</i>
и <i>b</i>.
</p>
<p><font style="font-weight: bold;">Пример 3.</font><span
 style="font-weight: bold;">
</span><br>
Да се намери покриващо дърво на граф.
<br>
В този случай характеризираме размера на входа
с две числа: брой на върховете и брой на ребрата.
</p>
<h4>Асимптотична нотация</h4>
<p>&nbsp;&nbsp;&nbsp; Когато се интересуваме от
сложността
на алгоритъм най-често се интересуваме как ще работи при достатъчно
голям
размер <span style="font-style: italic;">n</span> на входните данни.
При формалното оценяване на сложността на алгоритмите
ще се интересуваме от поведението им при <i>n</i> клонящо към
безкрайност.
</p>
<p>1.<i> O</i>(<i>F</i>) определя множеството от
всички функции&nbsp; <i>f</i>, които нарастват <b>не</b> по-бързо от <i>F</i>,
т.е. съществува константа <i>c </i>&gt; 0 такава, че <i>f </i>(<i>n</i>)
&lt;=
<i>cF</i>(<i>n</i>),
за всички достатъчно големи стойности на
<i>n.</i>
</p>
<p>2. <i><font face="Symbol">Q </font></i>(<i>F</i>)
определя множеството от всички функции <i>f</i>, които нарастват
толкова
бързо, колкото и <i>F</i> (с точност до константен множител), т.е.
съществуват
константи <i>c</i><sub>1</sub><i> </i>&gt; 0 и <i>c</i><sub>2</sub><i>
</i>&gt;
0 такава, че <i>c</i><sub>1</sub><i>F</i>(<i>n</i>) &lt;=&nbsp; <i>f </i>(<i>n</i>)
&lt;= <i>c</i><sub>2</sub><i>F</i>(<i>n</i>), за всички достатъчно
големи
стойности на
<i>n.</i>
</p>
<p>3. <i><font face="Symbol">W </font></i>(<i>F</i>)
определя
множеството от всички функции <i>f</i>, които нарастват <b>не</b>
по-бавно
от <i>F</i>, т.е. съществува константа <i>c </i>&gt; 0 такава, че
<i>f </i>(<i>n</i>)
&gt;= <i>cF</i>(<i>n</i>), за всички достатъчно големи стойности на
<i>n.</i>
</p>
<p style="font-weight: bold;"><i>O</i>(<i>F</i>):
Свойства и примери
</p>
<p>Нотацията <i>О</i>(<i>F</i>) е най-често
използваната
при оценка на сложност на алгоритми и програми.
<br>
По-важни свойства на <i>O</i>(<i>F</i>) (с ~ тук
означаваме принадлежност):
</p>
<li>рефлексивност: <i>f</i> <span style="font-family: symbol;">~</span><i>
О</i>( <i>f </i>);</li>
<li> транзитивност: ако <i>f</i> ~<i> О</i>(<i>g</i>),<i>
g</i> <font face="Symbol">~ </font><i>О</i>(<i>h</i>), то&nbsp; <i>f</i><span
 style="font-family: symbol;"> ~</span> <i>О</i>(<i>h</i>);</li>
<li> транспонирана симетрия:&nbsp; ако <i>f</i>&nbsp; <font
 face="Symbol">~ <i>W </i></font>(<i>g</i>),
то <i>g</i> <font face="Symbol">~ </font><i>O</i>( <i>f </i>) и
обратно;</li>
<li> константите могат да бъдат игнорирани: за
всяко <i>k
&gt; </i>0, <i>kF</i><span style="font-family: symbol;"> ~ </span><i>О</i>(<i>F</i>);</li>
<li> <i>n</i>, повдигнато в по-висока степен,
нараства
по-бързо: <i>n<sup>r</sup></i><span style="font-family: symbol;">~ </span><i>О</i>(<i>n<sup>s</sup></i>),
за 0 &lt; <i>r</i> &lt; <i>s</i>.</li>
<li> нарастването на сума от функции се определя
от
най-бързо
нарастващата от тях: <i>f + g</i> ~ max(<i>O</i>( <i>f </i>), <i>O</i>(<i>g</i>));</li>
<li> ако <i>f</i>(<i>n</i>) е полином от степен <i>d</i>,
то <i>f</i><font face="Symbol"> ~ </font><i>О</i>(<i>n<sup>d</sup></i>);</li>
<li> ако <i>f</i> нараства по-бързо от <i>g</i>,
а <i>g</i>
нараства по-бързо от <i>h</i>, то следва, че <i>f</i> нараства
по-бързо
от <i>h.</i></li>
<p style="font-weight: bold;">Нарастване на
най-често използваните функции:
</p>
<center>
<table border="1" cellpadding="4" cellspacing="0" cols="6" width="59%">
  <tbody>
    <tr>
      <td>
      <center>Функция / <span style="font-style: italic;">n</span><br>
      </center>
      </td>
      <td>
      <center>1</center>
      </td>
      <td>
      <center>2</center>
      </td>
      <td>
      <center>10</center>
      </td>
      <td>
      <center>100</center>
      </td>
      <td>
      <center>1000</center>
      </td>
    </tr>
    <tr>
      <td>
      <center>5</center>
      </td>
      <td>
      <center>5</center>
      </td>
      <td>
      <center>5</center>
      </td>
      <td>
      <center>5</center>
      </td>
      <td>
      <center>5</center>
      </td>
      <td>
      <center>5</center>
      </td>
    </tr>
    <tr>
      <td>
      <center>log <i>n</i></center>
      </td>
      <td>
      <center>0</center>
      </td>
      <td>
      <center>1</center>
      </td>
      <td>
      <center>3.32</center>
      </td>
      <td>
      <center>6.64</center>
      </td>
      <td>
      <center>9.96</center>
      </td>
    </tr>
    <tr>
      <td>
      <center><i>n</i></center>
      </td>
      <td>
      <center>1</center>
      </td>
      <td>
      <center>2</center>
      </td>
      <td>
      <center>10</center>
      </td>
      <td>
      <center>100</center>
      </td>
      <td>
      <center>1000</center>
      </td>
    </tr>
    <tr>
      <td>
      <center><i>n</i> log <i>n</i></center>
      </td>
      <td>
      <center>0</center>
      </td>
      <td>
      <center>2</center>
      </td>
      <td>
      <center>33.2</center>
      </td>
      <td>
      <center>664</center>
      </td>
      <td>
      <center>9996</center>
      </td>
    </tr>
    <tr>
      <td>
      <center><i>n</i><sup>2</sup></center>
      </td>
      <td>
      <center>1</center>
      </td>
      <td>
      <center>4</center>
      </td>
      <td>
      <center>100</center>
      </td>
      <td>
      <center>10<sup>4</sup></center>
      </td>
      <td>
      <center>10<sup>6</sup></center>
      </td>
    </tr>
    <tr>
      <td>
      <center><i>n</i><sup>3</sup></center>
      </td>
      <td>
      <center>1</center>
      </td>
      <td>
      <center>8</center>
      </td>
      <td>
      <center>1000</center>
      </td>
      <td>
      <center>10<sup>6</sup></center>
      </td>
      <td>
      <center>10<sup>9</sup></center>
      </td>
    </tr>
    <tr>
      <td>
      <center>2<i><sup>n</sup></i></center>
      </td>
      <td>
      <center>2</center>
      </td>
      <td>
      <center>4</center>
      </td>
      <td>
      <center>1024</center>
      </td>
      <td>
      <center>10<sup>30</sup></center>
      </td>
      <td>
      <center>10<sup>300</sup></center>
      </td>
    </tr>
    <tr>
      <td>
      <center><i>n</i>!</center>
      </td>
      <td>
      <center>1</center>
      </td>
      <td>
      <center>2</center>
      </td>
      <td>
      <center>3628800</center>
      </td>
      <td>
      <center>10<sup>157</sup></center>
      </td>
      <td>
      <center>10<sup>2567</sup></center>
      </td>
    </tr>
    <tr>
      <td>
      <center><i>n<sup>n</sup></i></center>
      </td>
      <td>
      <center>1</center>
      </td>
      <td>
      <center>4</center>
      </td>
      <td>
      <center>10<sup>10</sup></center>
      </td>
      <td>
      <center>10<sup>200</sup></center>
      </td>
      <td>
      <center>10<sup>3000</sup></center>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p>Определяне на сложност на алгоритъм:
<br>
- елементарна операция - не зависи от размера
на обработваните данни { <i>O</i>(1) };
<br>
- последователност от оператори - определя се
от асимтотично най-бавния { <i>f + g</i> <font face="Symbol">О</font>
max(<i>O</i>(
<i>f
</i>),
<i>O</i>(<i>g</i>)) };
<br>
- композиция на оператори - произведение от
сложностите
{ <i>f&nbsp; g</i> <font face="Symbol">О</font> <i>O</i>(
<i>f g</i>) };
<br>
- условни оператори - определя се от асимтотично
най-бавния измежду условието и различните случаи;
<br>
- цикли, вложени цикли - { <i>O</i>(<i>n</i>),
<i>O</i>(<i>n<sup>p</sup></i>) }.
</p>
<p><font style="font-weight: bold;">Примери:</font><span
 style="font-weight: bold;">
</span><br>
<b><tt><font color="#000099">/* Брой цифри на число */</font></tt></b>
<br>
<b><tt><font color="#000099">// digits.c</font></tt></b>
<br>
<b><tt><font color="#000099">#include &lt;stdio.h&gt;</font></tt></b>
<br>
<b><tt><font color="#000099">unsigned n=9800;</font></tt></b>
<br>
<b><tt><font color="#000099">int main(void)</font></tt></b>
<br>
<b><tt><font color="#000099">{</font></tt></b>&nbsp;
<b><tt><font color="#000099">unsigned d, m=n;</font></tt></b>
<br>
<b><tt><font color="#000099">&nbsp; for (d=0; m&gt;0; d++, m/=10);</font></tt></b>
<br>
<b><tt><font color="#000099">&nbsp; printf("numb of dig %u is
%u\n",n,d);</font></tt></b>
<br>
<b><tt><font color="#000099">&nbsp; return 0;</font></tt></b>
<br>
<b><tt><font color="#000099">}</font></tt></b>
</p>
<p><b><tt><font color="#000099">/* Сума от цифрите на число */</font></tt></b>
<br>
<b><tt><font color="#000099">// sdigits.c</font></tt></b>
<br>
<b><tt><font color="#000099">#include &lt;stdio.h&gt;</font></tt></b>
<br>
<b><tt><font color="#000099">unsigned n=9800;</font></tt></b>
<br>
<b><tt><font color="#000099">int main(void)</font></tt></b>
<br>
<b><tt><font color="#000099">{</font></tt></b>&nbsp;
<b><tt><font color="#000099">unsigned m, s=0;</font></tt></b>
<br>
<b><tt><font color="#000099">&nbsp; for (m=n; m&gt;0; s+=m%10, m/=10);</font></tt></b>
<br>
<b><tt><font color="#000099">&nbsp; printf("sum of digits=%u\n", s);</font></tt></b>
<br>
<b><tt><font color="#000099">&nbsp; return 0;</font></tt></b>
<br>
<b><tt><font color="#000099">}</font></tt></b>
</p>
<p><b><tt><font color="#000099">/* Брой цифри на число */</font></tt></b>
<br>
<b><tt><font color="#000099">// ldigit.c</font></tt></b>
<br>
<b><tt><font color="#000099">#include &lt;stdio.h&gt;</font></tt></b>
<br>
<b><tt><font color="#000099">#include &lt;math.h&gt;</font></tt></b>
<br>
<b><tt><font color="#000099">unsigned n=9800;</font></tt></b>
<br>
<b><tt><font color="#000099">int main(void)</font></tt></b>
<br>
<b><tt><font color="#000099">{</font></tt></b>&nbsp;
<b><tt><font color="#000099">printf("int(1+log10 (%u)) = %d\n",
n, (int)(1+log10(n)));</font></tt></b>
<br>
<b><tt><font color="#000099">&nbsp; return 0;</font></tt></b>
<br>
<b><tt><font color="#000099">}</font></tt></b>
</p>
<p>Оценка на сложността на "Решето на Ератостен"
и
алгоритъма за намиране последователно на простите числа.
<br>
Оценка на сложността на следните цикли:
<br>
<b><tt><font color="#000099">/</font><font color="#006600">/ 1</font></tt></b>
<br>
<b><tt><font color="#006600">for (i=0; i&lt;n; i++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;for (j=0; j&lt;n, j==i; j++, sum++);</font></tt></b>
<br>
<b><tt><font color="#006600">// 2</font></tt></b>
<br>
<b><tt><font color="#006600">for (i=0; i&lt;n; i++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;for (j=0; j&lt;n; j++) if
(a[i]==a[j])
return;</font></tt></b>
<br>
<b><tt><font color="#006600">// 3</font></tt></b>
<br>
<b><tt><font color="#006600">for (i=0; i&lt;n; i++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;for (j=0; j&lt;n; j++) if
(a[i]!=a[j])
return;</font></tt></b>
<br>
<b><tt><font color="#006600">// 4</font></tt></b>
<br>
<b><tt><font color="#006600">for (i=0; i&lt;n; i++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;for (j=0; j&lt;n; j++) if
(a[i]==a[j])
return;</font></tt></b>
<br>
<b><tt><font color="#006600">// 5</font></tt></b>
<br>
<b><tt><font color="#006600">for (i=0; i&lt;n; i++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;for (j=0; j&lt;i; j++) sum++;</font></tt></b>
<br>
<b><tt><font color="#006600">// 6</font></tt></b>
<br>
<b><tt><font color="#006600">for (i=0; i&lt;n; i++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;for (j=0; j&lt;n*n; j++) sum++;</font></tt></b>
<br>
<b><tt><font color="#006600">// 7</font></tt></b>
<br>
<b><tt><font color="#006600">for (i=0; i&lt;n; i++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;for (j=0; j&lt;i*i; j++) sum++;</font></tt></b>
<br>
<b><tt><font color="#006600">// 8</font></tt></b>
<br>
<b><tt><font color="#006600">for (i=0; i&lt;n; i++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;for (j=0; j&lt;i*i; j++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;&nbsp; for (k=0; k&lt;j*j; k++)
sum++;</font></tt></b>
<br>
</p>
<hr style="width: 100%; height: 2px;"><span style="font-weight: bold;"></span>
<h4>Логаритмична сложност.
</h4>
<p>&nbsp;&nbsp;&nbsp; Да разгледаме цикъла:
<br>
<b><tt><font color="#006600">for (sum=0, i=0; i&lt;n; i+=2) sum++;</font></tt></b>
<br>
Променливата <b><tt>i</tt></b> приема стойности 1, 2, 4, ..., 2<i><sup>k</sup></i>,
...&nbsp; докато надмине <b><tt>n</tt></b>. Цикълът се изпълнява [log <i>n</i>]
пъти. Сложността е <i>O</i>(log <i>n</i>).
</p>
<p>&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">Изчисляване на
сложност при рекурсия.</span><br>
<span style="font-weight: bold;">Пример:</span> Двоично търсене -
рекурсивен алгоритъм.
<br>
&nbsp;&nbsp;&nbsp; Броим обръщенията към елементите на масива. В
рекурсивната функция
се разглежда средния елемент и се прави едно рекурсивно извикване с два
пъти по-малък масив. Следователно, ако <i>T</i>(<i>n</i>) е функцията,
която задава броя на обръщенията, то <i>T</i>(<i>n</i>) = <i>T</i>(<i>n/</i>2)
+ 1. От равенствата
<br>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
T</i>(<i>n</i>) = <i>T</i>(<i>n/</i>2) + 1 = <i>T</i>(<i>n/</i>4) + 2
=
<i>T</i>(<i>n/</i>8)
+ 3 = ... = <i>T</i>(<i>n/</i>2<i><sup>k</sup></i>) + <i>k</i>
<br>
получаваме за <i>n</i> = 2<i><sup>k</sup></i>, че&nbsp;<i> T</i>(<i>n</i>)
= <i>T</i>(1) + log <i>n</i>, т.е. сложността на алгоритъма е <i>O</i>(log
<i>n</i>).
</p>
<p>Характеристични уравнения [1.4.9]
<br>
Числа на Фибоначи
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>&nbsp; T</i>(<i>n</i>) = <i>T</i>(<i>n -
</i>2) + <i>T</i>(<i>n - </i>1)
</p>
Специални техники за анализ на алгоритми [1.4.10]
<br>
- Измерване на времето за работа
<br>
- Използване на барометър
<br>
- Амортизационен анализ - зависимост от входните данни
<br>
<br>
Най-добър случай, най-лош случай, обща сложност<br>
Проблеми при асимптотичната нотация [1.4.11]
<br>
<hr width="100%"><span style="font-weight: bold;">Задача.
</span>Hidden Password
<p>Input File: B.IN
<br>
Output File: standard output
<br>
</p>
<p>Some time the programmers have very strange ways to hide their
passwords.
See for example how Billy "Hacker" Geits hide his password. Billy
chooses
a string <i>S</i> composed of small Latin letters with length <i>L</i>.
Then he makes all <i>L - </i>1 one-letter left cyclic shifts of the
string
and takes as a password one prefix of the lexicographically first of
the
obtained strings (including <i>S</i>). For example let consider the
string
<b><tt>alabala</tt></b>. The cyclic one-letter left shifts (including
the
initial string) are:
</p>
<p>&nbsp;&nbsp;&nbsp; <b><tt>alabala</tt></b>
<br>
<b><tt>&nbsp; labalaa</tt></b>
<br>
<b><tt>&nbsp; abalaal</tt></b>
<br>
<b><tt>&nbsp; balaala</tt></b>
<br>
<b><tt>&nbsp; alaalab</tt></b>
<br>
<b><tt>&nbsp; laalaba</tt></b>
<br>
<b><tt>&nbsp; aalabal</tt></b>
</p>
<p>and lexicographically first of them is the string <span
 style="font-family: monospace; font-weight: bold;">aalabal</span>. The
first
letter of this string is in position 6 in the initial string (the
positions
in the string are counted from 0).
</p>
<p>Write a program that for given string <i>S</i> finds the start
position
of the smallest lexicographically one-letter left cyclic shift of this
string. If the smallest lexicographically left shift appears more than
once then the program have to output the smallest initial position.
</p>
<p>Your program has to be ready to solve more than one test case. The
first
line of the input file will contains only the number <i>T</i> of the
test
cases. Each of the following <i>T</i> lines will describe one test
case
– first the length <i>L</i> of the string (5 &lt; <i>L</i> &lt;
100000)
and then, separated by one space, the string <i>S</i> itself.
</p>
<p>The output file have to contain exactly <i>T</i> lines with a
single
number each – the initial position found by your program.
</p>
<p>EXAMPLE
</p>
<p>Input&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Output
<br>
<b><tt>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1</tt></b>
<br>
<b><tt>6
baabaa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
6</tt></b>
<br>
<b><tt>7 alabala</tt></b>
</p>
<hr width="100%">
</body>
</html>
