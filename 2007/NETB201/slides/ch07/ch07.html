<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Chapter 7</title>
</head>
<body>
<big> </big>
<h2>Chapter 7: Priority Queues</h2>
<big>A <span style="font-weight: bold;">priority queue</span> is an
ADT for storing a collection of prioritized
elements that supports <span style="font-style: italic;">arbitrary
element insertion</span> but supports <span style="font-style: italic;">removal
of elements in order of priority</span>; that is, the element with
first priority can be removed at any time.<br>
Examples: <br>
</big>
<ul>
  <li><big>Standby passenger for a fully booked flight - priority here
is measured in terms of the fare paid, frequent-flyer status, and
check-in time</big></li>
  <li><big>In any operating system, each process is assumed a priority
and the scheduler will always choose a process with higher priority
over one of lower priority.</big></li>
</ul>
<big>The priority is typically a numerical value - the smallest
numerical value should have first (highest) priority. <br>
<br>
<span style="font-weight: bold;">7.1.1 Keys,
Priorities, and Total Order Relations</span><br>
We define a <span style="font-weight: bold;">key </span>to be an
object that is assigned to an element as a <span
 style="font-style: italic;">specific</span> attribute for that element
and that can be used to <span style="font-style: italic;">identify</span>,<span
 style="font-style: italic;"> rank</span>, or <span
 style="font-style: italic;">weight </span>that element.<br>
<br>
<span style="font-weight: bold;">Comparing Keys with Total
Orders</span></big><br>
<big>[<a href="PriorityQueues-slides.pdf">PriorityQueues.pdf</a> 4]</big>
<ul>
  <li><big>Keys in a priority queue can be arbitrary objects on which
an order is defined</big></li>
  <li><big>Two distinct items in a priority queue can have the same key</big></li>
  <li><big>Mathematical concept of <span style="font-style: italic;">total
order</span> relation &#8804;</big></li>
  <ul>
    <li><big>Reflexive property: <span style="font-style: italic;">x &#8804;
x</span></big></li>
    <li><big>Antisymmetric property: <span style="font-style: italic;">x
&#8804; y </span>&#8743;<span style="font-style: italic;"> y &#8804; x </span>&#8658;<span
 style="font-style: italic;"> x = y</span></big></li>
    <li><big>Transitive property: <span style="font-style: italic;">x
&#8804; y </span>&#8743;<span style="font-style: italic;"> y &#8804; z </span>&#8658;<span
 style="font-style: italic;"> x &#8804; z</span></big></li>
  </ul>
</ul>
<big>[<a href="PriorityQueues-slides.pdf">PriorityQueues.pdf</a> 3]</big><br>
<ul>
  <li><big>A priority queue stores a collection of items </big></li>
  <li><big>An item is a pair <span style="font-family: monospace;">(k,e)</span></big></li>
  <li><big>Main methods of the Priority Queue ADT</big></li>
  <ul>
    <li><big><span style="font-family: monospace;">insertItem(k,e)</span>
inserts an item with key <span style="font-family: monospace;">k</span>
and element <span style="font-family: monospace;">e</span></big></li>
    <li><big><span style="font-family: monospace;">removeMin()</span>
removes the item with the smallest key</big></li>
  </ul>
  <li><big>Additional methods</big></li>
  <ul>
    <li><big><span style="font-family: monospace;">minKey()</span>
returns, but does not remove, the smallest
key of an item</big></li>
    <li><big><span style="font-family: monospace;">minElement()</span>
returns, but does not remove, the element of
an item with smallest key</big></li>
    <li><big><span style="font-family: monospace;">size()</span>, <span
 style="font-family: monospace;">isEmpty()</span></big></li>
  </ul>
  <li><big>Applications:</big></li>
  <ul>
    <li><big>Standby flyer's</big></li>
  </ul>
</ul>
<big>Example 7.1: Suppose a certain flight is fully booked an hour
prior to departure. Because of possibility of cancellations, the
airline maintains a priority queue of standby passengers hoping to get
a seat. The priority of each passenger is determined by the fare paid,
the frequent-flyer status, and the time when the passenger is inserted
into the priority queue. When a passenger requested to fly standby, the
associated passenger object is inserted into the priority queue with an
</big><big><span style="font-family: monospace;">insertItem</span></big><big>
operation. Shortly before the flight departure, if seats become
available (for example, due to last-minute cancellations), the airline
repeatedly removes, from the priority queue, a standby passenger with
first priority, using a combination of </big><big><span
 style="font-family: monospace;">minElement()</span> and </big><big><span
 style="font-family: monospace;">removeMin()</span> operations, and
lets this person board.&nbsp;</big>
<br>
<br>
<big><span style="font-weight: bold;">7.1.2 Sorting with a Priority
Queue</span></big><br>
<big>[<a href="PriorityQueues-slides.pdf">PriorityQueues.pdf</a>
7]<br>
</big>
<ul>
  <li><big>We can use a priority queue to sort a set of comparable
elements</big></li>
  <ol>
    <li><big>Insert the elements one by one with a series of <span
 style="font-family: monospace;">insertItem(e,e)</span>
operations</big></li>
    <li><big>Remove the elements in sorted order with a series of <span
 style="font-family: monospace;">removeMin()</span>
operations</big></li>
  </ol>
  <li><big>The running time of this sorting method depends on the
priority queue implementation</big></li>
</ul>
<br>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><big><span
 style="font-weight: bold;">Algorithm</span> <span
 style="font-family: monospace;">PriorityQueueSort</span>(<span
 style="font-style: italic;">S</span>,<span style="font-style: italic;">
P</span>):<br>
      <span style="font-weight: bold; font-style: italic;">Input:</span><span
 style="font-style: italic;"> </span>A sequence <span
 style="font-style: italic;">S</span> storing <span
 style="font-style: italic;">n</span> elements, on which a total
order relation is <br>
&nbsp;&nbsp;&nbsp; defined, and a priority queue <span
 style="font-style: italic;">P</span>, that compares keys using the
same total <br>
&nbsp;&nbsp;&nbsp; order relation<br>
      <span style="font-weight: bold; font-style: italic;">Output:</span><span
 style="font-style: italic;"> </span>The sequence <span
 style="font-style: italic;">S</span> sorted by the total order
relation<br>
      <span style="font-family: monospace;"><span
 style="font-weight: bold;">while</span>
!</span><span style="font-style: italic;">S</span><span
 style="font-family: monospace;">.isEmpty() <span
 style="font-weight: bold;">do</span></span><br>
&nbsp;&nbsp; <span style="font-style: italic;">e</span><span
 style="font-family: monospace;"> &lt;- </span><span
 style="font-style: italic;">S</span><span
 style="font-family: monospace;">.removeFirst()</span>&nbsp;&nbsp;
{remove an element <span style="font-family: monospace;">e</span> from
      <span style="font-family: monospace;"></span></big><big><span
 style="font-style: italic;">S</span><span
 style="font-family: monospace;"></span></big><big><span
 style="font-family: monospace;"></span>}<br>
&nbsp;&nbsp;&nbsp;<span style="font-family: monospace;"></span></big><big><span
 style="font-style: italic;">P</span></big><big><span
 style="font-family: monospace;">.insertItem(</span></big><big><span
 style="font-style: italic;">e</span></big><big><span
 style="font-family: monospace;">,</span></big><big><span
 style="font-style: italic;">e</span></big><big><span
 style="font-family: monospace;">)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{the key is the element itself}<br>
      <span style="font-family: monospace;"><span
 style="font-weight: bold;">while</span>
!</span></big><big><span style="font-style: italic;">P</span></big><big><span
 style="font-family: monospace;">.isEmpty() <span
 style="font-weight: bold;">do</span></span><br>
&nbsp;&nbsp;&nbsp;<span style="font-family: monospace;"></span></big><big><span
 style="font-style: italic;">e</span></big><big><span
 style="font-family: monospace;"> &lt;- </span></big><big><span
 style="font-style: italic;">P</span></big><big><span
 style="font-family: monospace;">.minElement()</span>&nbsp;&nbsp;&nbsp;
{get a smallest element from <span style="font-family: monospace;"></span></big><big><span
 style="font-style: italic;">P</span></big><big><span
 style="font-family: monospace;"></span></big><big><span
 style="font-family: monospace;"></span>}<br>
&nbsp;&nbsp;&nbsp;<span style="font-family: monospace;"></span></big><big><span
 style="font-style: italic;">P</span></big><big><span
 style="font-family: monospace;">.removeMin()&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{remove this element from <span style="font-family: monospace;"></span></big><big><span
 style="font-style: italic;">P</span></big><big><span
 style="font-family: monospace;"></span></big><big><span
 style="font-family: monospace;"></span>}<br>
&nbsp;&nbsp;&nbsp;<span style="font-family: monospace;"></span></big><big><span
 style="font-style: italic;">S</span><span
 style="font-family: monospace;"></span></big><big><span
 style="font-family: monospace;">.insertLast(</span></big><big><span
 style="font-style: italic;">e</span></big><big><span
 style="font-family: monospace;">)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{add the element at the end of <span style="font-family: monospace;"></span></big><big><span
 style="font-style: italic;">S</span><span
 style="font-family: monospace;"></span></big><big><span
 style="font-family: monospace;"></span>}</big></td>
    </tr>
  </tbody>
</table>
<ul>
  <li><big>The running time of the algorithm is determined by the
running times of
operations <span style="font-family: monospace;">insertItem(</span></big><big><span
 style="font-style: italic;">e</span></big><big><span
 style="font-family: monospace;">,</span></big><big><span
 style="font-style: italic;">e</span></big><big><span
 style="font-family: monospace;">)</span>,<span
 style="font-family: monospace;"> </span><span
 style="font-family: monospace;">minElement()</span>, and<span
 style="font-family: monospace;"> </span><span
 style="font-family: monospace;">removeMin()</span>, which do depend
how <span style="font-family: monospace;"></span></big><big><span
 style="font-style: italic;">P</span></big><big><span
 style="font-family: monospace;"></span> is implemented.</big></li>
  <li><big>Example 7.2:</big></li>
</ul>
<table style="width: 100%; text-align: left;" border="1" cellpadding="2"
 cellspacing="0">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><font size="+1">Operation<br>
      </font> </td>
      <td style="vertical-align: top;"><font size="+1">Output<br>
      </font> </td>
      <td style="vertical-align: top;"><font size="+1">Priority Queue<br>
      </font> </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">insertItem(5,A)<br>
      </font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">-<br>
      </font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">{(5,A)}<br>
      </font> </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">insertItem(9,C)</font></td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">-<br>
      </font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">{(5,A),(9,C)}<br>
      </font> </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">insertItem(3,B)</font></td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">-<br>
      </font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">{(3,B),(5,A),(9,C)}</font></td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">insertItem(7,D)</font></td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">-<br>
      </font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">{(3,B),(5,A),(7,D),(9,C)}</font></td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">minElement()<br>
      </font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">B<br>
      </font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">{(3,B),(5,A),(7,D),(9,C)}</font></td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">minKey()<br>
      </font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">3<br>
      </font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">{(3,B),(5,A),(7,D),(9,C)}</font></td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">removeMin()<br>
      </font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">-<br>
      </font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">{(5,A),(7,D),(9,C)}</font></td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">size()<br>
      </font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">3<br>
      </font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">{(5,A),(7,D),(9,C)}</font> </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">minElement()<br>
      </font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">A<br>
      </font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">{(5,A),(7,D),(9,C)}</font> </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">removeMin()<br>
      </font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">-<br>
      </font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">{(7,D),(9,C)}</font> </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">removeMin()</font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">-<br>
      </font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">{(9,C)}</font> </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">removeMin()</font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">-<br>
      </font> </td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">{}</font> </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">removeMin()</font></td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">ERROR<br>
      </font></td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">{}</font></td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">isEmpty()<br>
      </font></td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">true<br>
      </font></td>
      <td style="vertical-align: top; font-family: monospace;"><font
 size="+1">{}</font></td>
    </tr>
  </tbody>
</table>
<big><span style="font-weight: bold;"><br>
</span>There are still two important issues that we have left
undetermined to this point:<br>
</big>
<ul>
  <li><big>How do we keep track of the associations between
elements and their keys?</big></li>
  <li><big>How do we compare keys so as to determine a smallest
key?</big></li>
</ul>
<big style="font-weight: bold;">7.1.4 Compositions and Comparators</big><span
 style="font-weight: bold;">
<br>
<br>
</span><big><span style="font-weight: bold;">The Composition Pattern<br>
</span></big>
<ul>
  <li><big>The composition pattern defines a single object that is a
composition of other objects. </big></li>
  <li><big>A pair (<span style="font-style: italic;">k</span>,<span
 style="font-style: italic;">e</span>) is the simplest composition, for
it composes two objects, <span style="font-style: italic;">k</span>
and <span style="font-style: italic;">e</span>, into a single <span
 style="font-weight: bold;">pair</span> object.<span
 style="font-weight: bold;"></span></big></li>
</ul>
<big><span style="font-weight: bold;"></span><a
 href="7.2_ItemFragment.h-Item.html">html-7.2</a>
(Item)<br>
</big><br>
<big><span style="font-weight: bold;">The Comparator Pattern<br>
</span></big>
<ul>
  <li><big>A comparator encapsulates the action of comparing two
objects according to a given total order relation</big></li>
  <li><big>When the priority queue needs to compare two keys, it uses
its comparator</big></li>
  <li><big>A generic priority queue uses a comparator as a template
argument, to define the comparison function (&lt;, =, &gt;)</big></li>
  <li><big>Lexicographical less than operator:</big></li>
</ul>
<big>
<blockquote>
  <pre>bool operator&lt;(const Point&amp; p1, const Point&amp; p2)<br>{ if (p1.getX() == p2.getX()) return p1.getY() &lt; p2.getY();<br>  else return p1.getX() &lt; p1.getX();<br>}</pre>
</blockquote>
</big>
<ul>
  <li><big>The comparator is external to the keys being compared. Thus,
the same objects can be sorted in different ways by using different
comparators.</big></li>
  <li><big>Assume that <span style="font-family: monospace;">comp</span>
is a comparison class object. <span style="font-family: monospace;">comp</span>(<span
 style="font-style: italic;">a</span>,<span style="font-style: italic;">b</span>)
returns integer<span style="font-style: italic;"> i</span>, such that </big></li>
  <ul>
    <li><big><span style="font-style: italic;">i</span> &lt; 0 if <span
 style="font-style: italic;">a&nbsp; &lt; b,</span></big></li>
    <li><big><span style="font-style: italic;">i</span> = 0 if <span
 style="font-style: italic;">a = b</span>, and</big></li>
    <li><big><span style="font-style: italic;">i</span> &gt; 0 if <span
 style="font-style: italic;">a &gt; b.</span></big></li>
  </ul>
  <li><big>We use special comparator object, external to the keys, to
supply the comparison rules.</big><br>
  </li>
  <li><big>The approach that we will use is to overload "<span
 style="font-family: monospace;">()</span>" operator
(to
create so called function object).</big></li>
</ul>
<big>[<a href="PriorityQueues-slides.pdf">PriorityQueues.pdf</a>
5]</big><big><span style="font-weight: bold;"></span></big>
<br>
<ul>
  <li><big>Example: Compare two points in the plane lexicographically.</big></li>
</ul>
<big>
<blockquote>
  <pre>class LexCompare {<br>public:<br>   int <span
 style="color: rgb(0, 153, 0); font-weight: bold;">operator()</span>(Point a, Point b) {<br>   if (a.x &lt; b.x) return &#8211;1<br>   else if (a.x &gt; b.x) return +1<br><br>   else if (a.y &lt; b.y) return &#8211;1<br>   else if (a.y &gt; b.y) return +1<br>   else return 0;<br>   }<br>};<big><br></big></pre>
</blockquote>
</big>
<big><a href="7.3_LexCompare.h-compare.html">html-7.3</a>
(Compare)</big><br>
<big><span style="font-weight: bold;"><br>
Using Comparator Objects<br>
</span>[<a href="PriorityQueues-slides.pdf">PriorityQueues.pdf</a>
6]</big>
<ul>
  <li><big>To use the comparator, define an object of this type, and
invoke it
using its &#8220;()&#8221; operator:</big></li>
  <li><big>Example of usage:</big></li>
</ul>
<big>
<blockquote>
  <pre>Point p(2.3, 4.5);<br>Point q(1.7, 7.3);<br>LexCompare lexCompare;<br>if (lexCompare(p, q) &lt; 0) cout &lt;&lt; &#8220;p less than q&#8221;;<br>else if (lexCompare(p, q) == 0) cout &lt;&lt; &#8220;p equals q&#8221;;<br>else if (lexCompare(p, q) &gt; 0) cout &lt;&lt; &#8220;p greater than q&#8221;;<br></pre>
</blockquote>
</big>
<br>
<big><a href="7.4_LexExample.cpp-generic.html">html-7.4</a>
(Generic)</big><br>
<br>
<hr style="width: 100%; height: 2px;">
<h3 style="font-weight: bold;"> 7.2 Implementing a Priority Queue
with a Sequence</h3>
<big style="font-weight: bold;"> 7.2.1 Implementation with an Unsorted
Sequence</big>
<ul>
  <li><big>Add the new pair object <span style="font-style: italic;">p
    </span>=
(<span style="font-style: italic;">k</span>,<span
 style="font-style: italic;">e</span>) at the end of sequence <span
 style="font-style: italic;">S</span>, by executing function <span
 style="font-family: monospace;">insertLast(<span
 style="font-style: italic;">p</span>)</span> on <span
 style="font-style: italic;">S</span> - takes <span
 style="font-style: italic;">O</span>(1) time, independent of whether
the sequence is implemented using an array or a linked list.</big></li>
  <li><big>To perform operations </big><font size="+1"><span
 style="font-family: monospace;">minElement()</span></font><font
 size="+1">, </font><font size="+1"><span
 style="font-family: monospace;">minKey()</span></font><font size="+1">
or </font><font size="+1"><span style="font-family: monospace;">removeMin()</span></font><font
 size="+1"> on <span style="font-style: italic;">P</span>, we must
inspect all the elements of sequence <span style="font-style: italic;">S</span>
to find an element <span style="font-style: italic;">p</span> = (<span
 style="font-style: italic;">k</span>,<span style="font-style: italic;">e</span>)
of <span style="font-style: italic;">S</span> with minimal <span
 style="font-style: italic;">k</span> - takes <span
 style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span>)
time.</font></li>
</ul>
<big style="font-weight: bold;"> 7.2.2 Implementation with a Sorted
Sequence</big>
<ul>
  <li><big>We can implement functions </big><font size="+1"><span
 style="font-family: monospace;">minElement()</span></font><font
 size="+1">or </font><font size="+1"><span
 style="font-family: monospace;">minKey()</span></font><font size="+1">
on </font><font size="+1"><span style="font-style: italic;">P</span></font><font
 size="+1"><span style="font-family: monospace;"></span></font><font
 size="+1"> simply by
accessing the first element of the sequence with the </font><font
 size="+1"><span style="font-family: monospace;">first()</span></font><font
 size="+1"> function of </font><big><span style="font-style: italic;">S</span></big><font
 size="+1">. We
can implement </font><font size="+1"><span
 style="font-family: monospace;">removeMin()</span></font><font
 size="+1"><span style="font-family: monospace;"></span> function of </font><font
 size="+1"><span style="font-style: italic;">P</span></font><font
 size="+1"> as&nbsp;</font><big><span style="font-style: italic;">S</span></big><font
 size="+1"><span style="font-family: monospace;">.remove(</span></font><big><span
 style="font-style: italic;">S</span></big><font size="+1"><span
 style="font-family: monospace;">.first())</span></font><font size="+1"><span
 style="font-family: monospace;"></span>. <span
 style="font-style: italic;">O</span>(1)</font></li>
  <li><big><font size="+1">The function </font><font size="+1"><span
 style="font-family: monospace;">insertItem(k,e)</span></font><font
 size="+1"> of </font><font size="+1"><span
 style="font-family: monospace;"></span></font></big><font size="+1"><span
 style="font-style: italic;">P</span></font><big><font size="+1"><span
 style="font-family: monospace;"></span></font><font size="+1">
requires that we scan through the sequence </font><font size="+1"><span
 style="font-family: monospace;"></span></font></big><big><span
 style="font-style: italic;">S</span></big><big><font size="+1"><span
 style="font-family: monospace;"></span></font><font size="+1"> to
find the appropriate position to insert the element and key. <span
 style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span>)<br>
    </font></big></li>
</ul>
<big><a href="7.5_SortedSeqPriorityQueue.h-SSPQ1.html">html-7.5</a>
(SSPQ1)<br>
<a href="7.6_SortedSeqPriorityQueue.h-SSPQ2.html">html-7.6</a> (SSPQ2)<br>
<br>
[<a href="priority.cpp"><span style="font-family: monospace;">priority.cpp</span></a>]<br>
<br>
<span style="font-weight: bold;">Comparing the Two
Implementations<br>
</span>[<a href="PriorityQueues-slides.pdf">PriorityQueues.pdf</a>
8]<br>
<br>
</big>
<table style="text-align: left; width: 100%;" border="0" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <ul>
        <li><big>Implementation with an unsorted sequence</big></li>
        <ul>
          <li><big>Store the items of the priority queue in a
list-based sequence, in
arbitrary order</big></li>
        </ul>
      </ul>
      </td>
      <td style="vertical-align: top;">
      <ul>
        <li><big>Implementation with a sorted sequence</big></li>
        <ul>
          <li><big>Store the items of the priority queue in a sequence,
sorted by key</big></li>
        </ul>
      </ul>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <ul>
        <li><big>Performance:</big></li>
        <ul>
          <li><big><span style="font-family: monospace;">insertItem</span>
takes <span style="font-style: italic;">O</span>(1) time since we can
insert the item at the
beginning or end of the sequence</big></li>
          <li><big><span style="font-family: monospace;">removeMin</span>,
            <span style="font-family: monospace;">minKey</span> and <span
 style="font-family: monospace;">minElement</span> take <span
 style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span>)
time since we have to
traverse the entire sequence to find the smallest key</big></li>
        </ul>
      </ul>
      </td>
      <td style="vertical-align: top;">
      <ul>
        <li><big>Performance:</big></li>
        <ul>
          <li><big><span style="font-family: monospace;">insertItem</span>
takes <span style="font-style: italic;">O</span>(<span
 style="font-style: italic;">n</span>) time since we have to find the
place where to
insert the item</big></li>
          <li><big><span style="font-family: monospace;">removeMin</span>,
            <span style="font-family: monospace;">minKey</span> and <span
 style="font-family: monospace;">minElement</span> take <span
 style="font-style: italic;">O</span>(1) time
since the smallest key
is at the beginning of the sequence</big></li>
        </ul>
      </ul>
      </td>
    </tr>
  </tbody>
</table>
<big><br>
</big>
<br>
<big style="font-weight: bold;">7.2.3 Selection-Sort and Insertion-Sort<br>
<br>
<span style="font-weight: bold;">Selection-Sort<br>
</span>[<a href="PriorityQueues-slides.pdf">PriorityQueues.pdf</a>
9]</big>
<ul>
  <li><big>Selection-sort is the variation of PQ-sort where the
priority queue is implemented with an unsorted sequence</big></li>
  <li><big>Running time of Selection-sort:</big></li>
  <ol>
    <li><big>Inserting the elements into the priority queue with <span
 style="font-style: italic;">n</span> <span
 style="font-family: monospace;">insertItem</span> operations takes <span
 style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span>)
time</big></li>
    <li><big>Removing the elements in sorted order from the priority
queue with <span style="font-style: italic;">n</span> <span
 style="font-family: monospace;">removeMin</span>
operations takes time proportional to<br>
1 + 2 + &#8230;+ <span style="font-style: italic;">n</span></big></li>
  </ol>
  <li><big>Selection-sort runs in <span style="font-style: italic;">O</span>(<span
 style="font-style: italic;">n</span><sup>2</sup>) time</big></li>
</ul>
<table style="width: 100%; text-align: left;" border="1" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">Sequence <span
 style="font-style: italic;">S</span><br>
      </td>
      <td style="vertical-align: top;">Priority Queue <span
 style="font-style: italic;">P</span> <br>
(unsorted sequence)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><big>Input<br>
      </big></td>
      <td style="vertical-align: top; text-align: center;">(<span
 style="font-weight: bold; color: rgb(204, 0, 0);">7</span>,4,8,2,5,3,9)<br>
      </td>
      <td style="vertical-align: top; text-align: center;">()<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><big>Phase 1<br>
      <span style="font-style: italic;">O</span>(<span
 style="font-style: italic;">n</span>)<br>
      </big></td>
      <td style="vertical-align: top; text-align: center;">(<span
 style="color: rgb(204, 102, 0);">4</span>,8,2,5,3,9)<br>
(<span style="color: rgb(204, 102, 0);">8</span>,2,5,3,9)<br>
(<span style="color: rgb(204, 102, 0);">2</span>,5,3,9)<br>
(<span style="color: rgb(204, 102, 0);">5</span>,3,9)<br>
(<span style="color: rgb(204, 102, 0);">3</span>,9)<br>
(<span style="color: rgb(204, 0, 0);">9</span>)<br>
()<br>
      </td>
      <td style="vertical-align: top; text-align: center;">(7)<br>
(7,4)<br>
(7,4,8)<br>
(7,4,8,2)<br>
(7,4,8,2,5)<br>
(7,4,8,2,5,3)<br>
(7,4,8,<span style="color: rgb(0, 153, 0); font-weight: bold;">2</span>,5,3,9)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><big>Phase 2</big><br>
      <big><span style="font-style: italic;">O</span>(<span
 style="font-style: italic;">n</span><sup><sub>2</sub></sup>)</big><br>
      </td>
      <td style="vertical-align: top; text-align: center;">(2)<br>
(2,3)<br>
(2,3,4)<br>
(2,3,4,5)<br>
(2,3,4,5,7)<br>
(2,3,4,5,7,8)<br>
(2,3,4,5,7,8,9)<br>
      </td>
      <td style="vertical-align: top; text-align: center;">(7,4,8,5,<span
 style="color: rgb(0, 153, 0); font-weight: bold;">3</span>,9)<br>
(7,<span style="color: rgb(0, 153, 0); font-weight: bold;">4</span>,8,5,9)<br>
(7,8,<span style="color: rgb(0, 153, 0); font-weight: bold;">5</span>,9)<br>
(<span style="font-weight: bold; color: rgb(0, 153, 0);">7</span>,8,9)<br>
(<span style="color: rgb(0, 153, 0); font-weight: bold;">8</span>,9)<br>
(<span style="font-weight: bold; color: rgb(0, 153, 0);">9</span>)<br>
()<br>
      </td>
    </tr>
  </tbody>
</table>
<big><span style="font-weight: bold;"><br style="font-weight: bold;">
Insertion-Sort<br>
</span>[<a href="PriorityQueues-slides.pdf">PriorityQueues.pdf</a>
10]<br>
</big>
<ul>
  <li><big>Insertion-sort is the variation of PQ-sort where the
priority queue is implemented with a sorted sequence</big></li>
  <li><big>Running time of Insertion-sort:</big></li>
  <ol>
    <li><big>Inserting the elements into the priority queue with <span
 style="font-style: italic;">n</span> <span
 style="font-family: monospace;">insertItem</span> operations takes
time proportional to<br>
1 + 2 + &#8230;+ <span style="font-style: italic;">n</span></big></li>
    <li><big>Removing the elements in sorted order from the priority
queue with a series of <span style="font-style: italic;">n</span> <span
 style="font-family: monospace;">removeMin</span> operations takes <span
 style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span>)
time</big></li>
  </ol>
  <li><big>Insertion-sort runs in <span style="font-style: italic;">O</span>(<span
 style="font-style: italic;">n</span><sup>2</sup>) time</big></li>
</ul>
<big><br>
</big>
<table style="width: 100%; text-align: left;" border="1" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">Sequence <span
 style="font-style: italic;">S</span><br>
      </td>
      <td style="vertical-align: top;">Priority Queue <span
 style="font-style: italic;">P</span><span style="font-style: italic;"></span>
      <br>
(sorted sequence) </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><big>Input</big><br>
      </td>
      <td style="vertical-align: top; text-align: center;">(<span
 style="color: rgb(204, 0, 0);">7</span>,4,8,2,5,3,9)<br>
      </td>
      <td style="vertical-align: top; text-align: center;">()<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><big>Phase 1</big><br>
      <big><span style="font-style: italic;">O</span>(<span
 style="font-style: italic;">n</span><sup><sub>2</sub></sup>)</big><br>
      </td>
      <td style="vertical-align: top; text-align: center;">(4,8,2,5,3,9)<br>
(8,2,5,3,9)<br>
(2,5,3,9)<br>
(5,3,9)<br>
(3,9)<br>
(9)<br>
()<br>
      </td>
      <td style="vertical-align: top; text-align: center;">(<span
 style="color: rgb(204, 0, 0); font-weight: bold;">7</span>)<br>
(<span style="color: rgb(204, 0, 0); font-weight: bold;">4</span>,7)<br>
(4,7,<span style="color: rgb(204, 0, 0); font-weight: bold;">8</span>)<br>
(<span style="color: rgb(204, 0, 0); font-weight: bold;">2</span>,4,7,8)<br>
(2,4,<span style="color: rgb(204, 0, 0); font-weight: bold;">5</span>,7,8)<br>
(2,<span style="color: rgb(204, 0, 0); font-weight: bold;">3</span>,4,5,7,8)<br>
(<span style="font-weight: bold; color: rgb(0, 153, 0);">2</span>,3,4,5,7,8,<span
 style="color: rgb(204, 0, 0); font-weight: bold;">9</span>)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><big>Phase 2<br>
      </big><big><span style="font-style: italic;">O</span>(<span
 style="font-style: italic;">n</span>)</big><br>
      </td>
      <td style="vertical-align: top; text-align: center;">(2)<br>
(2,3)<br>
(2,3,4)<br>
(2,3,4,5)<br>
(2,3,4,5,7)<br>
(2,3,4,5,7,8)<br>
(2,3,4,5,7,8,9)<br>
      </td>
      <td style="vertical-align: top; text-align: center;">(<span
 style="font-weight: bold; color: rgb(0, 153, 0);">3</span>,4,5,7,8,9)<br>
(<span style="font-weight: bold; color: rgb(0, 153, 0);">4</span>,5,7,8,9)<br>
(<span style="font-weight: bold; color: rgb(0, 153, 0);">5</span>,7,8,9)<br>
(<span style="font-weight: bold; color: rgb(0, 153, 0);">7</span>,8,9)<br>
(<span style="font-weight: bold; color: rgb(0, 153, 0);">8</span>,9)<br>
(<span style="font-weight: bold; color: rgb(0, 153, 0);">9</span>)<br>
()<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<hr style="width: 100%; height: 2px;">
<h3>7.3 Heaps</h3>
<ul>
  <li><big>An efficient realization of a priority queue uses a
(nonlinear)
data structure called a heap </big><big>&#8722;</big><big> performs both
insertions and removals in <span style="font-style: italic;">logarithmic</span>
time.</big></li>
</ul>
<big><br>
<span style="font-weight: bold;"> 7.3.1 The Heap Data
Structure</span><br>
[<a href="Heap-slides.pdf">heap.pdf</a> 10]<br>
</big>
<ul>
  <li><big>A heap is a binary tree storing keys at its internal nodes
and satisfying the following properties:</big></li>
  <ul>
    <li><big>Heap-Order: for every internal node <span
 style="font-style: italic;">v</span> other than the root, <span
 style="font-family: monospace;">key</span>(<span
 style="font-style: italic;">v</span>) &#8805; <span
 style="font-family: monospace;">key</span>(<span
 style="font-family: monospace;">parent</span>(<span
 style="font-style: italic;">v</span>))</big></li>
    <li><big>Complete Binary Tree: let <span
 style="font-style: italic;">h</span> be the height of the heap</big></li>
    <ul>
      <li><big>for <span style="font-style: italic;">i</span> = 0, &#8230; ,
        <span style="font-style: italic;">h</span> &#8722; 2, there are 2<sup><span
 style="font-style: italic;">i</span></sup> nodes of depth <span
 style="font-style: italic;">i</span></big></li>
      <li><big>at depth <span style="font-style: italic;">h </span>&#8722;
1,
the internal nodes are to the left of the
external nodes</big></li>
    </ul>
  </ul>
  <li><big>The <span style="font-style: italic;">last node</span> of a
heap is the rightmost internal node of
depth <span style="font-style: italic;">h</span> &#8722; 1</big></li>
</ul>
<big><img style="width: 374px; height: 271px;" alt="" src="pic1.jpg"><br>
<span style="font-weight: bold;"></span></big><big>
[<a href="Heap-slides.pdf">heap.pdf</a> 11]</big><br>
<big><span style="font-weight: bold;">Proposition 7.5:</span> A heap <span
 style="font-style: italic;">T</span>
storing <span style="font-style: italic;">n</span> keys has height <span
 style="font-style: italic;">h</span> = [log(<span
 style="font-style: italic;">n</span> + 1)].<br>
Proof: (we apply the complete binary tree property)<br>
</big>
<ul>
  <li><big>Let <span style="font-style: italic;">h</span> be the
height of a heap storing <span style="font-style: italic;">n</span>
keys</big></li>
  <li><big>Since there are 2<sup><span style="font-style: italic;">i</span></sup>
keys at depth <span style="font-style: italic;">i </span>= 0, &#8230; , <span
 style="font-style: italic;">h</span> &#8722;2 and at least one key at
depth <span style="font-style: italic;">h</span> &#8722;1, we have <span
 style="font-style: italic;">n</span> &#8805; 1 + 2 + 4 +&#8230; + 2<sup><span
 style="font-style: italic;">h</span> &#8722;2</sup> + 1</big></li>
  <li><big>Thus, <span style="font-style: italic;">n</span> &#8805; 2<sup><span
 style="font-style: italic;">h</span> &#8722; 1</sup> , i.e., <span
 style="font-style: italic;">h</span> &#8804; log <span
 style="font-style: italic;">n</span> + 1</big></li>
</ul>
<big>
<img style="width: 669px; height: 240px;" alt="" src="pic2.jpg"><br>
<br>
</big><big><span style="font-weight: bold;">7.3.2 Implementing a
Priority Queue with a Heap</span><br>
[<a href="Heap-slides.pdf">heap.pdf</a> 12]<br>
</big>
<ul>
  <li><big>We can use a heap to implement a priority queue</big></li>
  <li><big>We store a (<span style="font-family: monospace;">key</span>,
    <span style="font-family: monospace;">element</span>) item at each
internal node</big></li>
  <li><big>We keep track of the position of the last node</big></li>
</ul>
<big><img style="width: 678px; height: 258px;" alt="" src="pic3.jpg"><br>
<span style="font-weight: bold;">The Vector Representation
of a Heap<br>
</span>[<a href="Heap-slides.pdf">heap.pdf</a> 19]<br>
</big>
<ul>
  <li><big>We can represent a heap with <span
 style="font-style: italic;">n</span> keys by means of a vector of
length <span style="font-style: italic;">n</span> + 1</big></li>
  <li><big>For the node at rank <span style="font-style: italic;">i</span></big></li>
  <ul>
    <li><big>the left child is at rank 2<span
 style="font-style: italic;">i</span></big></li>
    <li><big>the right child is at rank 2<span
 style="font-style: italic;">i</span> +1</big></li>
  </ul>
  <li><big>Links between nodes are not explicitly stored</big></li>
  <li><big>The leaves are not represented</big></li>
  <li><big>The cell of at rank 0 is not used</big></li>
  <li><big>Operation <span style="font-family: monospace;">insertItem</span>
corresponds to inserting at rank <span style="font-style: italic;">n</span>
+ 1</big></li>
  <li><big>Operation <span style="font-family: monospace;">removeMin</span>
corresponds to removing at rank <span style="font-style: italic;">n</span></big></li>
  <li><big>Yields in-place heap-sort</big></li>
</ul>
<big><span style="font-weight: bold;"><img
 style="width: 351px; height: 329px;" alt="" src="pic4.jpg"><br>
Insertion<br>
</span>[<a href="Heap-slides.pdf">heap.pdf</a> 13]<br>
</big>
<ul>
  <li><big>Method <span style="font-family: monospace;">insertItem</span>
of the priority queue ADT corresponds to
the insertion of a key <span style="font-style: italic;">k</span> to
the heap</big></li>
  <li><big>The insertion algorithm consists of three steps</big></li>
  <ul>
    <li><big>Find the insertion node <span style="font-style: italic;">z
      </span>(the new last node)</big></li>
    <li><big>Store <span style="font-style: italic;">k</span> at <span
 style="font-style: italic;">z</span> and expand <span
 style="font-style: italic;">z</span> into an internal node</big></li>
    <li><big>Restore the heap-order property (discussed next)</big></li>
  </ul>
</ul>
<big><span style="font-weight: bold;"><br style="font-weight: bold;">
</span></big>
<table style="text-align: left; width: 100%;" border="0" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><img
 style="width: 365px; height: 200px;" alt="" src="pic5.jpg"><br>
      </td>
      <td style="vertical-align: top;"><img
 style="width: 378px; height: 185px;" alt="" src="pic6.jpg"><br>
      </td>
    </tr>
  </tbody>
</table>
<big><span style="font-weight: bold;"></span><span
 style="font-weight: bold;"><br>
Up-Heap Bubbling after an
Insertion<br>
</span>[<a href="Heap-slides.pdf">heap.pdf</a> 14]<br>
</big>
<ul>
  <li><big>After the insertion of a new key <span
 style="font-style: italic;">k</span>, the heap-order property
may be violated</big></li>
  <li><big>Algorithm upheap restores the heap-order property by
swapping <span style="font-style: italic;">k</span> along an upward
path from the insertion node</big></li>
  <li><big>Upheap terminates when the key <span
 style="font-style: italic;">k</span> reaches the root or a node
whose parent has a key smaller than or equal to <span
 style="font-style: italic;">k</span></big></li>
  <li><big>Since a heap has height <span style="font-style: italic;">O</span>(log
    <span style="font-style: italic;">n</span>), upheap runs in <span
 style="font-style: italic;">O</span>(log <span
 style="font-style: italic;">n</span>) time</big></li>
</ul>
<big><span style="font-weight: bold;"></span></big>
<table style="text-align: left; width: 100%;" border="0" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><img
 style="width: 375px; height: 181px;" alt="" src="pic7.jpg"><br>
      </td>
      <td style="vertical-align: top;"><img
 style="width: 375px; height: 188px;" alt="" src="pic8.jpg"><br>
      </td>
    </tr>
  </tbody>
</table>
<big><span style="font-weight: bold;"></span><span
 style="font-weight: bold;">Removal<br>
</span>[<a href="Heap-slides.pdf">heap.pdf</a> 15]<br>
</big>
<ul>
  <li><big>Method <span style="font-family: monospace;">removeMin</span>
of the priority queue ADT corresponds to
the removal of the root key from the heap</big></li>
  <li><big>The removal algorithm consists of three steps</big></li>
  <ul>
    <li><big>Replace the root key with the key of the last node <span
 style="font-style: italic;">w</span></big></li>
    <li><big>Compress <span style="font-style: italic;">w</span> and
its children into a leaf</big></li>
    <li><big>Restore the heap-order property (discussed next)</big></li>
  </ul>
</ul>
<table style="text-align: left; width: 100%;" border="0" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><img
 style="width: 301px; height: 193px;" alt="" src="pic9.jpg"><br>
      </td>
      <td style="vertical-align: top;"><img
 style="width: 308px; height: 182px;" alt="" src="pic10.jpg"><br>
      </td>
    </tr>
  </tbody>
</table>
<big><span style="font-weight: bold;">Down-Heap Bubbling after a Removal<br>
</span>[<a href="Heap-slides.pdf">heap.pdf</a> 16<br>
</big>
<ul>
  <li><big>After replacing the root key with the key <span
 style="font-style: italic;">k</span> of the last node,
the heap-order property may be violated</big></li>
  <li><big>Algorithm downheap restores the heap-order property by
swapping key <span style="font-style: italic;">k</span> along a
downward path from the root</big></li>
  <li><big>Downheap terminates when key <span
 style="font-style: italic;">k</span> reaches a leaf or a node whose
children have keys greater than or equal to <span
 style="font-style: italic;">k</span></big></li>
  <li><big>Since a heap has height <span style="font-style: italic;">O</span>(log
    <span style="font-style: italic;">n</span>), downheap runs in <span
 style="font-style: italic;">O</span>(log <span
 style="font-style: italic;">n</span>) time</big></li>
</ul>
<table style="text-align: left; width: 100%;" border="0" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><img
 style="width: 302px; height: 185px;" alt="" src="pic11.jpg"><br>
      </td>
      <td style="vertical-align: top;"><img
 style="width: 298px; height: 193px;" alt="" src="pic12.jpg"><br>
      </td>
    </tr>
  </tbody>
</table>
<big><span style="font-weight: bold;"></span><span
 style="font-weight: bold;"><br>
Analysis<br>
<big><br>
</big></span></big>
<table style="text-align: left; width: 693px; height: 149px;" border="1"
 cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><big><span
 style="font-weight: bold;">Function</span><br>
      </big></td>
      <td style="vertical-align: top;"><big><span
 style="font-weight: bold;">Time</span><br>
      </big></td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><big>size(),
isEmpty()<br>
      </big></td>
      <td style="vertical-align: top;"><big><span
 style="font-style: italic;">O</span>(1)<br>
      </big></td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><big>minElement(),
minKey()<br>
      </big></td>
      <td style="vertical-align: top;"><big><span
 style="font-style: italic;">O</span>(1)<br>
      </big></td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><big>insertItem(k,e)<br>
      </big></td>
      <td style="vertical-align: top;"><big><span
 style="font-style: italic;">O</span>(log <span
 style="font-style: italic;">n</span>)<br>
      </big></td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><big>removeMin()<br>
      </big></td>
      <td style="vertical-align: top;"><big><span
 style="font-style: italic;">O</span>(log <span
 style="font-style: italic;">n</span>)<br>
      </big></td>
    </tr>
  </tbody>
</table>
<br>
<big style="font-weight: bold;">7.3.3 C++ Implementation</big><br>
<big><a href="7.7_HeapTree.h-HeapTree.html">html-7.7</a> (HeapTree)<br>
<a href="7.8_HeapPriorityQueue.h-HPQ1.html">html-7.8</a> (HPQ1)<br>
<a href="7.9_HeapPriorityQueue.h-HPQ2.html">html-7.<span
 style="text-decoration: underline;">9</span></a> (HPQ2)<br>
<br>
</big><big style="font-weight: bold;"> 7.3.4 Heap-Sort</big><br>
<big>[<a href="Heap-slides.pdf">heap.pdf</a> 18]<br>
</big>
<ul>
  <li><big>Consider a priority queue with <span
 style="font-style: italic;">n</span> items implemented by means
of a heap</big></li>
  <ul>
    <li><big>the space used is <span style="font-style: italic;">O</span>(<span
 style="font-style: italic;">n</span>)</big></li>
    <li><big>methods <span style="font-family: monospace;">insertItem</span>
and <span style="font-family: monospace;">removeMin</span> take <span
 style="font-style: italic;">O</span>(log <span
 style="font-style: italic;">n</span>) time</big></li>
    <li><big>methods <span style="font-family: monospace;">size</span>,
      <span style="font-family: monospace;">isEmpty</span>, <span
 style="font-family: monospace;">minKey</span>, and <span
 style="font-family: monospace;">minElement</span> take <span
 style="font-style: italic;">O</span>(1) time</big></li>
  </ul>
  <li><big>Using a heap-based priority queue, we can sort a sequence of
    <span style="font-style: italic;">n</span> elements in <span
 style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span>
log <span style="font-style: italic;">n</span>) time</big></li>
  <li><big>The resulting algorithm is called heap-sort</big></li>
  <li><big>Heap-sort is much faster than quadratic sorting algorithms,
such as insertion-sort and selection-sort</big></li>
</ul>
<big>
</big>
<hr style="width: 100%; height: 2px;">
</body>
</html>
