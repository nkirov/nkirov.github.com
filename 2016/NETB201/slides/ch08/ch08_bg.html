<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>Chapter 8</title>
  </head>
  <body>
    <h2>Речници</h2>
    <ul>
      <li><big>Основната употреба на речника е да съхранява обекти,
          така, че те да могат да се намират бързо с използване на
          ключове.</big></li>
      <li><big><span style="font-style: italic;"></span>Подобно на
          приоритетната опашка, речникът е контейнер на двойки
          ключ-елемент.</big></li>
      <li><big>Независимо от това, че за приоритетната опашка се иска
          пълна наредба на ключовете, за речника тя е по избор.</big></li>
      <li><big>Най-простата форма на речника изисква само да може да се
          определи дали два ключа са еднакви.<br>
        </big></li>
      <li><big>Когато е дефинирана пълна наредба на ключовете, имаме <i>нареден
            речник</i>, за който дефинираме допълнителни функции, които
          се отнасят до наредбата на ключовете.</big></li>
    </ul>
    <ul>
      <li><big>Речник АТД съхранява <b>двойки</b> ключ-елемент (<span
            style="font-style: italic;">k</span>,<span
            style="font-style: italic;">e</span>), които ще наричаме <b>членове</b>
          на речника (items), където <span style="font-style: italic;">k</span>
          е ключ и <span style="font-style: italic;">e</span> е
          елемент. </big></li>
      <li>
        <big><big> </big></big><font size="+1">В ненареден речник можем
          да използваме обект-тестер за проверка дали два ключа</font><big>
          <span style="font-style: italic;">k</span><sub>1</sub> и <span
            style="font-style: italic;">k</span><sub>2</sub> са равни с
          функция за равенство (еднаквост) <span style="font-family:
            monospace;">isEqualTo(</span><span style="font-style:
            italic;">k</span><sub>1</sub>, <span style="font-style:
            italic;">k</span><sub>2</sub>).<br>
        </big>
      </li>
    </ul>
    <big><span style="font-weight: bold;">Речник АТД</span><br>
    </big>
    <ul>
      <li><big>Речник АТД моделира възможности за търсене в колекция от
          двойки ключ-елемент.</big></li>
      <li><big>Основни операции за речник са <i>търсене</i> (find), <i>вмъкване</i>
          (добавяне, insert) и <i>премахване</i> (изтриване, delete).</big></li>
      <li><big>Допуска се няколко членове на речника да имат един и същи
          ключ.</big></li>
      <li><big>Приложения:</big></li>
      <ul>
        <li><big>книга с адреси (address book);</big></li>
        <li><big>авторизация на кредитни карти (credit card
            authorization);</big></li>
        <li><big>DNS съответствия [име на хост (напр.&nbsp; <span
              style="font-family: monospace;">www.nbu.bg</span>) -
            интернет адрес (<span style="font-family: monospace;">193.19.172.24</span>)].</big></li>
      </ul>
      <li><big>Като АТД, речникът поддържа следните функции:</big></li>
    </ul>
    <table style="width: 100%; text-align: left;" border="1"
      cellpadding="2" cellspacing="0">
      <tbody>
        <tr>
          <td style="vertical-align: top;"><big>Function<br>
            </big></td>
          <td style="vertical-align: top;"><big>Input<br>
            </big></td>
          <td style="vertical-align: top;"><big>Output<br>
            </big></td>
          <td style="vertical-align: top;"><big>Description<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>size()<br>
            </big></td>
          <td style="vertical-align: top;"><big>-<br>
            </big></td>
          <td style="vertical-align: top;"><big>Integer<br>
            </big></td>
          <td style="vertical-align: top;"><big>Връща броя на елементите
              на <span style="font-style: italic;">D.</span><br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>isEmpty()<br>
            </big></td>
          <td style="vertical-align: top;"><big>-<br>
            </big></td>
          <td style="vertical-align: top;"><big>Boolean<br>
            </big></td>
          <td style="vertical-align: top;"><big>Проверява дали <span
                style="font-style: italic;">D</span> е празен.<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>elements()<br>
            </big></td>
          <td style="vertical-align: top;"><big>-<br>
            </big></td>
          <td style="vertical-align: top;"><big>Iterator of objects
              (elements)<br>
            </big></td>
          <td style="vertical-align: top;"><big>Връща елементите,
              записани в <span style="font-style: italic;">D</span>.<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>keys()<br>
            </big></td>
          <td style="vertical-align: top;"><big>-<br>
            </big></td>
          <td style="vertical-align: top;"><big>Iterator of objects
              (keys)</big></td>
          <td style="vertical-align: top;"><big>Връща ключовете,
              записани в <span style="font-style: italic;">D</span>.</big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>find(k)<br>
            </big></td>
          <td style="vertical-align: top;"><big>Object (key)</big></td>
          <td style="vertical-align: top;"><big>Position<br>
            </big></td>
          <td style="vertical-align: top;"><big>Ако <span
                style="font-style: italic;">D</span> съдържа член с
              ключ, равен на <span style="font-family: monospace;">k</span>,
              връща позицията на този член. Ако не, връща nullposition .<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>findAll(k)<br>
            </big></td>
          <td style="vertical-align: top;"><big>Object (key)</big></td>
          <td style="vertical-align: top;"><big>Iterator of Positions</big></td>
          <td style="vertical-align: top;"><big>Връща итератор от
              позициите на всички членове, чийто ключове са равни на <span
                style="font-family: monospace;">k</span>.<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>insertItem(k,e)<br>
            </big></td>
          <td style="vertical-align: top;"><big>Objects <span
                style="font-family: monospace;">k</span> (key) and<span
                style="font-family: monospace;"> e</span><span
                style="font-family: monospace;"></span> (element) </big></td>
          <td style="vertical-align: top;"><big>-<br>
            </big></td>
          <td style="vertical-align: top;"><big>Вмъква двойка с елемент
              <span style="font-family: monospace;">e</span> и ключ <span
                style="font-family: monospace;">k</span> в <span
                style="font-style: italic;">D</span>.<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>removeElement(k)<br>
            </big></td>
          <td style="vertical-align: top;"><big>Object (key)<br>
            </big></td>
          <td style="vertical-align: top;"><big>-<br>
            </big></td>
          <td style="vertical-align: top;"><big>Премахва член с ключ
              равен на <span style="font-family: monospace;">k</span>
              от <span style="font-style: italic;">D</span>. Ако в <span
                style="font-style: italic;">D</span> няма такъв член се
              генерира грешка (error condition).<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>removeAllElements(k)<br>
            </big></td>
          <td style="vertical-align: top;"><big>Object (key)</big></td>
          <td style="vertical-align: top;"><big>-<br>
            </big></td>
          <td style="vertical-align: top;"><big>Премахва всички двойки с
              ключове равни на <span style="font-family: monospace;">k</span>
              от <span style="font-style: italic;">D</span>.</big></td>
        </tr>
      </tbody>
    </table>
    <ul>
      <li><big>Бележки: <br>
        </big></li>
      <ul>
        <li><big>Начинът, по който членовете на речника се съхраняват
            зависи от реализацията на речника.</big></li>
        <li><big>Означението <span style="font-family: monospace;">p(x)</span>
            показва позицията на члена, където се пази елемента <span
              style="font-family: monospace;">x</span>.</big></li>
      </ul>
      <li style="color: rgb(0, 102, 0);"><big>Пример:</big></li>
    </ul>
    <table style="width: 100%; text-align: left;" border="1"
      cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td style="vertical-align: top;"><big>Operation<br>
            </big></td>
          <td style="vertical-align: top;"><big>Output<br>
            </big></td>
          <td style="vertical-align: top;"><big>Dictionary<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>insertItem(5,A)<br>
              insertItem(7,B)<br>
              insertItem(2,C)<br>
              insertItem(8,D)<br>
              insertItem(2,E)<br>
              find(7)<br>
              find(4)<br>
              find(2)<br>
              findAll(2)<br>
              size()<br>
              removeElement(5)<br>
              removeElement(5)<br>
              removeAllElements(2)<br>
              find(2)<br>
              findAll(2)<br>
            </big></td>
          <td style="vertical-align: top;"><big><span
                style="font-family: monospace;"></span><span
                style="font-family: monospace;">-</span><br
                style="font-family: monospace;">
              <span style="font-family: monospace;">-</span><br
                style="font-family: monospace;">
              <span style="font-family: monospace;">-</span><br
                style="font-family: monospace;">
              <span style="font-family: monospace;">-<br>
                -<br style="font-family: monospace;">
              </span><span style="font-family: monospace;">p(B)<br>
                "null"<br>
                p(C) or p(E)<br>
                p(C),p(E)<br>
                5<br>
                -<br>
                "error"<br>
                -<br>
                "null"<br>
                "empty iterator"<br>
              </span> </big></td>
          <td style="vertical-align: top;"><big><span
                style="font-family: monospace;">{(5,A)}</span><br
                style="font-family: monospace;">
              <span style="font-family: monospace;">{(5,A),(7,B)}</span><br
                style="font-family: monospace;">
              <span style="font-family: monospace;">{(5,A),(7,B),(2,C)}</span><br
                style="font-family: monospace;">
              <span style="font-family: monospace;">{(5,A),(7,B),(2,C),(8,D)}</span><br
                style="font-family: monospace;">
              <span style="font-family: monospace;">{(5,A),(7,B),(2,C),(8,D),(2,E)}</span><br
                style="font-family: monospace;">
              <span style="font-family: monospace;">{(5,A),(7,B),(2,C),(8,D),(2,E)}</span><br
                style="font-family: monospace;">
              <span style="font-family: monospace;">{(5,A),(7,B),(2,C),(8,D),(2,E)}</span><br
                style="font-family: monospace;">
              <span style="font-family: monospace;">{(5,A),(7,B),(2,C),(8,D),(2,E)}</span><br
                style="font-family: monospace;">
              <span style="font-family: monospace;">{(5,A),(7,B),(2,C),(8,D),(2,E)}<br>
              </span><span style="font-family: monospace;">{(5,A),(7,B),(2,C),(8,D),(2,E)}</span><br
                style="font-family: monospace;">
              <span style="font-family: monospace;">{(7,B),(2,C),(8,D),(2,E)}<br>
              </span><span style="font-family: monospace;">{(7,B),(2,C),(8,D),(2,E)}<br>
              </span><span style="font-family: monospace;">{(7,B),(8,D)}<br>
              </span><span style="font-family: monospace;">{(7,B),(8,D)}<br>
              </span><span style="font-family: monospace;">{(7,B),(8,D)}</span>
            </big></td>
        </tr>
      </tbody>
    </table>
    <ul>
      <li><big>Позиция АТД поддържа следните функции:</big></li>
    </ul>
    <table style="width: 100%; text-align: left;" border="1"
      cellpadding="2" cellspacing="0">
      <tbody>
        <tr>
          <td style="vertical-align: top;"><big>Operation<br>
            </big></td>
          <td style="vertical-align: top;"><big>Input<br>
            </big></td>
          <td style="vertical-align: top;"><big>Output<br>
            </big></td>
          <td style="vertical-align: top;"><big>Description</big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>element()</big></td>
          <td style="vertical-align: top;"><big>-<br>
            </big></td>
          <td style="vertical-align: top;"><big>Object (element)</big></td>
          <td style="vertical-align: top;"><big>Връща псевдоним на
              елемента от двойката на тази позиция.<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>key()</big></td>
          <td style="vertical-align: top;"><big>-<br>
            </big></td>
          <td style="vertical-align: top;"><big>Object (key)</big></td>
          <td style="vertical-align: top;"><big>Връща константен
              псевдоним на ключа от двойката на тази позиция.</big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>isNull()</big></td>
          <td style="vertical-align: top;"><big>-<br>
            </big></td>
          <td style="vertical-align: top;"><big>Boolean<br>
            </big></td>
          <td style="vertical-align: top;"><big>Връща <tt>true</tt>,
              ако това е nullposition.<br>
            </big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
      <span style="font-weight: bold;">Log файлове</span><br>
    </big>
    <ul>
      <li><big>Един прост начин за реализация на речник АТД е да
          използваме ненаредени вектор АТД, списък АТД или редица АТД за
          запазване на двойката ключ-елемент. </big></li>
      <li><big>Тази реализация се нарича <span style="font-style:
            italic;">log файл</span>.</big></li>
    </ul>
    <big> </big>
    <ul>
      <li><big>Log файл е речник АТД, реализиран с несортирана редица.<span
            style="font-style: italic;"></span></big></li>
      <ul>
        <li><big>Съхраняваме членовете на речника в редица (базирана на
            двойносвързан списък или кръгов масив) в произволен ред.</big></li>
      </ul>
      <li><big>Performance:</big></li>
      <ul>
        <li><big><span style="font-family: monospace;">insertItem</span>
            отнема време <span style="font-style: italic;">O</span>(1),
            защото добавяме нов член в началото или в края на редицата.</big></li>
        <li><big><span style="font-family: monospace;">find</span> и <span
              style="font-family: monospace;">removeElement</span>
            отнемат време<span style="font-style: italic;"> O</span>(<span
              style="font-style: italic;">n</span>), защото в най-лошия
            случай (обектът не е намерен) трябва да обходим (претърсим)
            цялата редица, сравнявайки ключовете на членовете с дадения
            ключ.</big></li>
      </ul>
      <li><big>Log файлът е ефективен само за речници с малки размери
          или за речници, за които вмъкването са най-честата операция,
          докато търсене и изтриване се изпълняват рядко (напр., запис
          на историята потребителски имена на работна станция).<br>
        </big></li>
    </ul>
    <hr style="width: 100%; height: 1px;">
    <h3>Хеш таблици<br>
    </h3>
    <ul>
      <li><big>Един от най-ефективните начини за реализация на речник
          АТД е използването на хеш таблица. </big></li>
      <li><big>Въпреки, че хеш таблици имат голямо време за изпълнение в
          най-лошия случай за операциите на речник АТД, ще видим, че
          тяхното очаквано време за изпълнение в повечето случаи е
          отлично.</big></li>
      <li><big>Ако <span style="font-style: italic;">n</span> означава
          броя на обектите в речника, времето за работа в най-лошия
          случай е <span style="font-style: italic;">O</span>(<span
            style="font-style: italic;">n</span>), но очаквано време за
          работа в общия случай е само <span style="font-style:
            italic;">O</span>(1).</big></li>
    </ul>
    <big><span style="font-weight: bold;">Клетъчни масиви (bucket
        arrays)</span><br>
    </big>
    <ul>
      <li><big>A <span style="font-style: italic;">клетъчен масив</span>
          за хеш таблица е масив <span style="font-style: italic;">A</span>
          с размер <span style="font-style: italic;">N</span>
          (капацитет), където всеки елемент на <span style="font-style:
            italic;">A</span> се разглежда като клетка (т.е. контейнер
          на двойката ключ-елемент)<span style="font-style: italic;"></span><span
            style="font-style: italic;"></span>. </big></li>
      <li><big>Ако ключовете са цели числа, <i>добре разпределени</i> в
          интервала [0, <span style="font-style: italic;">N</span> <span
            style="font-style: italic;">-</span> 1], този клетъчен масив
          е всичко, от което се нуждаем - елемент <span
            style="font-style: italic;">e</span> с ключ <span
            style="font-style: italic;">k</span> просто се вмъква в
          клетка <span style="font-style: italic;">A</span>[<span
            style="font-style: italic;">k</span>].</big></li>
      <li><big>Ако ключовете не са уникални, тогава два елемента може да
          попаднат е една и съща клетка от <span style="font-style:
            italic;">A</span>. В този случай казваме, че се появява <i>колизия</i>.</big></li>
    </ul>
    <big><b>Анализ на структурата на клетъчния масив</b><br>
    </big>
    <ul>
      <li><big>Достижение: <span style="font-style: italic;">O</span>(1)











          за всички функции, няма колизии за различни ключове. </big></li>
      <li><big>Недостатък 1: Използва памет Theta(<span
            style="font-style: italic;">N</span>), разточително когато <span
            style="font-style: italic;">N</span> е голямо относно <span
            style="font-style: italic;">n.</span></big></li>
      <li><big>Недостатък 2: Ключовете са цели числа в интервала [0, <span
            style="font-style: italic;">N -</span> 1], което често не е
          така.<span style="font-style: italic;"></span></big></li>
    </ul>
    <big><span style="font-weight: bold;">Хеш функции</span><br>
    </big>
    <ul>
      <li><big>Хеш функция <span style="font-style: italic;">h</span>
          изобразява ключове от даден тип&nbsp; в цели числа от
          интервала [0, <span style="font-style: italic;">N</span> −
          1].</big></li>
      <li><big><span style="color: rgb(0, 102, 0);">Пример:</span> <span
            style="font-style: italic;">h</span>(<span
            style="font-style: italic;">x</span>) = <span
            style="font-style: italic;">x</span> mod <span
            style="font-style: italic;">N</span> е хеш функция за цели
          числа.</big></li>
      <li><big>Цялото число <span style="font-style: italic;">h</span>(<span
            style="font-style: italic;">x</span>) се нарича хеш стойност
          на ключа <span style="font-style: italic;">x.</span></big></li>
      <li><big>Хеш таблица за даден тип ключове се състои от:</big></li>
      <ul>
        <li><big>хеш функция <span style="font-style: italic;">h,<br>
            </span></big></li>
        <li><big>масив с размер <span style="font-style: italic;">N.</span></big></li>
      </ul>
      <li><big>Когато реализираме речник с хеш таблица, целта е да
          поставим обекта (<span style="font-style: italic;">k</span>, <span
            style="font-style: italic;">e</span>) в масива с индекс <span
            style="font-style: italic;">i</span> =&nbsp; <span
            style="font-style: italic;">h</span>(<span
            style="font-style: italic;">k</span>).</big></li>
      <li style="color: rgb(0, 102, 0);"><big>Пример:</big></li>
    </ul>
    <table style="text-align: left; width: 100%;" border="0"
      cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td style="vertical-align: top;"><big><img style="width:
                286px; height: 298px;" alt="" src="pic1.jpg"><br>
            </big></td>
          <td style="text-align: left; vertical-align: middle;">
            <ul>
              <li><big>Ще направим хеш таблица за речник, съдържащ
                  двойки (SSN, Name), където SSN (social security
                  number) е 9-цифрово положително число.</big></li>
              <li><big>Ако хеш таблицата използва масив с размер N =
                  10000 и хеш функция <i>h</i>(<i>x</i>) = <i>x</i>
                  mod 10000, т.е. (последните 4 цифри на x), може да
                  възникнат колизии.<br>
                </big></li>
              <li><big>За да избегнем колизии, ще трябва да вземем <span
                    style="font-style: italic;">N</span> = 10<sup>9</sup>
                  и хеш функция <span style="font-style: italic;">h</span>(<span
                    style="font-style: italic;">x</span>) = <span
                    style="font-style: italic;">x </span>(Недостатък 1)<span
                    style="font-style: italic;">.<br>
                  </span></big></li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <ul>
      <li>
        <big>Хеш функцията </big><big><big><span style="font-style:
              italic;"><font size="+1">h</font> </span></big>обикновено
          се разглежда като композиция на две функции:<br>
        </big>
      </li>
      <ul>
        <li><big>Хеш код: <span style="font-style: italic;">h</span><sub>1</sub>:
            keys → integers</big></li>
        <li><big>Компресия: <span style="font-style: italic;">h</span><sub>2</sub>:
            integers → [0, <span style="font-style: italic;">N</span> −
            1]</big></li>
      </ul>
      <li><big>Хеш кода се прилага първи и след това компресията се
          прилага върху резултата, т.е.&nbsp;<span style="font-style:
            italic;">h</span>(<span style="font-style: italic;">x</span>)
          = <span style="font-style: italic;">h</span><sub>2</sub>(<span
            style="font-style: italic;">h</span><sub>1</sub>(<span
            style="font-style: italic;">x</span>)).</big></li>
      <li><big>Целта на хеш функцията е да "разпръсне" ключовете по
          (привидно) случаен начин.</big></li>
      <li><big>Хеш функцията е "добра" ако изобразява ключовете на
          речника така, че да минимизира колизиите.</big></li>
      <li><big>Тя трябва да бъде също така бърза и лесна за пресмятане.</big></li>
    </ul>
    <big><span style="font-weight: bold;">Хеш кодове</span><br>
    </big>
    <ul>
      <li><big>Цяло число, което съответства на ключа <span
            style="font-style: italic;">k</span> се нарича хеш код или
          хеш стойност за <span style="font-style: italic;">k</span>.</big></li>
    </ul>
    <big>Хеш кодове в C++<br>
    </big>
    <ul>
      <li><big>Адреси на паметта:<br>
        </big></li>
      <ul>
        <li><big>Обръщаме (преобразуваме) адреса в паметта на
            обекта-ключ в цяло число.</big></li>
        <li><big>Добър като цяло, с изключение на числови и низови
            ключове.<br>
          </big></li>
      </ul>
      <li><big>Integer cast:</big></li>
      <ul>
        <li>
          <big>Преобразуваме (</big><big><font size="+1">reinterpret</font>)
            битовете на ключа в цяло число.<br>
          </big>
        </li>
        <li>
          <big>Подходящ за ключове с дължина по-малка или равна на броя
            на битовете на числовия тип (например, </big><big>char,
            short, int и float за много машини).<br>
          </big>
        </li>
      </ul>
      <li><big>Сума на компонентите:</big></li>
      <ul>
        <li><big>Разделяме битовете на ключа на компоненти с фиксирана
            дължина (например 16 или 32 бита) и сумираме компонентите
            (игнорирайки евентуално препълване).</big></li>
        <li>
          <big>Подходящ за числови ключове с фиксирана дължина,
            по-голяма или равна на броя на битовете на числовия тип
            (например,&nbsp;</big><big><big> <font size="+1">long</font>
            </big> и double за много машини).</big>
        </li>
      </ul>
    </ul>
    <big>C++ пример<br>
      32-bit integer if we have 32-bit integer hash function<br>
    </big>
    <pre><big>int hashCode(int x)<br>{ return x; }</big></pre>
    <big>64-bit integer if we have 32-bit integer hash function</big>
    <pre><big>int hashCode(long x)<br>{  typedef unsigned long ulong;<br>   return hashCode(static_cast&lt;int&gt;(static_cast&lt;ulong&gt;(x) &gt;&gt; 32) <br>          + static_cast&lt;int&gt;(x));<br>}</big></pre>
    <big>Полиномен хеш код<span style="font-weight: bold;"></span><br>
    </big>
    <ul>
      <li><big>Полиномиално натрупване:</big></li>
      <ul>
        <li><big>Разделяме битовете на ключа на редица от компоненти с
            фиксирана дължина (например, 8, 16 или 32 бита): <span
              style="font-style: italic;">a</span><sub>0</sub> <span
              style="font-style: italic;">a</span><sub>1</sub>… <span
              style="font-style: italic;">a</span><sub><span
                style="font-style: italic;">n</span>−1.</sub></big></li>
        <li><big>Пресмятаме стойността на полинома<br>
            <span style="font-style: italic;">p</span>(<span
              style="font-style: italic;">z</span>) =<span
              style="font-style: italic;"> a</span><sub>0</sub> +<span
              style="font-style: italic;"> a</span><sub>1</sub><span
              style="font-style: italic;">z</span> + <span
              style="font-style: italic;">a</span><sub>2</sub> <span
              style="font-style: italic;">z</span><sup><sub>2</sub></sup>
            + … + <span style="font-style: italic;">a<sub>n</sub></span><sub>−1</sub><span
              style="font-style: italic;">z<sup><sub>n</sub></sup></span><sup><sub>−1</sub></sup><br>
            за фиксирана стойност на <span style="font-style: italic;">z</span>,
            игнорирайки препълването.</big></li>
        <li><big>Особено подходящ за низове (напр. изборът <span
              style="font-style: italic;">z</span> = 33 дава най-много 6
            колизии за множество от 50000 английски думи!)</big></li>
      </ul>
      <li><big>Стойността на полиномът <span style="font-style:
            italic;">p</span>(<span style="font-style: italic;">z</span>)
          се смята за време <span style="font-style: italic;">O</span>(<span
            style="font-style: italic;">n</span>) по схемата на Хорнер:</big></li>
      <ul>
        <li>
          <big>Следните полиноми се изчисляват </big><big><big> <font
                size="+1">последователно</font></big><font size="+1">, </font>като







            всеки от предишния, за време <span style="font-style:
              italic;">O</span>(1) -<br>
            <span style="font-style: italic;">p</span><sub>0</sub>(<span
              style="font-style: italic;">z</span>) = <span
              style="font-style: italic;">a<sub>n</sub></span><sub>−1,&nbsp;</sub><span
              style="font-style: italic;"> p</span><sub><span
                style="font-style: italic;">i</span></sub>(<span
              style="font-style: italic;">z</span>) = <span
              style="font-style: italic;">a<sub>n−i−</sub></span><sub>1</sub>
            + <span style="font-style: italic;">zp<sub>i−</sub></span><sub>1</sub>(<span
              style="font-style: italic;">z</span>) (<span
              style="font-style: italic;">i</span> = 1, 2, …, <span
              style="font-style: italic;">n −</span> 1).</big>
        </li>
      </ul>
      <li><big>Получаваме <span style="font-style: italic;">p</span>(<span
            style="font-style: italic;">z</span>) =<span
            style="font-style: italic;"> p<sub>n</sub></span><sub>−1</sub>(<span
            style="font-style: italic;">z</span>).</big></li>
    </ul>
    <big> Циклични </big><big><font size="+1">с преместване хеш</font>
      кодове <br>
    </big>
    <blockquote>
      <pre><big>int hashCode(const char* p, int len) // hash a character array<br>{ unsigned int h = 0;<br>  for (int i = 0; i &lt; len; i++)<len i=""><br>  { h = (h &lt;&lt; 5)|(h &gt;&gt; 27);          // 5-bit cyclic shift<br>    h += (unsigned int)p[i];         // add in next character<br>  }<br>  return hashCode(int(h));<br>}<br></len></big></pre>
    </blockquote>
    <big>Експериментални резултати за 25000 английски думи</big>
    <table style="text-align: left; width: 687px; height: 144px;"
      border="1" cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td style="vertical-align: top;"><big>Shift<br>
            </big></td>
          <td style="vertical-align: top;"><big>Collisions Total<br>
            </big></td>
          <td style="vertical-align: top;"><big>Collisions Max<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>0<br>
            </big></td>
          <td style="vertical-align: top;"><big>23739<br>
            </big></td>
          <td style="vertical-align: top;"><big>86<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>1<br>
            </big></td>
          <td style="vertical-align: top;"><big>10517<br>
            </big></td>
          <td style="vertical-align: top;"><big>21<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>5<br>
            </big></td>
          <td style="vertical-align: top;"><big>4<br>
            </big></td>
          <td style="vertical-align: top;"><big>2<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>6<br>
            </big></td>
          <td style="vertical-align: top;"><big>6<br>
            </big></td>
          <td style="vertical-align: top;"><big>2<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>11<br>
            </big></td>
          <td style="vertical-align: top;"><big>453<br>
            </big></td>
          <td style="vertical-align: top;"><big>4<br>
            </big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
      Хеширане на типове с плаваща точка<br>
    </big>
    <blockquote>
      <pre><big>int hashCode(const double&amp; x)       // hash a double<br>{ int len = sizeof(x);<br>  const char* p = reinterpret_cast&lt;const char *&gt;(&amp;x);<len i=""><br>  return hashCode(p, len);<br>}<br></len></big></pre>
    </blockquote>
    <a href="hash_code.cpp"><big><tt>hash_code.cpp</tt></big></a><br>
    <h4><big> Компресиращи изображения<br>
      </big></h4>
    <ul>
      <li>
        <big>Хеш кода за ключ <i>k</i> обикновено не е подходящ за
          незабавнo използване с употреба с </big><big><font size="+1">клетъчния&nbsp;</font>масив,


          тъй като интервалът от възможни хеш кодове за ключовете
          обикновено надвишава интервала за допустими индекси на масива.</big>
      </li>
    </ul>
    <big><span style="font-weight: bold;">Метод на деленето</span><br>
    </big>
    <ul>
      <li><big><span style="font-style: italic;">h</span><sub>2</sub>(<span
            style="font-style: italic;">y</span>) = | <span
            style="font-style: italic;">y</span> | mod <span
            style="font-style: italic;">N.</span></big></li>
      <li><big>Размерът <span style="font-style: italic;">N</span> на
          хеш таблицата обикновено се избира просто число.<span
            style="font-style: italic;"></span><br>
        </big></li>
      <li><big>Причината за това е свързана с теорията на числата и е
          извън обхвата на този курс.</big></li>
    </ul>
    <big><span style="font-weight: bold;"> Метод MAD</span><br>
      Умножи, събери и раздели (Multiply, Add and Divide - MAD):<br>
    </big>
    <ul>
      <li><big><span style="font-style: italic;">h</span><sub>2</sub>(<span
            style="font-style: italic;">y</span>) = <span
            style="font-style: italic;">|ay</span> + <span
            style="font-style: italic;">b</span>| mod <span
            style="font-style: italic;">N</span></big></li>
      <li><big><span style="font-style: italic;">a</span> и <span
            style="font-style: italic;">b</span> са неотрицателни числа,
          такива че <span style="font-style: italic;">a</span> mod <span
            style="font-style: italic;">N</span> ≠ 0.</big></li>
      <li><big>В противен случай, всяко число ще се изобразява в една и
          съща стойност <span style="font-style: italic;">b.</span></big></li>
    </ul>
    <big><span style="font-weight: bold;">Схеми за решаване на колизии</span><br>
    </big>
    <ul>
      <li><big><span style="font-style: italic;">Колизия </span>възниква,






          когато различни елементи трябва да се поставят в една и съща
          клетка.</big></li>
    </ul>
    <big><span style="font-weight: bold;">Самостоятелни вериги (separate
        chaining) <br>
      </span></big>
    <ul>
      <li><big>Верижно съставяне: нека всяка клетка от таблицата е адрес
          на първия елемент на свързан списък.</big></li>
      <li><big>Верижно съставяне е просто, но изисква допълнителна памет
          извън таблицата.</big></li>
    </ul>
    <big><span style="font-weight: bold;"><img style="width: 394px;
          height: 163px;" alt="" src="pic2.jpg"><br>
      </span><span style="font-weight: bold;">Подход на отворено
        адресиране<br>
      </span>Отворено адресиране: при колизия обектът се поставя в друга
      клетка на таблицата.<br>
      <br style="font-weight: bold;">
      <span style="font-weight: bold;">Линейно пробване (linear probing)</span><br>
    </big>
    <ul>
      <li><big>Линейното пробване решава колизиите като поставя обекта в
          следващата свободна (кръгово) клетка на таблицата.</big></li>
      <li><big>Всяка проверена клетка на таблицата се разглежда като
          "проба".</big></li>
      <li><big>Обектите с колизии се струпват, като следващите колизии
          предизвикват по-дълги редици от проби.</big></li>
      <li><big>Пример:<br>
        </big></li>
    </ul>
    <table style="text-align: left; width: 100%;" border="0"
      cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td style="vertical-align: top;"><big><img style="width:
                379px; height: 178px;" alt="" src="pic3.jpg"><br>
            </big></td>
          <td>
            <ul>
              <li><big><span style="font-style: italic;">h</span>(<span
                    style="font-style: italic;">x</span>) = <span
                    style="font-style: italic;">x</span> mod 13</big></li>
              <li><big>Добавяме ключове 18, 41, 22, 44, 59, 32, 31, 73 в
                  този ред.<br>
                </big></li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>
    <big><span style="font-weight: bold;"><br>
        Търсене с линейно пробване<br>
      </span></big>
    <table style="text-align: left; width: 100%;" border="0"
      cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td style="vertical-align: middle;">
            <ul>
              <li><big>Нека хеш таблицата <span style="font-style:
                    italic;">A</span> използва линейно пробване.</big></li>
              <li><big><span style="font-family: monospace;">find</span>(<span
                    style="font-style: italic;">k</span>)</big></li>
              <ul>
                <li><big>Започваме с клетка <span style="font-style:
                      italic;">h</span>(<span style="font-style:
                      italic;">k</span>).</big></li>
                <li><big>Пробваме последователни клетки, докато се появи
                    един от следните случаи:</big></li>
                <ul>
                  <li><big>обект с ключ <span style="font-style:
                        italic;">k</span> е намерен, или<br>
                    </big></li>
                  <li><big>достигната е празна клетка, или<br>
                    </big></li>
                  <li><big><span style="font-style: italic;">N</span>
                      клетки се пробвани без резултат.</big></li>
                </ul>
              </ul>
            </ul>
          </td>
          <td style="vertical-align: top; white-space: nowrap;"><big>Algorithm












              <span style="color: rgb(204, 0, 0);"><span
                  style="font-style: italic;">find</span>(<span
                  style="font-style: italic;">k</span>)</span><br>
              <span style="color: rgb(51, 102, 102);"><span
                  style="font-style: italic;">&nbsp;&nbsp; i</span> ←<span
                  style="font-style: italic;"> h</span>(<span
                  style="font-style: italic;">k</span>)</span><br
                style="color: rgb(51, 102, 102);">
              <span style="color: rgb(51, 102, 102);"><span
                  style="font-style: italic;">&nbsp;&nbsp; p</span> ← 0</span><br>
              &nbsp;&nbsp; repeat<br>
              <span style="color: rgb(51, 102, 102);"><span
                  style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;











                  c</span> ← <span style="font-style: italic;">A</span>[<span
                  style="font-style: italic;">i</span>]</span><br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if<span style="color:
                rgb(51, 102, 102);"> <span style="font-style: italic;">c</span>
                = ∅</span><br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              return <span style="color: rgb(51, 102, 102);"><span
                  style="font-style: italic;">Position</span>(<span
                  style="font-style: italic;">null</span></span>)<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if <span
                style="color: rgb(51, 102, 102);"><span
                  style="font-style: italic;">c.key</span>() = <span
                  style="font-style: italic;">k</span></span><br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              return <span style="color: rgb(51, 102, 102);"><span
                  style="font-style: italic;">Position</span>(<span
                  style="font-style: italic;">c</span>)</span><br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
              <span style="color: rgb(51, 102, 102);"><span
                  style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;











                  i</span> ← (<span style="font-style: italic;">i +</span>
                1) mod <span style="font-style: italic;">N</span></span><br
                style="color: rgb(51, 102, 102);">
              <span style="color: rgb(51, 102, 102);"><span
                  style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;











                  p</span> ← <span style="font-style: italic;">p +</span>
                1</span><br>
              &nbsp;&nbsp; until <span style="color: rgb(51, 102,
                102);"><span style="font-style: italic;">p</span> = <span
                  style="font-style: italic;">N</span></span><br>
              &nbsp;&nbsp; return <span style="color: rgb(51, 102,
                102);"><span style="font-style: italic;">Position</span>(<span
                  style="font-style: italic;">null</span>)</span><br>
            </big></td>
        </tr>
      </tbody>
    </table>
    <big><span style="font-weight: bold;"><br>
        Обновяване с линейно пробване<br>
      </span></big>
    <ul>
      <li><big>За да организираме вмъквания и изтривания, въвеждаме
          специален обект, наречен AVAILABLE, който замества изтритите
          обекти.</big></li>
      <li><big><span style="font-family: monospace;">removeElement</span>(<span
            style="font-style: italic;">k</span>)</big></li>
      <ul>
        <li><big>Търсим обект с ключ <span style="font-style: italic;">k.</span></big></li>
        <li><big>Ако обектът (<span style="font-style: italic;">k</span>,
            <span style="font-style: italic;">e</span>) е намерен, го
            заместваме със специалния обект AVAILABLE и връщаме
            позицията му.</big></li>
        <li><big>В противен случай връщаме nullposition.</big></li>
      </ul>
      <li><big><span style="font-family: monospace;">insertItem</span>(<span
            style="font-style: italic;">k</span>, <span
            style="font-style: italic;">e</span>)</big></li>
      <ul>
        <li><big>Ако таблицата е пълна, изхвърляме изключение.</big></li>
        <li><big>Започваме с клетка <span style="font-style: italic;">h</span>(<span
              style="font-style: italic;">k</span>). </big></li>
        <li><big>Пробваме последователно клетките докато се появи един
            от следните случаи:</big></li>
        <ul>
          <li><big>намерена е клетка <span style="font-style: italic;">i</span>,
              която е празна или съдържа AVAILABLE, или<br>
            </big></li>
          <li><big><span style="font-style: italic;">N</span> клетки са
              пробвани без резултат.</big></li>
        </ul>
        <li><big>Поставяме обекта (<span style="font-style: italic;">k</span>,
            <span style="font-style: italic;">e</span>) в клетка <span
              style="font-style: italic;">i.</span></big></li>
      </ul>
    </ul>
    <big><span style="font-weight: bold;"> </span><span
        style="font-weight: bold;">Двойно хеширане</span><br>
    </big>
    <ul>
      <li><big>Двойно хеширане използва втора хеш функция <span
            style="font-style: italic;">d</span>(<span
            style="font-style: italic;">k</span>) и обработва колизии
          чрез поставяне на обекта в първата свободна клетка от серията
          (<span style="font-style: italic;">i+ jd</span>(<span
            style="font-style: italic;">k</span>)) mod <span
            style="font-style: italic;">N</span> за <span
            style="font-style: italic;">j </span>= 0, 1, … , <span
            style="font-style: italic;">N</span> −1.</big></li>
      <li><big>Втората хеш функция <span style="font-style: italic;">d</span>(<span
            style="font-style: italic;">k</span>) не трябва да има
          нулеви стойности.</big></li>
      <li><big>Размерът <span style="font-style: italic;">N</span> на
          таблицата трябва да бъде просто число, за да може да се
          пробват всички клетки.</big></li>
      <li><big>За компресията на втората хеш функция обикновено се
          избира функцията <span style="font-style: italic;">d</span><sub>2</sub>(<span
            style="font-style: italic;">k</span>) = <span
            style="font-style: italic;">q − k</span> mod <span
            style="font-style: italic;">q</span> където<br>
        </big></li>
      <ul>
        <li><big><span style="font-style: italic;">q</span> &lt; <span
              style="font-style: italic;">N<br>
            </span></big></li>
        <li><big><span style="font-style: italic;">q</span> е просто
            число.<br>
          </big></li>
      </ul>
      <li><big>Възможни стойности на <span style="font-style: italic;">d</span><sub>2</sub>(<span
            style="font-style: italic;">k</span>) са 1, 2, … , <span
            style="font-style: italic;">q.</span></big></li>
      <li><big>Пример:</big></li>
    </ul>
    <big><br>
    </big>
    <table style="text-align: left; width: 100%;" border="0"
      cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td style="vertical-align: top;"><big><img style="width:
                379px; height: 413px;" alt="" src="pic4.jpg"><br>
            </big></td>
          <td style="vertical-align: middle;">
            <ul>
              <li><big>Разглеждаме хеш таблица за съхранение на
                  целочислени ключове, обработваща колизии с двойно
                  хеширане</big></li>
              <ul>
                <li><big><span style="font-style: italic;">N</span> = 13</big></li>
                <li><big><span style="font-style: italic;">h</span>(<span
                      style="font-style: italic;">k</span>) = <span
                      style="font-style: italic;">k</span> mod 13</big></li>
                <li><big><span style="font-style: italic;">d</span>(<span
                      style="font-style: italic;">k</span>) = 7 − <span
                      style="font-style: italic;">k</span> mod 7</big></li>
              </ul>
              <li><big>Въвеждат се ключове 18, 41, 22, 44, 59, 32, 31,
                  73, в този ред.</big></li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>
    <big><span style="font-weight: bold;"><span style="font-weight:
          bold;"></span></span><span style="font-weight: bold;"></span></big>
    <h4><big> Реализация на хеш-таблица със C++ <br>
      </big></h4>
    <big><a href="8.1_LinearProbeHashTable.h-HashEntry.html">html-8.1</a>
      (HashEntry)<br>
      <a href="8.2_LinearProbeHashTable.h-Position.html">html-8.2</a></big>
    <big>(Position)<br>
      <a href="8.3_LinearProbeHashTable.h-Hash1.html">html-8.3</a></big>
    <big> (Hash1)<br>
      <a href="8.4_LinearProbeHashTable.h-Hash2.html">html-8.</a></big>
    <big><a href="8.4_LinearProbeHashTable.h-Hash2.html">4</a> (Hash2)<br>
      <br>
      <a style="font-family: monospace;" href="hash.cpp">hash.cpp</a></big><span
      style="font-family: monospace;"> </span><big><span
        style="font-weight: bold;"><br>
        <hr style="width: 100%; height: 2px;">
        <h3>Наредени речници<br>
        </h3>
      </span>В нареден речник искаме освен обичайните операции за
      речник, да поддържа и такива, свързани с наредбата на ключовете.<br>
      <br>
      <span style="font-weight: bold;">Нареден речник АТД</span></big><span
      style="font-weight: bold;"> </span><big><span style="font-weight:
        bold;"></span><br>
      <br>
      Нареденият речник поддържа следните функции извън тези, включени в
      общия речник АТД:<br>
    </big>
    <ul>
      <li><big><span style="font-family: monospace;">closestBefore(k)</span>
          - Връща позиция на обект с най-голям ключ, по-малък или равен
          на <span style="font-family: monospace;">k.</span></big></li>
      <li><big><span style="font-family: monospace;">closestAfter(k)</span>
          - Връща позиция на обект с най-малкия ключ, по-голям или равен
          на <span style="font-family: monospace;">k.</span></big></li>
    </ul>
    <big><span style="font-weight: bold;">Lookup таблици</span><br>
    </big>
    <ul>
      <li><big>Lookup таблца е речник, реализиран с наредена редица.<span
            style="font-style: italic;"></span></big></li>
      <ul>
        <li><big>Ще съхраняваме обектите на речника в масив базирана
            редица АТД, сортирани по ключ. <br>
          </big></li>
        <li><big>Ще използваме външен компаратор за сравнение на
            ключовете.</big></li>
      </ul>
      <li><big>Performance:</big></li>
      <ul>
        <li><big><span style="font-family: monospace;">find</span>
            отнема време <span style="font-style: italic;">O</span>(log
            <span style="font-style: italic;">n</span>), като използваме
            двоично търсене.</big></li>
        <li><big><span style="font-family: monospace;">insertItem</span>
            отнема време <span style="font-style: italic;">O</span>(<span
              style="font-style: italic;">n</span>), защото в най-лошия
            случай преместваме <span style="font-style: italic;">n</span>/2





            обекта, за да направим място на новия обект.</big></li>
        <li>
          <big><span style="font-family: monospace;">removeElement</span>
            отнема време <span style="font-style: italic;">O</span>(<span
              style="font-style: italic;">n</span>),&nbsp; </big><big><big><font
                size="+1">защото в най-лошия случай преместваме <span
                  style="font-style: italic;">n</span>/2 обекта,</font>
            </big>за да запълним празното място след премахването.</big>
        </li>
      </ul>
      <li><big>Lookup таблицата е ефективна само за речници с малки
          размери, или за речници, на която търсенето са най-честата
          операция, докато вмъкване и отстраняване са рядко изпълнявани
          (например, оторизация на кредитни карти).<br>
        </big></li>
    </ul>
    <big><span style="font-weight: bold;">Двоично търсене</span><br>
    </big>
    <ul>
      <li><big>Двоичното търсене изпълнява операция <span
            style="font-family: monospace;">find</span>(<span
            style="font-style: italic;">k</span>) за речник, реализиран
          с масив-базирана редица, наредена по ключове:<br>
        </big></li>
      <ul>
        <li><big>на всяка стъпка броят на кандидатите се намалява
            наполовина;</big></li>
        <li><big>завършва за логаритмичен брой стъпки (относно
            големината на речника).</big></li>
      </ul>
      <li><big>Пример: <span style="font-family: monospace;">find</span>(7)</big></li>
    </ul>
    <big><img style="width: 718px; height: 225px;" alt="" src="pic5.jpg"><br>
      <a style="font-family: monospace;" href="bsearch.cpp">bsearch.cpp</a><br>
      <br>
      <span style="font-weight: bold;">Анализ на двоично търсене</span></big><big><br>
    </big>
    <ul>
      <li><big>Времето за изпълнение е пропорционално на числото <span
            style="font-style: italic;">k</span> на рекурсивните
          извиквания. </big></li>
      <li><big>Броят на оставащите кандидати се намалява най-малко
          наполовина с всяко рекурсивно извикване. </big></li>
      <li><big>В най-лошия случай (неуспешно търсене), рекурсията спира
          когато няма повече кандидати, т.е. <span style="font-style:
            italic;">n</span>/2<sup><span style="font-style: italic;">k</span></sup>
          = 1, <span style="font-style: italic;">k</span> = log <span
            style="font-style: italic;">n</span> и получаваме време за
          изпълнение <span style="font-style: italic;">O</span>(log <span
            style="font-style: italic;">n</span>).</big></li>
    </ul>
    <big><span style="font-weight: bold;"></span> <span
        style="font-weight: bold;">Сравнение на прости реализации на
        нареден речник АТД</span></big> <big><br>
      <br>
    </big>
    <table style="width: 100%; text-align: left;" border="1"
      cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td style="vertical-align: top;"><big>Function<br>
            </big></td>
          <td style="vertical-align: top;"><big>Log File<br>
            </big></td>
          <td style="vertical-align: top;"><big>Lookup Table<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>size(),











              isEmpty()<br>
            </big></td>
          <td style="vertical-align: top;"><big><span style="font-style:
                italic;">O</span>(1)<br>
            </big></td>
          <td style="vertical-align: top;"><big><span style="font-style:
                italic;">O</span>(1)<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>keys(),











              elements()<br>
            </big></td>
          <td style="vertical-align: top;"><big><span style="font-style:
                italic;">O</span>(<span style="font-style: italic;">n</span>)<br>
            </big></td>
          <td style="vertical-align: top;"><big><span style="font-style:
                italic;">O</span>(<span style="font-style: italic;">n</span>)<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>find(key)<br>
            </big></td>
          <td style="vertical-align: top;"><big><span style="font-style:
                italic;">O</span>(<span style="font-style: italic;">n</span>)<br>
            </big></td>
          <td style="vertical-align: top;"><big><span style="font-style:
                italic;">O</span>(log <span style="font-style: italic;">n</span>)<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>findAll(key)<br>
            </big></td>
          <td style="vertical-align: top;"><big>Theta(<span
                style="font-style: italic;">n</span>)<br>
            </big></td>
          <td style="vertical-align: top;"><big><span style="font-style:
                italic;">O</span>(log <span style="font-style: italic;">n
                + s</span>)<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>insertItem(key,











              element)<br>
            </big></td>
          <td style="vertical-align: top;"><big><span style="font-style:
                italic;">O</span>(1)<br>
            </big></td>
          <td style="vertical-align: top;"><big><span style="font-style:
                italic;">O</span>(<span style="font-style: italic;">n</span>)<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>removeElement(key)<br>
            </big></td>
          <td style="vertical-align: top;"><big><span style="font-style:
                italic;">O</span>(<span style="font-style: italic;">n</span>)<br>
            </big></td>
          <td style="vertical-align: top;"><big><span style="font-style:
                italic;">O</span>(<span style="font-style: italic;">n</span>)<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-family: monospace;"><big>removeAllElements()<br>
            </big></td>
          <td style="vertical-align: top;"><big>Theta(<span
                style="font-style: italic;">n</span>)</big></td>
          <td style="vertical-align: top;"><big><span style="font-style:
                italic;">O</span>(<span style="font-style: italic;">n</span>)<br>
            </big></td>
        </tr>
      </tbody>
    </table>
    <hr style="width: 100%; height: 2px;">
  </body>
</html>
