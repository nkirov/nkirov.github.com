<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>test3</title>
  </head>
  <body>
    Тест 3<br>
    <br>
    Отбележете верни/грешни твърдения за асимптотична оценка за следните
    функции: <br>
    (да) 2<i>n</i> + 3<i>n</i><sup>2</sup> e <i>O</i>(<i>n</i><sup>2</sup>)<br>
    (не) <i>n</i> + <i>n</i><sup>2</sup> e <i>O</i>(<i>n</i>)<br>
    <br>
    Дадени са следните дефиниции:<br>
    <font size="+1"><tt>&nbsp;i = 4, j = 2, k = 1;</tt></font> <br>
    Определете дали коментарът е стойност на израза. <br>
    (да) <font size="+1"><tt>i -= j // 2</tt></font> <br>
    (не) <font size="+1"><tt>j *= -j // -2</tt></font><br>
    <br>
    Посочете верни/неверни дефиниции и твърдения за търсещи дървета. <br>
    (да) Търсене в AVL дърво с <i>n</i> члена отнема време <i>O</i>(log











    <i>n</i>). <br>
    (не) Височината на AVL дърво, съдържащо <i>n</i> ключа е <i>O</i>(<i>n</i>).<br>
    <br>
    Дадено е (2,4) дърво АТД: T = {12}({3,6,9},{15}). Външните възли не
    са включени в представянето. Определете дали даденото след
    съответната операция (2,4)-дърво е получено като резултат от
    прилагане на операцията.<br>
    (да) <font size="+1"><tt>insertItem(1)</tt></font> -
    T={6,12}({1,3}, {9},{15})<br>
    (не) <font size="+1"><tt>insertItem(1) </tt></font>-
    T={3,12}({1,6,9},{15})<br>
    <br>
    <meta name="qrichtext" content="1">
    Дадено е <i>червено</i>-<b>черно</b> дърво АТД, като <b>черните</b>
    възли са <b>bold</b>, а <i>червените</i> - <i>italic</i>.
    Външните възли не са включени в представянето. Определете дали
    даденото след операцията <i>червено</i>-<b>черно</b> дърво е
    получено като резултат от прилагане на операцията. <br>
    (да) <b>6</b>(<i>8</i>) - <font size="+1"><tt>insertItem(7)</tt></font>
    - <b>7</b>(<i>6</i>,<i>8</i>) (не) <b>5</b>(<i>7</i>) - <font
      size="+1"><tt>insertItem(6)</tt></font> - <b>5</b>(<i>6</i>,<i>7</i>)
    <br>
    <br>
    Прост алгоритъм за разрешаване на колизии в хеш таблици e линейно
    пробване. Даден е клетъчен масив <br>
    &nbsp;&nbsp;&nbsp; A = { 35,14,D,21,E,12,E } <br>
    с капацитет N=7, където E означава empty и D означава available
    елемент на масива. Хеш функцията e <i>h</i>(<i>k</i>) = <i>k</i>
    mod 7. Посочете верни/неверни съответствия, като след -&gt; е дадено
    предполагаемото място на добавения елемент в масива. <br>
    (да) <font size="+1"><tt>insrtItem(7)</tt></font> -&gt; A[2] = 7 <br>
    (не) <font size="+1"><tt>insrtItem(18)</tt></font> -&gt; A[5] = 18<br>
    <br>
    Дадено е двоично дърво АТД: <br>
    &nbsp;&nbsp; <font size="+1"><tt>T =
        a(b(c(d,e),f),g(h,i(j(k,l),m)). </tt></font><br>
    Дали дадената редица е част от редицата от възли, получена чрез
    Ойлерово обхождане на двоичното дърво? <br>
    (да) <font size="+1"><tt>abcd </tt></font><br>
    (не) <font size="+1"><tt>bcde </tt></font><br>
    <br>
    Да се построи двоично дърво, представящо следния аритметичен израз:
    <br>
    <font size="+1"><tt>&nbsp; (x + 2*(y - 2)) / 2. </tt></font><br>
    Дали дадената редица е част от редицата от възли, получена чрез
    preorder обхождане на двоичното дърво? <br>
    (да) <font size="+1"><tt>/ + x </tt></font><br>
    (не) <font size="+1"><tt>2 - 2</tt></font><br>
    <br>
    Даден е стек АТД: <br>
    &nbsp;&nbsp; <font size="+1"><tt>S = (5,3,4,9). </tt></font><br>
    Върхът на стека е <font size="+1"><tt>5</tt></font>. Посочете
    вярно/невярно съответствие "функция -- върната стойност -- стека S"
    след изпълнението на функцията. <br>
    (да) <font size="+1"><tt>push(1) </tt></font>-- NONE -- <font
      size="+1"><tt>S=(1,5,3,4,9) </tt></font><br>
    (не) <font size="+1"><tt>push(10)</tt></font> -- NONE -- <font
      size="+1"><tt>S=(5,3,4,9,10)</tt></font><br>
    <br>
    Дадена е опашка АТД: <br>
    &nbsp;&nbsp; <font size="+1"><tt>Q = (8,7,2). </tt></font><br>
    Начало на опашката е елементът 8. Посочете вярно/невярно
    съответствие "функция -- върната стойност -- опашката Q" след
    изпълнението на функцията. <br>
    (да) <font size="+1"><tt>enqueue(5) -- NONE -- Q=(8,7,2,5) </tt></font><br>
    (не) <font size="+1"><tt>enqueue(7) -- 7 -- Q=(8,7,2,7) </tt></font><br>
    <br>
    Даден е дек АТД: <br>
    &nbsp;&nbsp; <font size="+1"><tt>D = (8,1,3). </tt></font><br>
    Начало на дека е елементът 8. Посочете вярно/невярно съответствие
    "функция -- върната стойност -- декът D" след изпълнението на
    функцията. <br>
    (да) <font size="+1"><tt>insertFirst(5) -- NONE -- D =(5,8,1,3) </tt></font><br>
    (не)<font size="+1"><tt> insertFirst(6) -- NONE -- D =(8,6,1,3) </tt></font><br>
    <br>
    Дадено е AVL дърво: <br>
    <font size="+1"><tt>&nbsp; 44(17(-,32),78(50(48,62),88)). </tt></font><br>
    Външните възли не са включени в представянето. Определете дали
    даденото след операцията AVL дърво е получено като резултат от
    прилагане на операцията. <br>
    (да) <font size="+1"><tt>insertItem(54)
        44(17(-,32),62(50(48,54),78(-,88))) </tt></font><br>
    (не) <font size="+1"><tt>removeItem(32) 44(17,78(50(48,62),88))</tt></font><br>
    <br>
    Дадено е двоично дърво. Да се провери дали редицата след ; е част от
    inorder обхождане на дървото.&nbsp; <br>
    (да) <font size="+1"><tt>c(b(a,d),e) ; bdc </tt></font><br>
    (не) <font size="+1"><tt>a(b,c(d(f,g),e)) ; cfe </tt></font><br>
    <br>
    Да се построи двоично дърво, представящо дадения аритметичен израз и
    да се провери дали редицата <font size="+1"><tt>x2y</tt></font> e
    част от postorder обхождане на полученото дърво. <br>
    (да) <font size="+1"><tt>(x+2*(y-2))/2</tt></font> <br>
    (не) <font size="+1"><tt>(x-2)*y </tt></font><br>
    <br>
    Класът <font size="+1"><tt>Position</tt></font> e включен в
    дефиницията на класа <font size="+1"><tt>BinarySearchTree</tt></font>
    (Code Fragment 9.2). Отбележете верни/неверни твърдения за
    член-функцията <br>
    <font size="+1"><tt>Element&amp; element() </tt><tt><br>
      </tt><tt>{ </tt><tt><br>
        &nbsp; </tt><tt>return btPos.element().element(); </tt><tt><br>
      </tt><tt>} </tt><tt><br>
      </tt><tt>от class Position. </tt></font><br>
    (да) Върнатата стойност е псевдоним на член-данна на класа <font
      size="+1"><tt>Item</tt></font>. <br>
    (не) Функцията е рекурсивна. <br>
    <br>
    Посочете верните и неверни дефиниции и твърдения за линейни
    структури от данни. <br>
    (да) Премахването на елемент от всеки край на двойно свързан списък
    се извършва за време <i>O</i>(1). <br>
    (не) Опашка е контейнер от обекти, които се добавят и изваждат в
    съответствие с принципа LIFO -- "последен влязъл, пръв излязъл". <br>
    <br>
    Отбележете верни/грешни дефиниции за асимптотична нотация. <br>
    (да) <i>f</i>(<i>n</i>) e <i>O</i>(<i>g</i>(<i>n</i>)), ако има
    положителни константи <i>c</i> и <i>N</i>, такива, че <i>f</i>(<i>n</i>)<cg(n)
      за="" n=""> &lt; <i>c</i> <i>g</i>(<i>n</i>) за <i>n</i> &gt; <i>N</i>.
      <br>
      (не) <i>g</i>(<i>n</i>) e <i>O</i>(<i>f</i>(<i>n</i>)), ако има
      положителни константи <i>c</i> и <i>N</i>, такива, че <i>f</i>(<i>n</i>)<cg(n)$
        за="" всяко="" $n="">&nbsp; &lt;&nbsp; <i>c</i> <i>g</i>(<i>n</i>)
        за <i>n</i> &gt; <i>N</i>. <br>
        <br>
        Даден е следния код: <br>
        <font size="+1"><tt>void fun1() { throw runtime_error("ERR" ); }
          </tt><tt><br>
          </tt><tt> void fun2() throw(runtime_error) { ... } </tt><tt><br>
          </tt><tt>void fun3() throw(runtime_error) { fun2(); } </tt><tt><br>
          </tt><tt>int main() </tt><tt><br>
          </tt><tt>{ </tt><tt><br>
            &nbsp; </tt><tt>try </tt><tt><br>
            &nbsp; </tt><tt>{ fun3(); } </tt><tt><br>
            &nbsp; </tt><tt>catch (runtime_error e)<br>
            &nbsp; </tt><tt>{ cout &lt;&lt; e.what(); }<br>
            &nbsp; </tt><tt>return 0; </tt><tt><br>
          </tt><tt>} </tt></font><br>
        Като заместим <font size="+1"><tt>...</tt></font> с дадения
        оператор, дали <font size="+1"><tt>ERR</tt></font> ще се
        отпечата на екрана? <br>
        (да) <font size="+1"><tt>fun1(); </tt></font><br>
        (не) <font size="+1"><tt>fun2(); </tt></font><br>
        <br>
        Посочете верните/неверните дефиниции и твърдения за дървета. <br>
        (да) Ако възел u е родител на възел v, казваме, че v е дете на
        u. <br>
        (не) Всеки възел в двоично дърво има родител и нула, едно или
        две деца. <br>
        <br>
        Класът <font size="+1"><tt>BinarySearchTree</tt></font> съдържа
        следната член-функция (Code Fragment 9.3): <br>
        <font size="+1"><tt>void setItem(const BTPosition&amp; p, const
            BSTItem&amp; i) const </tt><tt><br>
          </tt><tt>{ </tt><tt><br>
          </tt><tt>&nbsp; /*add*/ </tt><tt><br>
          </tt><tt>&nbsp; p.element().setKey(i.key()); </tt><tt><br>
          </tt><tt>&nbsp; p.element().setElement(i.element()); </tt><tt><br>
          </tt><tt>}
          </tt></font><br>
        Отбележете верни/неверни твърдения за тази функция.
        <br>
        (да) Функцията поставя<font size="+1"><tt> Item</tt></font> от
        BST (речник) на позиция <font size="+1"><tt>p</tt></font> в <font
          size="+1"><tt>LinkedBinaryTree</tt></font>.
        <br>
        (не) Като заместим <font size="+1"><tt>/*add*/</tt></font> с <font
          size="+1"><tt>p.eNull(); </tt></font>получаваме синтактична
        грешка.<br>
        <hr size="2" width="100%"><br>
      </cg(n)$></cg(n)>
  </body>
</html>
