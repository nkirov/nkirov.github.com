<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="GENERATOR" content="Mozilla/4.75 [en] (Win98; U)
      [Netscape]">
    <title>Тest 3</title>
  </head>
  <body>
    <center>
      <h3>ТЕСТ 3<br>
      </h3>
      <b>въпросите на теста, един верен отговор (да), и един грешен
        "отговор" (не)</b> </center>
    Дадени са следните дефиниции: <tt><br>
      <br>
      int b[3] = {10, 20, 30};</tt> <tt><br>
      int* pb = b;</tt><br>
    <br>
    Посочете с "да" изразите със стойност 30.<br>
    <br>
    (да) <tt>b[0] + b[1]</tt> <br>
    (не) <tt>*pb</tt>
    <hr size="2" width="100%">
    Отбележете с "да" операторите за дефиниране на обекти и указатели
    към обекти от класовете <tt>Time</tt> и <tt>Employee</tt>, дадени
    в учебника на К. Хорстман (Chapter 3).<br>
    <br>
    (да) <tt>Time* t = new Time(); </tt><br>
    (не) <tt>Employee* e = new Employee()</tt>;
    <br>
    <hr size="2" width="100%">Нека класът <tt>D</tt> наследява класа <tt>B</tt>,
    <tt>b</tt> е обект от класа <tt>B</tt>,&nbsp; <tt>d </tt>е обект
    от класа <tt>D</tt>, <tt>pb</tt> е указател от класа <tt>B</tt> и
    <tt>pd</tt> е указател от класа <tt>D</tt>. Кои от следните
    оператори са верни и кои - не?<br>
    <br>
    (да) <tt>b = d;</tt><br>
    (не) <tt>d = b;</tt><br>
    <hr size="2" width="100%">
    Дадени са следните дефиниции на класове:
    <br>
    <br>
    <tt>class Employee {</tt><br>
    <tt> ... <br>
      };</tt><br>
    <tt> class Manager : public Employee {</tt><br>
    <tt> ... <br>
      };</tt>
    <br>
    <br>
    Определете верните и неверните твърдения. <br>
    <br>
    (да) Класът <tt>Employee</tt> е базов клас и класът <tt>Manager</tt>
    е производен клас.
    <br>
    (не) Класът <tt>Manager</tt> е базов клас и класът <tt>Employee</tt>
    е производен клас.
    <hr size="2" width="100%">
    Дадени са следните дефиниции: <tt><br>
      <br>
      ifstream inp;</tt> <tt> <br>
      ofstream out;</tt> <tt> <br>
      int k = 100;</tt> <tt> <br>
      char ch = 'Z';</tt> <tt> <br>
      <br>
      const double PIN = 5.55;</tt>
    <br>
    Отбележете правилните и неправилните оператори относно синтаксис. <br>
    <br>
    (да) <tt>inp.get(ch);</tt>
    <br>
    (не) <tt>inp.get(PIN);</tt>
    <hr size="2" width="100%">
    Отбележете с "да" случаите, когато дадената редица от цифри
    съответства на дадения вход на програмата. <tt><br>
      <br>
      int dig(int n)</tt> <tt> { <br>
      cout &lt;&lt; n;</tt> <tt> <br>
      if (n &gt; 9) return dig(n/10) + 1;</tt> <tt> <br>
      else return 1; </tt> <tt> <br>
      }</tt> <tt> <br>
      <br>
      int main()</tt> <tt> <br>
      { <br>
      int k; <br>
      cin &gt;&gt; k;</tt>
    <br>
    <tt> cout &lt;&lt; dig(k);</tt> <tt> <br>
      return 0;</tt>
    <br>
    <tt> }</tt> <br>
    <br>
    Означението е: &lt;входно число&gt; -&gt; &lt;изходна редица&gt;. <br>
    <br>
    (да) 122 -&gt; 1221213<br>
    (не) 13 -&gt; 1332
    <hr size="2" width="100%">Отбележете верни и грешни твърдения
    относно сортиране и търсене.<br>
    <br>
    (да) За метода сортиране чрез избор удвояване на броя на елементите
    води до четирикратно учеличаване на времето за сортиране.<br>
    (не) За метода сортиране чрез сливане удвояване на броя на
    елементите води до четирикратно учеличаване на времето за сортиране.<br>
    <hr size="2" width="100%">
    Даден е свързан списък и итератор от Стандартаната библиотека с
    шаблони (STL):
    <tt><br>
      <br>
      list&lt;int&gt; slist;</tt>
    <br>
    <tt> list&lt;int&gt;::iterator lit;</tt>
    <br>
    <br>
    Списъкът съдържа 10 елементи и итераторът сочи втория елемент. Верен
    ли е даденият израз? <br>
    <br>
    (да) <tt>*lit &gt; 0<br>
    </tt>(не) <tt>slist++</tt>
    <hr size="2" width="100%"> Може ли даденият ред от програма да бъде
    дефиниция на деструктор? <br>
    <br>
    (да) <tt>Department::~Department() {}</tt> <br>
    (не) <tt>Dep::~Dep(int i) { cout &lt;&lt; i; }</tt><br>
    <hr size="2" width="100%">Възможно ли е да се предефинира следващата
    операция за обекти от класа <tt>Time</tt>, като използваме следната
    декларация на обикновена функция?<br>
    <br>
    (не) <tt>bool operator&gt;(Time);</tt><br>
    (да) <tt>long operator-(Time, Time); </tt><br>
    <hr size="2" width="100%">Възможно ли е да се предефинира следващата
    операция за обекти от класа <tt>Time</tt>, като използваме следната
    декларация на член-функция?<br>
    <br>
    (да) <tt>bool Time::operator==(Time);</tt><br>
    (не)<tt> istream&amp; Time::operator&gt;&gt;(Time&amp;);</tt><br>
    <hr size="2" width="100%"> Отбележете верни/неверни твърдения за
    предефиниране на операции и шаблони. <br>
    <br>
    (да) Клас-шаблон е механизъм, който позволява да се създават
    класове, чиито членове данни са от произволен тип.
    <br>
    (не) Функцията <tt>operator=</tt> може да не бъде член-функция.
    <br>
    <hr size="2" width="100%">Нека е даден следния клас-шаблон:
    <br>
    <br>
    <tt>template </tt><typename t=""><tt>
        class Temp {
      </tt><tt><br>
      </tt><tt>public:
      </tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp; </tt><tt>Temp(T t) { data = new T(t);
        }
      </tt><tt><br>
      </tt><tt>private: </tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp; </tt><tt>T* data;
      </tt><tt><br>
      </tt><tt>};
      </tt><br>
      <br>
      Може ли в класа да се добави деклaрация/дефиниция на следната
      функция: <br>
      <br>
      (да) <tt>T get() const { return *data; }
      </tt><br>
      (не) <tt>Temp go();</tt>
      <br>
      <hr size="2" width="100%">Дадена е следната част от програма:<br>
      <br>
      <tt>void fun3() <br>
        { <br>
        &nbsp;&nbsp;&nbsp; throw runtime_error("RTE" ); <br>
        }<br>
        void fun2() throw(runtime_error) <br>
        { <br>
        &nbsp;&nbsp;&nbsp; // блок на функциятя<br>
        }<br>
        void fun1() throw(runtime_error) <br>
        { <br>
        &nbsp;&nbsp;&nbsp; fun2(); <br>
        } <br>
        int main()<br>
        { <br>
        try <br>
        { <br>
        &nbsp;&nbsp;&nbsp; fun1(); <br>
        }<br>
        catch (runtime_error e) <br>
        { <br>
        &nbsp;&nbsp;&nbsp; cout&lt;&lt;e.what(); <br>
        }<br>
        return 0; <br>
        }</tt><br>
      Поставете в блока на функцията f<tt>un2</tt> дадения оператор или
      дадените оператори и отбележете с "да" случая на отпечатване на
      съобщение <tt>RTE</tt> при изпълнението на програмата.
      <br>
      <br>
      (да) <tt>fun3();</tt><br>
      (не) <tt>fun1();</tt><br>
      <hr width="100%">Дадена е част от програма:<br>
      <br>
      <tt>class Vec {<br>
        public:<br>
        &nbsp;&nbsp; class Range {<br>
        &nbsp;&nbsp; public:<br>
        &nbsp;&nbsp;&nbsp;&nbsp; int index;<br>
        &nbsp;&nbsp;&nbsp;&nbsp; Range(int j):index(j) {} <br>
        &nbsp;&nbsp; };<br>
        &nbsp;&nbsp; int&amp; operator[](int i)<br>
        &nbsp;&nbsp; { <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (0&lt;=i &amp;&amp;
        i&lt;100) return p[i]; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw Range(i); <br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; ... <br>
        };<br>
        void do_any(Vec&amp; w);<br>
        void do_some(Vec&amp; w);<br>
        void f(Vec&amp; v)<br>
        { <br>
        &nbsp; do_any(v);<br>
        &nbsp; try <br>
        &nbsp; { <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do_some(v); <br>
        &nbsp; }<br>
        &nbsp; catch(Vec::Range r)<br>
        &nbsp; { <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cerr &lt;&lt; "ERROR" &lt;&lt;
        r.index; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... <br>
        &nbsp; }<br>
        &nbsp; ...<br>
        }</tt><br>
      <br>
      Верни ли са следните твърдения?<br>
      <br>
      (да) <tt>r</tt> е обект от тип <tt>Vec::Range</tt>.<br>
      (не) <tt>r</tt> е обект от тип <tt>Range.</tt>
      <hr width="100%"> </typename>
  </body>
</html>
