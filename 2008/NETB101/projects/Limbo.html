<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>~Atanas Todorov F38900 -  LIMBO Programming ~</title>
</head>

<body>

<p align="center"><b><font face="Arial" size="6">LIMBO PROGRAMMING</font></b></p>
<p align="center"><font face="Arial" size="2">NETB131 Programming Project</font><b><font face="Arial" size="2">
</font></b></p>
<p align="center"><font face="Arial" size="2">Atanas Todorov, F38900</font></p>
<hr>
<p align="center"><font face="Arial"><b>History and Special Features</b></font></p>
<p align="left"><b><font face="Arial" size="2">    </font>
</b><font size="2" face="Arial">It was designed at Bell Labs by Sean Dorward, Phil 
Winterbottom, and Rob Pike. Limbo is a programming language intended for 
applications running distributed systems on small computers. It supports modular 
programming, strong type checking at compile- and run-time, interprocess 
communication over typed channels, automatic garbage collection, and simple 
abstract data types. It is designed for safe execution even on small machines 
without hardware memory protection.<br>
    In its initial implementation for the Inferno operating system, object 
programs generated by the Limbo compiler run using an interpreter for a fixed 
virtual machine. Inferno and its accompanying virtual machine run either 
stand-alone on bare hardware or as an application under conventional operating 
systems like Unix, Windows 95, Windows NT, and Plan 9. For several architectures, 
including Intel x86 and MIPS, Limbo object programs are transformed on-the-fly 
into instructions for the underlying hardware. Limbo's approach to concurrency 
was inspired by Hoare's Communicating Sequential Processes (CSP).</font></p>
<hr>
<p align="center"><b><font face="Arial">"Hello World" Program</font></b></p>
<dl>
	<dd><tt>
	<div align="left">
		<pre><font size="2" face="Arial">1	implement Command;

2	include "sys.m";</font></pre>
		<pre><font size="2" face="Arial">3	include "draw.m";

4	sys:	Sys;

5	Command: module
	{
6	    init: fn (ctxt: ref Draw-&gt;Context, argv: list of string);
7	};
</font></pre>
	</div>
	</tt></dd>
</dl>
<dl>
	<div align="left">
		<dt>
<font size="2" face="Arial">  </font> </dt>
	</div>
	<dd><tt>
	<div align="left">
		<pre><font size="2" face="Arial">8	# The canonical "Hello world" program, enhanced
9	init(ctxt: ref Draw-&gt;Context, argv: list of string)
10	{
11		sys = load Sys Sys-&gt;PATH;
12		sys-&gt;print("hello world\n");
13		for (; argv!=nil; argv = tl argv)
14			sys-&gt;print("%s ", hd argv);
15		sys-&gt;print("\n");
16	}
</font></pre>
	</div>
	</tt></dd>
</dl>
<p align="center"> </p>
<hr>
<p align="center"><b>Fundamental Data Types</b></p>
<p align="center"><b> (integer, floating point, string) 
</b></p>
<p align="center"><b>and Assignment Operator</b></p>
<p align="left"><font size="2"><br>
<br>
</font><font face="Arial"><b><font size="2">The five basic data types are denoted by byte, int, 
big, real, and string</font></b><font size="2">.<br>
<br>
Bytes are unsigned 8-bit quantities.<br>
<br>
Integers (int) are 32-bit signed quantities represented in two's complement 
notation. Large integers (big) are 64-bit signed quantities represented in two's 
complement notation.<br>
<br>
Real numbers (real) are 64-bit quantities represented in the IEEE long floating 
notation.<br>
<br>
The byte, int, big, and real types are collectively called arithmetic types.<br>
<br>
Strings are rows of Unicode characters. They may be concatenated and extended 
character-by-character. When a string is indexed with a single subscript, it 
yields an integer with the Unicode encoding of the character; when it is indexed 
by a range, it yields another string.</font></font></p>
<p align="left"><b><font face="Arial" size="2">Tuple type</font></b></p>
<p align="left"><font face="Arial" size="2">The tuple type, is a type consisting of an 
ordered collection of two or more objects, each having its own data type. For 
each tuple type, the types of the members are fixed, but need not be identical; 
for example, a function might return a tuple containing an integer and a string. 
Each tuple type is characterized solely by the the order and identity of the 
types it contains. Objects of tuple type may be assigned to a list of 
identifiers (to pick out the components), and a parenthesized, comma-separated 
list of expressions denotes a tuple.</font></p>
<p align="left"><b><font face="Arial" size="2">Abstract data types (adt)</font></b></p>
<p align="left"><font face="Arial" size="2">An abstract data type or adt is an object 
that can contain data objects of several different types and declare functions 
that operate on them. The syntax for declaring an adt is given later. Once an 
adt has been declared, the identifier associated with it becomes a data-type 
name.</font></p>
<p align="left"><b><font face="Arial" size="2">Assignment Operator</font></b></p>
<p align="left"><font face="Arial"><font size="2">In general, the types of the left and right 
operands must be the same; this type must be a data type. The value of an 
assignment is its new left operand. All the assignment operators associate 
right-to-left.<br>
<br>
In the ordinary assignment with =, the value of the right side is assigned to 
the object on the left. For simple assignment only, the left operand may be a 
parenthesized list of lvalues and the right operand either a tuple or an adt 
whose data members correspond in number and type to the lvalues in the list. The 
members of the tuple, or the data members of the adt, are assigned in sequence 
to lvalues in the list. For example,<br>
<br>
<u><i><b>p: Point;  <br>
x, y: int;   (like int x, y; in C++)<br>
(x, y) = p;<br>
</b></i></u><br>
splits out the coordinates of the point into x and y. These rules apply 
recursively, so that if one of the components of the left side is a 
parenthesized list of lvalues, it is assigned from a corresponding adt or tuple 
on the right.<br>
<br>
If the left operand of a simple assignment is an adt and the right side is a 
tuple, then the assignment assigns the members of the tuple to the adt data 
members; these must correspond in number and type with the members of the tuple.<br>
<br>
The constant nil may be assigned to an lvalue of any reference type. This lvalue 
will compare equal to nil until it is subsequently reassigned. In the Inferno 
implementation of Limbo, such an assignment also triggers the removal of the 
object referred to unless other references to it remain.<br>
<br>
The left operand of an assignment may be the constant nil to indicate that a 
value is discarded. This applies in particular to any of the lvalues in a tuple 
appearing on the left; to extend the examples above,<br>
<br>
</font>
<u><i><b><font size="2">(x, nil) = p;</font></b></i></u><font size="2"><br>
<br>
assigns the x member of the Point p to the variable x.<br>
<br>
A special consideration applies to strings. If an int containing a Unicode 
character is assigned to a subscripted string, the subscript is normally 
required to lie within the string. As a special case, the subscript's value may 
be equal to the length of the string (that is, just beyond its end); in this 
case, the character is appended to the string, and the string's length increases 
by 1.<br>
<br>
A final special case applies to array slices in the form e1[e2:]. Such 
expressions may lie on the left of =. The right side must be an array of the 
same type as e1, and its length must be less than or equal to (len e1)-e2. In 
this case, the elements in the array on the right replace the elements of e1 
starting at position e2. The length of the array is unchanged. </font> </font></p>
<hr>
<p align="center"><b><font face="Arial">Basic Control Flow (conditional 
and loop statements)</font></b></p>
<p align="left"><b><font size="2"><br>
</font><font size="2" face="Arial">The conditional statement takes two 
forms:<br>
<br>
<u><i>if ( expression ) statement<br>
if ( expression ) statement else statement<br>
</i></u></font></b><font size="2" face="Arial"><br>
The expression is evaluated; it must have type int. If it is non-zero, then the 
first statement is executed. In the second form, the second statement is 
executed if the expression is 0. The statement after else is connected to the 
nearest else-less if.</font></p>
<p align="left"><font face="Arial"><font size="2"><br>
</font>
<b><font size="2">Simple looping statements:</font></b></font></p>
<p align="left"><font face="Arial" size="2">The simple looping statements are<br>
<br>
<u><i><b>while ( expressionopt ) statement<br>
do statement while ( expressionopt ) ;<br>
</b></i></u><br>
In both cases the expression must be of type int. In the first form, the 
expression is first tested against 0; while it is not equal, the statement is 
repeatedly executed. In the second form, the statement is executed, and then, 
while the expression is not 0, the statement is repeatedly executed. If the 
expression is missing, it is understood to be non-zero.</font></p>
<p align="left"><font face="Arial"><b><font size="2">The for statement has the 
form</font></b><font size="2"><br>
<br>
 <u><i><b>for ( expression-1opt ; expression-2opt ; expression-3opt ) statement</b></i></u><br>
<br>
It is equivalent to<br>
<br>
<u><i><b>expression-1 ;<br>
while ( expression-2 ) {<br>
statement<br>
expression-3 ;<br>
}</b></i></u><br>
<br>
in the absence of continue or break statements. Thus (just as in C), the first 
expression is an initialization, the second a test for starting and continuing 
the loop, and the third a re-initialization for subsequent travels around the 
loop.</font></font></p>
<p align="left"><font face="Arial" size="2">Task: Input an integer number n and output 
the sum: 1+22+32+...+n2. Use input validation for n to be positive:</font></p>
<hr>
<p align="left"><font face="Arial" size="2">implement Command;<br>
<br>
include "sys.m";<br>
include "draw.m";<br>
<br>
sys : Sys;<br>
<br>
<br>
Command: module<br>
{<br>
init: fn(nil: ref Draw-&gt;Context, nil: list of string);<br>
};<br>
<br>
init(*,*)<br>
{<br>
sys = load Sys Sys-&gt;PATH;<br>
outfile := "outputfile";<br>
outfd: ref Sys-&gt;FD;<br>
sys-&gt;create(outfile, sys-&gt;ORDWR, 8r755);<br>
sys-&gt;print("ENTER NUMBER:");<br>
outfd = sys-&gt;open(outfile, sys-&gt;ORDWR);<br>
buf := array[1] of byte;<br>
sys-&gt;write(outfd, buf, len buf);<br>
n := sys-&gt;read(outfd,buf,len buf);<br>
if ( n &lt;= 0 ) <br>
break;<br>
else <br>
{<br>
sum:int = 0;<br>
for (i:int = 1; i &lt;= n; i++) sum = sum + pow(i,2);<br>
}<br>
sys-&gt;print("The number is: %d\n",sum);<br>
<br>
return;<br>
}</font></p>
<hr>
<p align="center"><b><font face="Arial">Functions - syntax, writing and using 
functions, example</font></b></p>
<p align="left"> </p>
<p align="left"><font face="Arial"><b><font size="2">Function types<br>
<br>
</font>
</b><font size="2">A function type characterizes the arguments and return value of a function. 
The syntax is<br>
<br>
<u><i><b>function-type:<br>
fn function-arg-ret<br>
<br>
function-arg-ret:<br>
( formal-arg-listopt )<br>
( formal-arg-listopt ) : data-type<br>
<br>
formal-arg-list:<br>
formal-arg<br>
formal-arg-list , formal-arg<br>
<br>
formal-arg:<br>
nil-or-D-list : type<br>
nil-or-D : self refopt identifier<br>
nil-or-D : self identifier<br>
*<br>
nil-or-D-list:<br>
nil-or-D<br>
nil-or-D-list , nil-or-D<br>
<br>
nil-or-D:<br>
identifier<br>
nil</b></i></u><br>
<br>
    That is, the denotation of a function type has the keyword fn followed by a 
comma-separated list of its arguments enclosed in parentheses, and perhaps 
followed by the type the function returns. Absence of a return value means that 
the function returns no value: it is a procedure. The names and types of 
arguments are specified. However, the name of an argument may be replaced by nil; 
in this case it is nameless. For example,<br>
<br>
<u><i><b>fn (nil: int, nil: int): int<br>
fn (radius: int, angle: int): int<br>
fn (radius, angle: int): int</b></i></u><br>
<br>
all denote exactly the same type, namely a function of two integers that returns 
an integer. As another example,<br>
<br>
<u><i><b>fn (nil: string)<br>
</b></i></u><br>
is the type of a function that takes a string argument and returns no value.<br>
<br>
    The self keyword has a specialized use within adt declarations. It may be 
used only for the first argument of a function declared within an adt; its 
meaning is discussed in §6.3 below.<br>
<br>
    The star character * may be given as the last argument in a function type. 
It declares that the function is variadic; during a call, actual arguments at 
its position and following are passed in a manner unspecified by the language. 
For example, the type of the print function of the Sys module is<br>
<br>
<u><i><b>fn (s: string, *): int</b></i></u><br>
<br>
    This means that the first argument of print is a string and that other 
arguments may be given when the function is called. The Limbo language itself 
has no way of accessing these arguments; the notation is an artifice for 
describing facilities built into the runtime system, such as the Sys module.</font></font></p>
<hr>
<p align="center"><b><font face="Arial">Arrays</font></b></p>
<p align="left"> </p>
<p align="left"><font face="Arial" size="2">    The array type describes a 
dynamically-sized row of objects, all of the same type; it is indexed starting 
from 0. An array type is denoted by<br>
 </font></p>
<p align="left"><font face="Arial" size="2"><u><i><b>array of data-type</b></i></u><br>
<br>
    The size of an array is not part of its type; instead it is part of the 
value. The data-type may itself be an array, to achieve a multidimensional 
array.</font></p>
<p align="left"><font face="Arial" size="2">In the expressions<br>
<br>
<u><b><i>array [ expression ] of data-type<br>
array [ expressionopt ] of { init-list ,opt }</i></b></u><br>
<br>
the value is a new array of the specified type. In both forms, the expression 
must be of type int, and it supplies the size of the array. In the first form, 
the type is given, and the values in the array are initialized as appropriate to 
the underlying type. In the second form, a comma-separated list of values to 
initialize the array is given, optionally followed by a trailing comma. The type 
of the array is taken from the types of the initializers, which must all be the 
same. The list of initializers has the syntax<br>
<br>
<u><i><b>init-list:<br>
element<br>
init-list , element<br>
<br>
element:<br>
expression<br>
expression =&gt; expression<br>
* =&gt; expression<br>
</b></i></u><br>
<br>
    In an init-list of plain expressions (without =&gt;), the members of the array 
are successively initialized with the corresponding elements of the init-list. 
An element of the form e1=&gt;e2 initializes the member of the array at subscript 
e1 with the expression e2. After such an element has been given, subsequent 
simple elements (without =&gt;) begin initializing at position e1+1 and so on. Each 
of the first expressions must be of type int and must evaluate to a constant .<br>
<br>
    If an element of the form * =&gt;e2 is present, all members of the array not 
otherwise initialized are set to the value e2. The expression e2 is evaluated 
for each subscript position, but in an undefined order. For example,<br>
<br>
<u><i><b>arr := array[3] of { * =&gt; array[3] of { * =&gt; 1 } };<br>
</b></i></u><br>
yields a 2-dimensional array (actually an array of arrays) filled with 1's.<br>
<br>
    If the expression giving the size of the array is omitted, its size is taken 
from the largest subscript of a member explicitly initialized. It is erroneous 
to initialize a member twice. </font></p>
<p align="left"><font face="Arial" size="2"><br>
The line<br>
<br>
<u><i><b>buf := array[1] of byte;<br>
</b></i></u><br>
declares buf to be a one-element array of bytes. Arrays are indexed from zero, 
so buf[0] is the only element. Arrays in Limbo are dynamic, so this array is 
created at the point of the declaration.</font></p>
<hr>
<p align="center"><font face="Arial"><b>Compilers</b></font></p>
<p align="left"><font face="Arial" size="2"><b><a href="http://sourceforge.net/projects/acheron-l">The 
Acheron Limbo Compiler </a></b></font></p>
<p align="left"><font face="Arial" size="2">This is a port of the Dis virtual machine 
system to POSIX-compatible operating systems, based on the original Inferno 
sources, including a Limbo compiler. The port is intended to make the virtual 
machine and runtime environment more general and easily ex.</font></p>
<hr>
<p align="center"><b><font face="Arial">Projects and Software in LIMBO</font></b></p>
<p align="left"><font face="Arial" size="2">All Inferno applications are written in 
Limbo. Life is made easier for the programmer with features such as automatic 
garbage collection, compile and runtime type checking and simple creation of 
multiple processes (threads) and communication between them. Inferno also comes 
with a graphical debugger, allowing the user to step into the program at any 
point and browse through the current state.</font></p>
<p align="left"> </p>
<p align="left"><font face="Arial" size="2">
<a href="http://www.alcatel-lucent.com/wps/portal/NewsReleases/DetailLucent?LMSG_CABINET=Docs_and_Resource_Ctr&amp;LMSG_CONTENT_FILE=News_Releases_LU_1997/LU_News_Article_006117.xml">
 Lucent Technologies introduces Inferno 1.0; real-time network operating system 
provides powerful platform for business applications development</a></font></p>
<hr>
<p align="center"><b><font face="Arial">References</font></b></p>
<p align="left"><font face="Arial" size="2">1.Limbo programming</font><b><font face="Arial" size="2">
</font></b><font face="Arial" size="2">from
<a href="http://en.wikipedia.org/wiki/Limbo_(programming_language)">
www.wikipedia.com</a></font></p>
<p align="left"><font face="Arial" size="2">2.<a href="http://doc.cat-v.org/inferno/4th_edition/limbo_language/descent">A 
Descent into Limbo</a> by Brian Kernighan</font></p>
<p align="left"><font face="Arial" size="2">3.<a href="http://www.cs.rit.edu/~ats/inferno/limbo/">The Limbo 
Programming Language </a> Copyright © 1996, 1997 Lucent Technologies Inc. All 
rights reserved.</font></p>
<p align="left"><font face="Arial" size="2">4.<a href="http://www.alcatel-lucent.com/wps/portal/BellLabs">Bell 
Labs</a> </font> </p>
<p align="center"> </p>

</body>

</html>
