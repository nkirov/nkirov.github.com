<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:o="urn:schemas-microsoft-com:office:office"
 xmlns:w="urn:schemas-microsoft-com:office:word"
 xmlns:st1="urn:schemas-microsoft-com:office:smarttags"
 xmlns="http://www.w3.org/TR/REC-html40">
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="ProgId" content="Word.Document">
  <meta name="Generator" content="Microsoft Word 10">
  <meta name="Originator" content="Microsoft Word 10">
  <link rel="File-List"
 href="file:///C:/Documents%20and%20Settings/Kristian/Desktop/Programming%20Language%20CLIPS.files/filelist.xml">
  <title>NETB131 Programming Project -- Groovy -- Lazar -- F39654</title>
  <o:smarttagtype
 namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="PlaceType"></o:smarttagtype> <o:smarttagtype
 namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="PlaceName"></o:smarttagtype><o:smarttagtype
 namespaceuri="urn:schemas-microsoft-com:office:smarttags" name="place"></o:smarttagtype><!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Kristian</o:Author>
  <o:Template>Normal</o:Template>
  <o:LastAuthor>Kristian</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>4</o:TotalTime>
  <o:Created>2008-01-04T23:11:00Z</o:Created>
  <o:LastSaved>2008-01-04T23:15:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>4016</o:Words>
  <o:Characters>22895</o:Characters>
  <o:Company>Home</o:Company>
  <o:Lines>190</o:Lines>
  <o:Paragraphs>53</o:Paragraphs>
  <o:CharactersWithSpaces>26858</o:CharactersWithSpaces>
  <o:Version>10.2625</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:Zoom>85</w:Zoom>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if !mso]><object
 classid="clsid:38481807-CA0E-42D2-BF39-B33AF135CC4D" id=ieooui></object>
<style>
st1\:*{behavior:url(#ieooui) }
</style>
<![endif]-->
  <style>
<!--
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p
	{mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
@page Section1
	{size:595.3pt 841.9pt;
	margin:70.85pt 70.85pt 70.85pt 70.85pt;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
  </style><!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"\041D\043E\0440\043C\0430\043B\043D\0430 \0442\0430\0431\043B\0438\0446\0430";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0in 5.4pt 0in 5.4pt;
	mso-para-margin:0in;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";}
</style>
<![endif]-->
</head>
<body style="" lang="EN-US" link="blue" vlink="blue">
<div class="Section1">
<p><a name="top"><b>NETB131 Programming Project <br>
Programming language CLIPS<br>
An overview</b><br>
<br>
</a><br>
Kristian Ognianov Bojinov, F39091</p>
<p>Navigation:<br>
1. <a href="#HSF">History and Special Features</a><br>
2. <a href="#HWP">"Hello World" Program</a><br>
3. <a href="#FDT">Fundamental Data Types and Assignment Operators</a><br>
4. <a href="#BCF">Basic Control Flow</a><br>
5. <a href="#Functions">Functions</a><br>
6. <a href="#Arrays">Arrays</a><br>
7. <a href="#Compilers">Compilers</a><br>
8. <a href="#PSG">Projects and software in Groovy</a><br>
9. <a href="#Standard">Standard</a><br>
10. <a href="#References">References</a> <br>
<br>
<br>
<a name="HSF"></a><big><span style="text-decoration: underline;">1.
History and Special Features</span> </big>(<a href="#top">^</a>)<br>
The origins of the C Language Integrated
Production System
(CLIPS) date back to 1984 at NASA's <st1:place><st1:placename>Johnson</st1:placename>
<st1:placename>Space</st1:placename> <st1:placetype>Center</st1:placetype></st1:place>.
At this time, the Artificial Intelligence Section (now the Software
Technology
Branch) had developed over a dozen prototype expert systems
applications using
state- of- the- art hardware and software. However, despite extensive
demonstrations of the potential of expert systems, few of these
applications
were put into regular use. This failure to provide expert systems
technology
within NASA's operational computing constraints could largely be traced
to the
use of LISP as the base language for nearly all expert system software
tools at
that time. In particular, three problems hindered the use of LISP based
expert
system tools within NASA: the low availability of LISP on a wide
variety of
conventional computers, the high cost of state- of- the- art LISP tools
and
hardware, and the poor integration of LISP with other languages (making
embedded applications difficult).<br>
The Artificial Intelligence Section felt that the use of a
conventional
language, such as C, would eliminate most of these problems, and
initially
looked to the expert system tool vendors to provide an expert system
tool
written using a conventional language. Although a number of tool
vendors
started converting their tools to run in C, the cost of each tool was
still
very high, most were restricted to a small variety of computers, and
the
projected availability times were discouraging. To meet all of its
needs in a
timely and cost effective manner, it became evident that the Artificial
Intelligence Section would have to develop its own C based expert
system tool. The prototype version of CLIPS was developed in the spring
of 1985
in a
little over two months. Particular attention was given to making the
tool
compatible with expert systems under development at that time by the
Artificial
Intelligence Section. Thus, the syntax of CLIPS was made to very
closely
resemble the syntax of a subset of the ART expert system tool developed
by
Inference Corporation. Although originally modelled from ART, CLIPS was
developed
entirely without assistance from Inference or access to the ART source
code.The original intent of the prototype was to gain useful insight
and
knowledge about the construction of expert system tools and to lay the
groundwork for the construction of a fully usable tool. The CLIPS
prototype had
numerous shortcomings, however, it demonstrated the feasibility of the
project
concept. After additional development, it became apparent that
sufficient
enhancements to the prototype would produce a low cost expert system
tool that
would be ideal for the purposes of training. Another year of
development and
internal use went into CLIPS improving its portability, performance,
and
functionality. A reference manual and user's guide were written during
this time.
The first release of CLIPS to groups outside of NASA, version 3.0,
occurred in
the summer of 1986.Further enhancements transformed CLIPS from a
training tool into a
tool
useful for the development and delivery of expert systems as well.
Versions 4.0
and 4.1 of CLIPS, released respectively in the summer and fall of 1987,
featured greatly improved performance, external language integration,
and
delivery capabilities. Version 4.2 of CLIPS, released in the summer of
1988,
was a complete rewrite of CLIPS for code modularity. Also included with
this
release were an architecture manual providing a detailed description of
the
CLIPS software architecture and a utility program for aiding in the
verification and validation of rule- based programs. Version 4.3 of
CLIPS,
released in the summer of 1989, added still more
functionality.Originally, the primary representation methodology in
CLIPS was a
forward
chaining rule language based on the Rete algorithm (hence the
Production System
part of the CLIPS acronym). Version 5.0 of CLIPS, released in the
spring of
1991, introduced two new programming paradigms: procedural programming
(as
found in languages such as C and Ada) and object- oriented programming
(as
found in languages such as the Common Lisp Object System and
Smalltalk). The
object- oriented programming language provided within CLIPS is called
the CLIPS
Object- Oriented Language (COOL). Version 5.1 of CLIPS, released in the
fall of
1991, was primarily a software maintenance upgrade required to support
the
newly developed and/or enhanced X Window, MS- DOS, and Macintosh
interfaces.Because of its portability, extensibility, capabilities, and
low-
cost,
CLIPS has received widespread acceptance throughout the government,
industry,
and academia. The development of CLIPS has helped to improve the
ability to
deliver expert system technology throughout the public and private
sectors for
a wide range of applications and diverse computing environments. CLIPS
is being
used by over 4,000 users throughout the public and private community
including:
all NASA sites and branches of the military, numerous federal bureaus,
government contractors, universities, and many private companies. CLIPS
is
available at a nominal cost through COSMIC, the NASA software
distribution
center (for more on COSMIC, see appendix E of the Basic Programming
Guide).</p>
<p class="MsoNormal" style="margin-bottom: 12pt;"><o:p></o:p><a
 name="HWP"></a><big style="text-decoration: underline;">2. "Hello
World" Program </big>(<a href="#top">^</a>)
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <br>
CAIT&gt; (clear) <br>
CAIT&gt; (defmodule MAIN (export deftemplate ?ALL)) <br>
CAIT&gt; (defrule MAIN::initial-rule =&gt; (assert (temp))) <br>
CAIT&gt; (defmodule toto (import MAIN deftemplate ?ALL)) <br>
CAIT&gt; (defrule toto::example (temp) =&gt; (printout t "Hello
World")) <br>
CAIT&gt; (reset) <br>
CAIT&gt; (agenda MAIN) <br>
0 initial-rule: f-0 <br>
For a total of 1 activation. <br>
CAIT&gt; (agenda toto) <br>
CAIT&gt; (run 1) <br>
CAIT&gt; (agenda toto) <br>
0 example: f-1 <br>
For a total of 1 activation. <br>
CAIT&gt; </p>
<div style="margin-left: 30pt;">
</div>
<p><a name="FDT"></a>3. <big style="text-decoration: underline;">Fundamental
Data Types (float, integer, symbol,
string,
externaladdress, factaddress, instancename<b> </b>and<b> </b>instanceaddress)
and Assignment Operators </big>(<a href="#top">^</a>)<br>
CLIPS provides eight primitive data types for representing
information.
These types are float, integer, symbol, string, externaladdress,
factaddress,
instancename<b> </b>and<b> </b>instanceaddress. Numeric information
can be
represented using floats and integers. Symbolic information can be
represented
using symbols and strings.<br>
A <b>number</b> consists <i>only</i> of digits (0- 9), a decimal
point (.),
a sign (+ or - ), and, optionally, an (e) for exponential notation with
its
corresponding sign. A number is either stored as a float or an integer.
Any
number consisting of an optional sign followed by only digits is stored
as an
integer (represented internally by CLIPS as a C long integer). All
other
numbers are stored as float<b>s</b> (represented internally by CLIPS as
a C
double- precision float). The number of significant digits will depend
on the
machine implementation. Roundoff errors also may occur, again depending
on the
machine implementation. As with any computer language, care should be
taken
when comparing floating- point values to each other or comparing
integers to
floating- point values. Some examples of integers are<br>
237 15 +12 -32.Some examples of floats are 237e3 15.09 +12.0
-32.3e-7.Specifically, integers use the following
format:&lt;integer&gt; ::= [+ | -] &lt;digit&gt;+&nbsp; &lt;digit&gt;
::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9<br>
Floating point numbers use the following format:&lt;float&gt; ::=
&lt;integer&gt; &lt;exponent&gt; |&lt;integer&gt; . [exponent]&nbsp; .
&lt;unsigned integer&gt; [exponent] &lt;integer&gt; . &lt;unsigned
integer&gt; [exponent] &lt;unsigned-integer&gt; ::= &lt;digit&gt;+
&lt;exponent&gt; ::= e | E &lt;integer&gt;<br>
A sequence of characters which does not exactly follow the format of
a
number is treated as a symbol (see the next paragraph).<br>
A symbol in CLIPS is any sequence of characters that starts with any
printable
ASCII character and is followed by zero or more printable ASCII
characters.
When a delimiter is found, the symbol is ended. The following
characters act as
delimiter<b>s</b>: any non- printable ASCII character (including
spaces, tabs,
carriage returns, and line feeds), a double quote, opening and closing
parentheses "(" and ")", an ampersand "&amp;", a
vertical bar "|", a less than "&lt;", and a tilde
"~". A semicolon ";" starts a CLIPS comment and also acts
as a delimiter. Delimiters may not be included in symbols with the
exception of
the "&lt;" character which may be the first character in a symbol. In
addition, a symbol may not begin with either the "?" character or the
"$?" sequence of characters (although a symbol may contain these
characters). These characters are reserved for variables. CLIPS is case
sensitive (i.e. uppercase letters will match only uppercase letters).
Note that
numbers are a special case of symbols (i.e. they satisfy the definition
of a
symbol, but they are treated as a different data type). Some simple
examples of
symbols are<br>
foo Hello B76-HI bad_value<br>
127A 456-93-039 @+=-% 2each<br>
A string is a set of characters that starts with a double quote (")
and
is followed by zero or more printable characters. A string ends with
double
quotes. Double quotes may be embedded within a string by placing a
backslash
(\) in front of the character. A backslash may be embedded by placing
two
consecutive backslash characters in the string. Some examples are<br>
"foo" "a and b" "1 number"
"a\"quote"<br>
An externaladdress is the address of an external data structure
returned by
a function (written in a language such as C or Ada) that has been
integrated
with CLIPS. This data type can only be created by calling a function
(i.e. it
is not possible to specify an external- address by typing the value).
In the
basic version of CLIPS (which has no user defined external functions),
it is
not possible to create this data type. External- addresses are
discussed in
further detail in the Advanced Programming Guide. Within CLIPS, the
printed
representation of an external- address is<br>
&lt;Pointer-XXXXXX&gt; where XXXXXX is the external- address.<br>
An instance is an object<b> </b>that is an instantiation or
specific example
of a class. Objects in CLIPS are defined to be floats, integers,
symbols,
strings, multifield values, externaladdresses, factaddresses or
instances of a
user- defined class. A userdefined class is created using the defclass
construct. An instance of a user- defined class is created with the
makeinstance
function, and such an instance can be referred to uniquely by address.
Within
the scope of a module an instance can also be uniquely referred to by
name. An
instancename is formed by enclosing a symbol within left and right
brackets.
Thus, pure symbols may not be surrounded by brackets. If the CLIPS
Object
Oriented Language (COOL) is not included in a particular CLIPS
configuration, then
brackets may be wrapped around symbols. Some examples of instance-
names are:<br>
[pump-1] [foo] [+++] [123-890].In CLIPS, a placeholder that has a value
(one of the primitive data
types)
is referred to as a field. The primitive data types are referred to as
singlefield value<b>s</b>. A constant is a non- varying single field
value
directly expressed as a series of characters (which means that
externaladdresses, factaddresses and instanceaddresses cannot be
expressed as
constants because they can only be obtained through function calls and
variable
bindings). A multifield value is a sequence of zero or more single
field
values. When displayed by CLIPS, multifield values are enclosed in
parentheses.
Collectively, single and multifield values are referred to as value<b>s</b>.
Some examples of multifield values are<br>
(1 bar foo) () (x 3.0 "red" 567) </p>
<div style="text-align: justify;">
</div>
<div style="text-align: justify;"></div>
<div style="text-align: justify;"></div>
<div style="text-align: justify;"></div>
<p><a name="BCF"></a><big style="text-decoration: underline;">4. Basic
Control Flow (conditional and loop
statements)</big> (<a href="#top">^</a>)<br>
DEFINING RULES<br>
Rules are defined using the defrule construct.<br>
Syntax<br>
(defrule &lt;rule-name&gt; [&lt;comment&gt;]<br>
[&lt;declaration&gt;] ; Rule Properties<br>
&lt;conditional-element&gt;* ; Left-Hand Side (LHS)<br>
&lt;action&gt;*) ; Right-Hand Side (RHS)<br>
Redefining a currently existing defrule causes the previous defrule
with the
same name to be removed even if the new definition has errors in it.
The LHS is made up
of a
series of conditional elements (CEs) which typically consist of pattern
conditional elements
(or just
simply patterns) to be matched against pattern entities. An implicit
and conditional
element
always surrounds all the patterns on the LHS. The RHS contains a list
of actions to be
performed
when the LHS of the rule is satisfied. In addition, the LHS of a rule
may also contain
declarations
about the rule&#8217;s properties immediately following the rule&#8217;s name and
comment . The
arrow
(=&gt;) separates the LHS from the RHS. There is no limit to the number
of conditional elements or actions a rule may have. Actions are
performed
sequentially if, and only if, all conditional elements on the LHS are
satisfied. If no conditional elements are on the LHS, the pattern CE
(initial-fact) or
(initial-object) is automatically used. If no actions are on the RHS,
the rule can be
activated and
fired but nothing will happen. As rules are defined, they are
incrementally reset. This means that CEs
in
newly defined rules can be satisfied by pattern entities at the time
the rule is defined,
in
addition to pattern entities created after the rule is defined <br>
Example<br>
(defrule example-rule "This is an example of a simple rule"<br>
(refrigerator light on)<br>
(refrigerator door open)<br>
=&gt;<br>
(assert (refrigerator food spoiled)))<br>
&nbsp;BASIC CYCLE OF RULE EXECUTION<br>
Once a knowledge base (in the form of rules) is built and the fact-list
and
instance-list is prepared, CLIPS is ready to execute rules. In a
conventional language,
the
starting point, the stopping point, and the sequence of operations are
defined explicitly
by the
programmer. With CLIPS, the program flow does not need to be defined
quite so
explicitly. The
knowledge (rules) and the data (facts and instances) are separated, and
the inference
engine
provided by CLIPS is used to apply the knowledge to the data. The basic
execution cycle is
as
follows:<br>
a) If the rule firing limit has been reached or there is no current
focus, then
execution is halted.<br>
Otherwise, the top rule on the agenda of the module which is the
current focus
is selected<br>
for execution. If there are no rules on that agenda, then the current
focus is
removed from<br>
the focus stack and the current focus becomes the next module on the
focus
stack. If the<br>
focus stack is empty, then execution is halted, otherwise step a is
executed
again. <br>
b) The right-hand side (RHS) actions of the selected rule are executed.
The use
of the return<br>
function on the RHS of a rule may remove the current focus from the
focus stack
The number of rules fired is incremented for use with the rule<br>
firing limit.<br>
c) As a result of step b, rules may be activated or deactivated.
Activated
rules (those rules<br>
whose conditions are currently satisfied) are placed on the agenda of
the
module in which<br>
they are defined. The placement on the agenda is determined by the
salience of
the rule and<br>
the current conflict resolution strategy .<br>
&nbsp; Defrule Construct<br>
comparisons that must be performed on the LHS of the rule. Each
comparison to a
constant or previously bound variable adds one to the specificity. Each
function
call made
on the LHS of a<br>
rule as part of the :, =, or test conditional element adds one to the
specificity. The boolean functions and, or, and not do not add to the
specificity of a rule, but
their
arguments do. Function calls made within a function call do not add to
the
specificity of a
rule. For example,the following rule<br>
(defrule example)<br>
(item ?x ?y ?x)<br>
(test (and (numberp ?x) (&gt; ?x (+ 10 ?y)) (&lt; ?x 100)))<br>
has a specificity of 5. The comparison to the constant item, the
comparison of
?x to its previous binding, and the calls to the numberp, &lt;, and
&gt; functions each
add one to
the specificity for a<br>
total of 5. The calls to the and and + functions do not add to the
specificity
of the rule.<br>
MEA Strategy<br>
Among rules of the same salience, newly activated rules are placed
using the
OPS5 strategy of the same name. First the time tag of the pattern
entity associated with
the
first pattern is used to<br>
determine where to place the activation. An activation thats first
pattern&#8217;s time tag is greater than another activations first pattern&#8217;s
time tag is placed before the other
activation on the agenda. If<br>
both activations have the same time tag associated with the first
pattern, then
the LEX strategy is used to determine placement of the activation.
Again, as with the CLIPS
LEX
strategy, negated<br>
patterns have pseudo time tags. As an example, the following six
activations have been listed in their
MEA
ordering (where the comma at the end of the activation indicates the
presence of a negated
pattern).<br>
(defrule rule-1<br>
(factoid a)<br>
(assert (factoid b)))<br>
(defrule rule-2<br>
?f &lt;- (factoid a)<br>
(factoid d)<br>
(retract ?f)<br>
(assert (factoid c)))<br>
Pattern Conditional Element Pattern conditional elements consist of a
collection of field
constraints,
wildcards, and variables which are used to constrain the set of facts
or instances
which match
the pattern CE. A pattern CE is satisfied by each and every pattern
entity that satisfies
its
constraints. Field constraints are a set of constraints that are used
to test a single
field or
slot of a pattern entity. A<br>
field constraint may consist of only a single literal constraint,
however, it
may also consist of<br>
(deffacts data-facts<br>
(data 1.0 blue "red")<br>
(data 1 blue)<br>
(data 1 blue red)<br>
(data 1 blue RED)<br>
(data 1 blue red 6.9))<br>
(deftemplate person<br>
(slot name)<br>
(slot age)<br>
(multislot friends))<br>
(deffacts people<br>
(person (name Joe) (age 20))<br>
(person (name Bob) (age 20))<br>
(person (name Joe) (age 34))<br>
(person (name Sue) (age 34))<br>
(person (name Sue) (age 20)))<br>
<a name="Functions"></a><big style="text-decoration: underline;">5.
Functions</big> (<a href="#top">^</a>)<br>
A function in CLIPS is a piece of executable code identified by a
specific name
which returns a useful value or performs a useful side effect (such as
displaying information). Throughout the CLIPS documentation, the word
function
is generally used to refer only to functions which return a value
(whereas
commands and actions are used to refer to functions which have a side
effect
but generally do not return a value). There are several types of
functions. <b>User defined </b>function<b>s</b>
and <b>system
defined </b>function<b>s</b> are pieces of code that have been written
in an
external language (such as C, FORTRAN, or Ada) and linked with the
CLIPS
environment. System defined functions are those functions that have
been
defined internally by the CLIPS environment. User defined functions are
functions that have been defined externally of the CLIPS environment. A
complete list of system defined functions can be found in appendix I.
The deffunction construct allows users to define new functions directly
in the
CLIPS environment using CLIPS syntax. Functions defined in this manner
appear
and act like other functions, however, instead of being directly
executed (as
code written in an external language would be) they are interpreted by
the
CLIPS environment. Generic functions can be defined using the
defgeneric and defmethod
constructs.
Generic functions allow different pieces of code to be executed
depending upon
the arguments passed to the generic function. Thus, a single function
name can
be overload<b>ed</b> with more than one piece of code.Function calls in
CLIPS use a prefix notation - the arguments to a
function
always appear after the function name. Function calls begin with a left
parenthesis, followed by the name of the function, then the arguments
to the
function follow (each argument separated by one or more spaces).
Arguments to a
function can be primitive data types, variables, or another function
call. The
function call is then closed with a right parenthesis. Some examples of
function calls using the addition (+) and multiplication (*) functions
are
shown following.<br>
(+ 3 4 5)<br>
(* 5 6.0 2)<br>
(+ 3 (* 8 9) 4)<br>
(* 8 (+ 3 (* 2 3 4) 9) (* 3 4))<br>
While a function refers to a piece of executable code identified by a
specific
name, an expression refers to a function which has its arguments
specified
(which may or may not be functions calls as well). Thus the previous
examples
are expressions which make calls to the * and + functions. Information
about
the function in CLIPS can be found <a
 href="http://phlips.sourceforge.net/documentation.php">here</a><br>
<big style="text-decoration: underline;"><b style="">Task</b></big>:<span
 class="postbody">Input
an integer number n and output the sum: 1+2^2+3^2+...+n^2. </span><br>
<span class="postbody">Use input validation for n to be positive. </span><br>
(defun power (x y) (if (= y 0) 1 (* x (power x (1- y))))) <br>
(defun sumpow (x y) (if (&lt; x 1) 0 (+ (power x y) (power (1- x) y))))<br>
<a name="Arrays"></a><big style="text-decoration: underline;">6. Arrays</big>
(<a href="#top">^</a>)<br>
An example of array With CLIPSActiveXControl1 <br>
DataGrid.Cols =3D 14 <br>
DataGrid.Rows =3D .NumberOfFacts + 1 <br>
For FactCount =3D 1 To .NumberOfFacts <br>
RowCount =3D RowCount + 1 <br>
.NextFact <br>
For SlotCount =3D 1 To 12 <br>
If ParseDeftemplateName(.FactString)=3D "Dogs" Then = <br>
'ParseDeftemplateName grabs the deftemp name of the current fact <br>
'now the program should fill in the slots for all of the dogs <br>
DataGrid.Row =3D RowCount <br>
DataGrid.Col =3D SlotCount <br>
DataGrid.Text =3D .GetSlotValue(.InstancePtr, = <br>
SlotName(SlotCount)) 'slotname is an array of the names of slots <br>
End If <br>
Next SlotCount <br>
.NextFact <br>
Next FactCount <br>
End With<br>
<a name="Compilers"></a><big style="text-decoration: underline;">7.
Compilers</big> (<a href="#top">^</a>)<br>
There is a new release for Windows called CLIPS
6.3 Beta.You
can find it on the <a href="http://www.ghg.net/clips/download/">download
area</a>
on the CLIPS homepage.And there is also CLIPS Java Native Interface 0.1
Beta.<br>
Version 0.1 demonstrates basic techniques for integrating CLIPS with
a GUI
and comes with three examples of CLIPS programs integrated with a Swing
front
end.<br>
<a name="PSG"></a><big style="text-decoration: underline;">8. Projects
and software in CLIPS</big> (<a href="#top">^</a>)<br>
All the information needed for the CLIPS projects can be found on
the CLIPS <a href="http://www.ghg.net/clips/CLIPS.html">webpage</a>
When tou subscribe in the google group for CLIPS you can enter the
CLIPS
projects and find more about the software written on CLIPS.<br>
<a name="Standard"></a><big style="text-decoration: underline;">9.
Standard</big> (<a href="#top">^</a>)<br>
CLIPS was made to very closely resemble the syntax of a subset of
the ART
expert system tool developed by Inference Corporation. Although
originally
modelled from ART, CLIPS was developed entirely without assistance from
Inference or access to the ART source code.CLIPS is portable,
extensible,
capable, and low- cost language.<br>
<a name="References"></a><big style="text-decoration: underline;">10.
References </big>(<a href="#top">^</a>)<br>
CLIPS on <a
 href="http://www.comp.rgu.ac.uk/staff/smc/teaching/clips/vol1/">http://www.comp.rgu.ac.uk/staff/smc/teaching/clips/vol1/</a><br>
CLIPS on <a href="http://en.wikipedia.org/wiki/CLIPS">Wikipedia</a><br>
CLIPS <a href="http://www.ghg.net/clips/download/documentation/">documentation</a></p>
</div>
</body>
</html>
