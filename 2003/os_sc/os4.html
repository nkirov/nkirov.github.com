<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <meta name="Author" content="Nikolay Kirov">
   <meta name="GENERATOR" content="Mozilla/4.75 [en] (Win98; U) [Netscape]">
   <title>os4</title>
</head>
<body>

<h2>
Операционни системи</h2>

<h3>
4 (5). Конкуренция: взаимно изключване и синхронизация</h3>
    Централни теми при изграждане на ОС:
<br>  - многопрограмна работа;
<br>  - многопроцесорна работа;
<br>  - разпределени процеси.
<br>    Конкуренция на процеси - 3 различни аспекта:
<br>  - много на брой активни приложения едновременно;
<br>  - структурирани приложения - за повишаване на ефективността
някои приложения се програмират като множества от конкурентни процеси;
<br>  - структурата на ОС - често като множество от конкурентни процеси.
<p><b>5.1 Принципи на конкуренцията.</b>
<br>    Пример.
<br>    Процесите <b><tt>P1</tt></b> и <b><tt>P2</tt></b>
използват обща "ехо" функция (напр. за отпечатване на екрана на натиснат
клавиш) - без и със защита на функцията. ОС може да прекъсва изпълнението
на функцията след всеки оператор.
<br><b><tt><font color="#000099">char chin, chout;</font></tt></b>
<br><b><tt><font color="#000099">void echo()</font></tt></b>
<br><b><tt><font color="#000099">{</font></tt></b>
<br><b><tt><font color="#000099">  getchar(chin);</font></tt></b>
<br><b><tt><font color="#000099">  chout = chin;</font></tt></b>
<br><b><tt><font color="#000099">  putchar(chout);</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<br><font color="#000000">    От клавиатурата на  </font><b><tt><font color="#003300">P1
</font></tt></b><font color="#000000">се
въвежда '<b><tt>A</tt></b>', а от клавиатурата на <b><tt>P2</tt></b> -
'<b><tt>B</tt></b>'. </font>Възможни са следните сценарии за изпълнение
на процесите <b><tt>P1</tt></b> и <b><tt>P2</tt></b>, които използват функцията
"ехо".
</p>
<p>  <b>А. Без защита : </b>ОС може да прекъсва изпълнението на функцията
след всеки оператор.
<br> 
</p>
<table border="0" cellpadding="4">
<tr>
<td>
<b><font color="#003300">// <tt>PROCESS P1</tt></font></b>
<br><b><tt><font color="#000099">void echo()</font></tt></b>
<br><b><tt><font color="#000099">{</font></tt></b>
<br><b><tt><font color="#000099">  getchar(chin);</font></tt></b>
<br><b><tt><font color="#000099">................</font></tt></b>
<br><b><tt><font color="#000099">................</font></tt></b>
<br><b><tt><font color="#000099">  chout = chin;</font></tt></b>
<br><b><tt><font color="#000099">  putchar(chout);</font></tt></b>
<br><b><tt><font color="#000099">.................</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
</td>

<td>
<b><font color="#003300">// <tt>PROCESS P2</tt></font></b>
<br><b><tt><font color="#000099">void echo()</font></tt></b>
<br><b><tt><font color="#000099">{</font></tt></b>
<br><b><tt><font color="#000099">...............</font></tt></b>
<br><b><tt><font color="#000099">  getchar(chin);</font></tt></b>
<br><b><tt><font color="#000099">  chout = chin;</font></tt></b>
<br><b><tt><font color="#000099">...............</font></tt></b>
<br><b><tt><font color="#000099">...............</font></tt></b>
<br><b><tt><font color="#000099">  putchar(chout);</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
</td>

<td>v<b><tt>alue of chin</tt></b>
<br><b><tt>...</tt></b>
<br><b><tt>...</tt></b>
<br><b><tt>...</tt></b>
<br><b><tt>A</tt></b>
<br><b><tt>B</tt></b>
<br><b><tt>B</tt></b>
<br><b><tt>B</tt></b>
<br><b><tt>B</tt></b>
</td>

<td>
<b><tt>value of chout</tt></b>
<br><b><tt>...</tt></b>
<br><b><tt>...</tt></b>
<br><b><tt>...</tt></b>
<br><b><tt>...</tt></b>
<br><b><tt>B</tt></b>
<br><b><tt>B</tt></b>
<br><b><tt>B</tt></b>
<br><b><tt>B</tt></b>
</td>
</tr>
</table>

<p>т.е. <b><tt><font color="#006600">P1(getchar)-&gt; P2(getchar)-&gt; P2(=)-&gt;
P1(=)-&gt; P1(putchar)-&gt; P2(putchar)-&gt;
</font></tt></b><font color="#000000">и
двата процеса извеждат '<b><tt>B</tt></b>'
<b><tt>-&gt; BAD.</tt></b></font>
<br> <b>     Б. Със защита: </b>ОС <b>не</b> може
да прекъсва изпълнението на функцията.
<br><b><tt><font color="#006600">P1(getchar)-&gt; P2(echo, недостъпна!)-&gt;
P1(=)-&gt; P1(putchar)-&gt; P2(=)-&gt; P2(putchar)-&gt;
</font></tt></b>и процесът
<b><tt>P1</tt></b>
извежда '<b><tt>A</tt></b>', а процесът <b><tt>P2</tt></b> - '<b><tt>B</tt></b>'<b><tt>
-&gt; OK.</tt></b>
<br>    Извод - управление на достъпа до съвместно използвана
функция!
</p>
<p>** Задължения на ОС.
<br>    1. Следене на активните прцеси.
<br>    2. Отпускане на ресурси за активните процеси:
<br>          - процесорно
време;
<br>          - памет;
<br>          - файлове;
<br>          - I/O устройства.
<br>    3. Предпазване на данни и ресурси на всеки процес
от неправомерна намеса на друг процес.
<br>    4. Резултатът от работата на един процес трябва
да е независим от скоростта на изпълнението му, както и от скоростта на
изпълнение на другите процеси.
</p>
<p>** Взаимодействие на процеси.
<br>* Състезание между процесите за ресурси.
<br><b>    Взаимно изключване</b> (ВИ) - mutual exclusion:
<b>критичен
ресурс</b> (КР) и <b>критична секция</b> (КС).
<br>    Пример: ресурс принтер.
<br><b><tt><font color="#003300">/* program mutual_exclusion */</font></tt></b>
<br><b><tt><font color="#003300">const int n; /* number of processes */</font></tt></b>
<br><b><tt><font color="#003300">void P(int i)</font></tt></b>
<br><b><tt><font color="#003300">{ while (true)</font></tt></b>
<br><b><tt><font color="#003300">  { enter_critical(i);</font></tt></b>
<br><b><tt><font color="#003300">    &lt;critical section&gt;</font></tt></b>
<br><b><tt><font color="#003300">    exit_critical(i);</font></tt></b>
<br><b><tt><font color="#003300">    &lt;remainder&gt;</font></tt></b>
<br><b><tt><font color="#003300">  }</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b>
<br><b><tt><font color="#003300">void main( )</font></tt></b>
<br><b><tt><font color="#003300">{ parbegin(P(1), P(2), ..., P(n)); }</font></tt></b>
</p>
<p><font color="#003300">    <i>Какво лошо може да се случи?</i></font>
<br><b>    Мъртва хватка</b> (МХ) - deadlock.
<br>    Дадени са процеси <b><tt>P1</tt></b> и
<b><tt>P2
</tt></b>и
ресурси <b><tt>R1</tt></b> и <b><tt>R2</tt></b>. За да завършат, двата
процеса трябва да използват и двата ресурса. Ако процесът <b><tt>P1</tt></b>
заеме ресурс <b><tt>R1</tt></b> и процес <b><tt>P2</tt></b> заеме ресурс
<b><tt>R2</tt></b>, 
тогава нито един от процесите не може да завърши - <b><tt>P1</tt></b> чака
да бъде освободен ресурс <b><tt>R2</tt></b>, а <b><tt>P2</tt></b> чака
да бъде освободен ресурс <b><tt>R1</tt></b> - МХ.
<br><b>    Гладна смърт</b> (ГС) - starvation.
<br>    Дадени са процеси <b><tt>P1</tt></b>,
<b><tt>P2</tt></b>
и <b><tt>P3</tt></b> и ресурс <b><tt>R</tt></b>. И трите процеса използват
дадения ресурс. Нека <b><tt>P1</tt></b> и
<b><tt>P2 </tt></b>да се изпълняват
периодично, т.е. заемат ресурса за определено време, след което го освобождават.
При сценарии
<br><b><tt><font color="#006600">P1(R)-&gt; P2(R)-&gt; P1(R)-&gt; P2(R)-&gt; P1(R)-&gt;
...</font></tt></b>
<br><b><tt>P3</tt></b> чака да бъде освободен ресурса и това чакане може
да продължи неопределено време - ГС.
</p>
<p>*  Кооперация между процеси чрез поделяне, съгласуване на данните.
<br>    Два процеса, като използват общи променливи <b><tt>a
</tt></b>и
<b><tt>b</tt></b>,
поддържат връзката <b><tt>a = b</tt></b>.
<br><b><tt><font color="#006600">int a=1, b=1;</font></tt></b>
</p>
<table cellpadding="4" cols="2" width="100%">
<tr>
<td>
<b><tt><font color="#006600">PROCESS P1</font></tt></b>
<br><b><tt><font color="#006600">...</font></tt></b>
<br><b><tt><font color="#006600">    a = a + 1;</font></tt></b>
<br><b><tt><font color="#006600">    b = b + 1;</font></tt></b>
<br><b><tt><font color="#006600">...</font></tt></b>
</td>

<td>
<b><tt><font color="#006600">PROCESS P2</font></tt></b>
<br><b><tt><font color="#006600">...</font></tt></b>
<br><b><tt><font color="#006600">    b = 2 * b;</font></tt></b>
<br><b><tt><font color="#006600">    a = 2 * a;</font></tt></b>
<br><b><tt><font color="#006600">...</font></tt></b>
</td>
</tr>
</table>
    При сценарии (без защита):
<br><b><tt><font color="#006600">       
P1(a = a + 1)-&gt; P2(b = 2 * b)-&gt; P2(a = 2 * a)-&gt; P1(b = b + 1)</font></tt></b>
<br>стойностите на двете променливи са съответно
<br><b><tt><font color="#006600">(1,1) -&gt;  (2,1)     
-&gt;   (2,2)      -&gt;   (4,2)     
-&gt;    (4,3)</font></tt></b>
<br>и връзката <b><tt>a = b </tt></b>е нарушена. Отново възниква необходимост
от защита - от ВИ.
<p>** Изисквания за ВИ:
<br>    1. Само един процес е в КС секция относно даден
КР.
<br>    2. Процес извън КС може да прекъсва, без това да
влияе на останалите процеси.
<br>    3. Всеки процес, чакащ за влизане в КС, трябва да
може да влезе в КС (с крайно време за чакане).
<br>    4. Ако няма процес в КС (относно КР), всеки процес,
който иска този КР, трябва да може да влезе в КС незабавно.
<br>    5. Няма ограничения за брой процеси, чакащи за КР
и няма ограничения за времето и честотата на използване на този ресурс.
<br>    6. Един процес може да остане в КС за крайно време.
<br>
</p>
<hr width="100%">
<p><b>5.2 Взаимно изключване: софтуерен подход.</b>
<br>** Алгоритъм на Декер.
<br><b>        </b>Първи опит:
<br><b><tt><font color="#003300">int </font><font color="#006600">turn;
/* =0 or =1 */</font></tt></b>
</p>
<table cellpadding="4" cols="2" width="100%">
<tr>
<td>
<b><tt><font color="#003300">// PROCESS P0</font></tt></b>
<br><b><tt><font color="#003300">...</font></tt></b>
<br><b><tt><font color="#003300">while(</font><font color="#006600">turn!=0)
nothing();</font></tt></b>
<br><b><tt><font color="#006600"> &lt;critical section&gt;</font></tt></b>
<br><b><tt><font color="#006600">turn = 1;</font></tt></b>
<br><b><tt><font color="#006600">...</font></tt></b>
</td>

<td>
<b><tt><font color="#003300">// PROCESS P1</font></tt></b>
<br><b><tt><font color="#003300">...</font></tt></b>
<br><b><tt><font color="#003300">while(</font><font color="#006600">turn!=1)
nothing();</font></tt></b>
<br><b><tt><font color="#006600"> &lt;critical section&gt;</font></tt></b>
<br><b><tt><font color="#006600">turn = 0;</font></tt></b>
<br><b><tt><font color="#006600">...</font></tt></b>
</td>
</tr>
</table>
    Щастлив сценарии - последователно влизане в КС:
<br><b><tt><font color="#006600">P0 -&gt; P1 -&gt; P0 -&gt; P1 -&gt; P0 -&gt; P1 -&gt; ...</font></tt></b>
<br>    Проблем - когато единия процес няма интерес за влизане
в КС, т.е. <b><tt><font color="#006600">P1</font></tt></b> иска 2 пъти
последователно да влезе в КС.
<br><b><tt><font color="#006600">P0 -&gt; P1 -&gt; P1(чака, turn има стойност
1) -</font></tt></b>   <b><tt><font color="#006600">P1 </font></tt></b>се
блокира.
<br>Това се случва и при грешка в единия процес
<p><b>      </b>  Втори опит:
<br><b><tt><font color="#003300">bool </font><font color="#006600">flag[2]
= {false, false};</font></tt></b>
</p>
<table cellpadding="4" width="100%">
<tr>
<td>
<b><tt><font color="#003300">// PROCESS P0</font></tt></b>
<br><b><tt><font color="#003300">...</font></tt></b>
<br><b><tt><font color="#003300">while(</font><font color="#006600">flag[1])
nothing();</font></tt></b>
<br><b><tt><font color="#006600">flag[0] = true;</font></tt></b>
<br><b><tt><font color="#006600"> &lt;critical section&gt;</font></tt></b>
<br><b><tt><font color="#006600">flag[0] = false;</font></tt></b>
<br><b><tt><font color="#006600">...</font></tt></b>
</td>

<td>
<b><tt><font color="#003300">// PROCESS P1</font></tt></b>
<br><b><tt><font color="#003300">...</font></tt></b>
<br><b><tt><font color="#003300">while(</font><font color="#006600">flag[0])
nothing();</font></tt></b>
<br><b><tt><font color="#006600">flag[1] = true;</font></tt></b>
<br><b><tt><font color="#006600"> &lt;critical section&gt;</font></tt></b>
<br><b><tt><font color="#006600">flag[1] = false;</font></tt></b>
<br><b><tt><font color="#006600">...</font></tt></b>
</td>
</tr>
</table>
    Щастлив сценарии:
<br><b><tt><font color="#006600">P0(while)-&gt; P0(=)-&gt; P0(КС)-&gt; P0(=)-&gt; P0(while)-&gt;
P0(=)-&gt; P0(КС)-&gt; P0(=)-&gt;</font></tt></b>
<br><b><tt><font color="#006600">P1(while)-&gt; P1(=)-&gt; P1(КС)-&gt; P1(=)-&gt; ...</font></tt></b>
<br>    Проблем при следния сценарии:
<br><b><tt>P0(<font color="#006600">while(flag[1])</font></tt></b> намира
го <b><tt><font color="#006600">false)-&gt;</font></tt></b>
<br><b><tt>P1(<font color="#006600">while(flag[0]) </font></tt></b>намира
го <b><tt><font color="#006600">false)-&gt;</font></tt></b>
<br><b><tt>P0(<font color="#006600">flag[0]=true</font></tt></b><font color="#000000">
и влиза в КС)<b><tt> -&gt;</tt></b></font>
<br><b><tt>P1(<font color="#006600">flag[1]=true</font></tt></b><font color="#000000">
и влиза в КС)</font> <b><tt>-&gt; BAD.</tt></b>
<br>И двата процеса са в КС - няма ВИ.
<p><b>    </b>Трети опит:
<br><b><tt><font color="#003300">bool </font><font color="#006600">flag[2];</font></tt></b>
</p>
<table cellpadding="4" width="100%">
<tr>
<td>
<b><tt><font color="#003300">// PROCESS P0</font></tt></b>
<br><b><tt><font color="#003300">...</font></tt></b>
<br><b><tt><font color="#006600">flag[0] = true;</font></tt></b>
<br><b><tt><font color="#003300">while(</font><font color="#006600">flag[1])
nothing();</font></tt></b>
<br><b><tt><font color="#006600"> &lt;critical section&gt;</font></tt></b>
<br><b><tt><font color="#006600">flag[0] = false;</font></tt></b>
<br><b><tt><font color="#006600">...</font></tt></b>
</td>

<td>
<b><tt><font color="#003300">// PROCESS P1</font></tt></b>
<br><b><tt><font color="#003300">...</font></tt></b>
<br><b><tt><font color="#006600">flag[1] = true;</font></tt></b>
<br><b><tt><font color="#003300">while(</font><font color="#006600">flag[0])
nothing();</font></tt></b>
<br><b><tt><font color="#006600"> &lt;critical section&gt;</font></tt></b>
<br><b><tt><font color="#006600">flag[1] = false;</font></tt></b>
<br><b><tt><font color="#006600">...</font></tt></b>
</td>
</tr>
</table>
    Щастливи сценарии:
<br><b><tt><font color="#006600">P0(=t)-&gt; P0(while)-&gt; P0(КС)-&gt; P1(=t)-&gt;
P1(while,чака)-&gt; P0(=f)-&gt; P1(КС)-&gt; P1(=f)-&gt; P1(=t)-&gt; P1(while)-&gt; P0(КС)-&gt;
P0(=t,чака)-&gt; P1(=f)-&gt; P0(КС)-&gt; ...</font></tt></b>
<br>ВИ е гарантирано.
<p>    Проблем - възможно e МХ при следния сценарии:
<br><b><tt><font color="#006600">P0(flag[0] = true)-&gt; P1(flag[1] = true)-&gt;
P1(while)-&gt; P0(while)-&gt;</font><font color="#000000"> MX.</font></tt></b>
</p>
<p>** Алгоритъм на Петерсон - решение на задачата за ВИ.
<br><b><tt><font color="#006600">bool flag[2] = {false,false};</font></tt></b>
<br><b><tt><font color="#006600">int turn;</font></tt></b>
</p>
<table cellpadding="4" cols="2" width="100%">
<tr>
<td>
<b><tt><font color="#006600">void P0()</font></tt></b>
<br><b><tt><font color="#006600">{</font></tt></b>
<br><b><tt><font color="#006600"> while (true)</font></tt></b>
<br><b><tt><font color="#006600"> {</font></tt></b>
<br><b><tt><font color="#006600">  flag[0] = true;</font></tt></b>
<br><b><tt><font color="#006600">  turn = 1;</font></tt></b>
<br><b><tt><font color="#006600">  while (flag[1] &amp;&amp; turn==1)</font></tt></b>
<br><b><tt><font color="#006600">                  
nothing();</font></tt></b>
<br><b><tt><font color="#006600">  &lt;critical section&gt;</font></tt></b>
<br><b><tt><font color="#006600">  flag[0] = false;</font></tt></b>
<br><b><tt><font color="#006600">  &lt;remainder&gt;</font></tt></b>
<br><b><tt><font color="#006600"> }</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b>
</td>

<td>
<b><tt><font color="#006600">void P1()</font></tt></b>
<br><b><tt><font color="#006600">{</font></tt></b>
<br><b><tt><font color="#006600"> while (true)</font></tt></b>
<br><b><tt><font color="#006600"> {</font></tt></b>
<br><b><tt><font color="#006600">  flag[1] = true;</font></tt></b>
<br><b><tt><font color="#006600">  turn = 0;</font></tt></b>
<br><b><tt><font color="#006600">  while (flag[0] &amp;&amp; turn==0)</font></tt></b>
<br><b><tt><font color="#006600">                  
nothing();</font></tt></b>
<br><b><tt><font color="#006600">  &lt;critical section&gt;</font></tt></b>
<br><b><tt><font color="#006600">  flag[1] = false;</font></tt></b>
<br><b><tt><font color="#006600">  &lt;remainder&gt;</font></tt></b>
<br><b><tt><font color="#006600"> }</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b>
</td>
</tr>
</table>
<b><tt><font color="#006600">void main()</font></tt></b>
<br><b><tt><font color="#006600">{ flag[0] = false;</font></tt></b>
<br><b><tt><font color="#006600">  flag[1] = false;</font></tt></b>
<br><b><tt><font color="#006600">  parbegin(P0, P1);</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b>
<br>    Масивът <b><tt><font color="#006600">flag</font></tt></b> 
показва заявка (интерес) за КС, променливата <b><tt><font color="#006600">turn</font></tt></b>
- кой в момента е в КС.  Ето и всички възможности за стойности на
тези променлива:
<table border cellspacing="0" cellpadding="6">
<tr>
<td><b><tt><font color="#006600">flag[0]</font></tt></b></td>

<td><b><tt><font color="#006600">flag[1]</font></tt></b></td>

<td><b><tt><font color="#006600">turn</font></tt></b></td>

<td></td>
</tr>

<tr>
<td><b><tt><font color="#006600">false</font></tt></b></td>

<td><b><tt><font color="#006600">false</font></tt></b></td>

<td><b><tt><font color="#006600">0, 1</font></tt></b></td>

<td>Няма интерес за КС.</td>
</tr>

<tr>
<td><b><tt><font color="#CC0000">false</font></tt></b></td>

<td><b><tt><font color="#006600">true</font></tt></b></td>

<td><b><tt><font color="#006600">0, 1</font></tt></b></td>

<td>
<b><tt><font color="#006600">P0</font></tt></b> няма интерес за КС,
<b><tt><font color="#006600">P1</font></tt></b>
в КС.</td>
</tr>

<tr>
<td><b><tt><font color="#006600">true</font></tt></b></td>

<td><b><tt><font color="#CC0000">false</font></tt></b></td>

<td><b><tt><font color="#006600">0, 1</font></tt></b></td>

<td>
<b><tt><font color="#006600">P0</font></tt></b> в КС, <b><tt><font color="#006600">P1</font></tt></b>
няма интерес за КС.</td>
</tr>

<tr>
<td><b><tt><font color="#006600">true</font></tt></b></td>

<td><b><tt><font color="#006600">true</font></tt></b></td>

<td><b><tt><font color="#990000">0</font></tt></b></td>

<td>
<b><tt><font color="#006600">P0</font></tt></b> в КС, <b><tt><font color="#006600">P1</font></tt></b>
чака за КС.</td>
</tr>

<tr>
<td><b><tt><font color="#006600">true</font></tt></b></td>

<td><b><tt><font color="#006600">true</font></tt></b></td>

<td><b><tt><font color="#990000">1</font></tt></b></td>

<td>
<b><tt><font color="#006600">P1</font></tt></b> в КС, <b><tt><font color="#006600">P0</font></tt></b>
чака за КС.</td>
</tr>
</table>

<hr width="100%">
<p><b>5.3 Взаимно изключване: хардуера поддръжка.</b>
<br>** Непозволяване на прекъсвания - проблеми при многопроцесорни системи
и неефективно използване на ресурси..
</p>
<p>** Специални машинни команди. Функцията <b><tt><font color="#000099">testset</font></tt></b>
не реализирана хардуерно и връща стойност за един такт на процесора, т.е.
не може да се прекъсва.
<br><b><tt><font color="#000099">bool testset(int &amp;i)</font></tt></b>
<br><b><tt><font color="#000099">{ if (i == 0)</font></tt></b>
<br><b><tt><font color="#000099">  { i = 1; return true; }</font></tt></b>
<br><b><tt><font color="#000099">          
return false;</font></tt></b>
<br><b><tt><font color="#000099">}</font></tt></b>
<br><b><tt><font color="#003300">const</font><font color="#006600"> int
n; /* number of processes */</font></tt></b>
<br><b><tt><font color="#006600">int bolt;</font></tt></b>
<br><b><tt><font color="#003300">void</font><font color="#006600"> P(int
k)</font></tt></b>
<br><b><tt><font color="#003300">{ while(true)</font></tt></b>
<br><b><tt><font color="#003300">  {</font></tt></b>
<br><b><tt><font color="#003300">   do </font><font color="#006600">nothing();</font><font color="#003300">
while (!</font><font color="#006600">testset(bolt));</font></tt></b>
<br><b><tt><font color="#006600">   &lt;critical section&gt;</font></tt></b>
<br><b><tt><font color="#006600">   bolt = 0;</font></tt></b>
<br><b><tt><font color="#006600">   &lt;remainder&gt;</font></tt></b>
<br><b><tt><font color="#003300">  }</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b>
<br><b><tt><font color="#003300">void main()</font></tt></b>
<br><b><tt><font color="#003300">{ parbegin(</font><font color="#006600">P(1),P(2),...,P(n));
}</font></tt></b>
<br>    Когато променливата <b><tt><font color="#006600">bolt</font></tt></b>
има стойност 1, има процес в КС и функцията <b><tt><font color="#000099">testset
</font></tt></b>връща
стойност <b><tt><font color="#000099">false</font></tt></b> - т.е. всички
процеси, които имат интерес за КС, чакат. Когато променливата
<b><tt><font color="#006600">bolt</font></tt></b>
има стойност 0, няма процес в КС, функцията <b><tt><font color="#000099">testset
</font></tt></b>връща
стойност <b><tt><font color="#000099">false</font></tt></b> , като стойността
на <b><tt><font color="#006600">bolt</font></tt></b> става 1. Процес, който
излиза от КС, променя стойността на <b><tt><font color="#006600">bolt</font></tt></b>
на 0. Гарантирано е ВИ, няма опасност от МХ.
</p>
<p><b>5.4 Семафори</b>
<br>   Основен принцип: два или повече процеса се кооперират
в смисъл на прости сигнали така, че един процес може да бъде спрян на определено
място и да остане в това състояние, докато не получи съответен сигнал.
<br>   За да изпрати сигнал чрез семафора  <b><tt><font color="#006600">s</font></tt></b>,
процесът трябва да изпълни примитива (процедурата) <b><tt><font color="#006600">signal(s)</font></tt></b>.
За да получи сигнал от семафор <b><tt><font color="#006600">s</font></tt></b>,
процесът трябва да изпълни <b><tt><font color="#006600">wait(s)</font></tt></b> 
и ако съответният сигнал още не е изпратен, да остане в състояние на чакане
(блокиран).
</p>
<p>    Дефинирани са 3 действия с променливата семафор:
<br>      1. Инициализира се с неотрицателно число.
<br>      2. Примитива <b><tt><font color="#006600">wait(s)
</font></tt></b>намалява
стойността на <b><tt><font color="#006600">s</font></tt></b> с 1. Ако стойността
стане отрицателна, процесът (изпълняващ <b><tt><font color="#006600">wait</font></tt></b>)
се блокира.
<br>      3. Операцията <b><tt><font color="#006600">signal(s)
</font></tt></b>увеличава
стойността на <b><tt><font color="#006600">s</font></tt></b> с 1. Ако стойността
не е положителна, процесът (блокиран с <b><tt><font color="#006600">wait</font></tt></b>)
се разблокира.
<br>    Примитивите <b><tt><font color="#006600">wait </font></tt></b>и
<b><tt><font color="#006600">signal
</font></tt></b>се
предполат неделими, т.е. те не могат да бъдат прекъсвани.
</p>
<p><b><tt><font color="#006600">struct semaphore {</font></tt></b>
<br><b><tt><font color="#006600"> int count;</font></tt></b>
<br><b><tt><font color="#006600"> queueType queue;</font></tt></b>
<br><b><tt><font color="#006600">};</font></tt></b>
</p>
<table border cellspacing="0" cellpadding="4" cols="2" width="100%">
<tr>
<td>
<b><tt><font color="#003300">void wait(semaphore s)</font></tt></b>
<br><b><tt><font color="#003300">{</font></tt></b>
<br><b><tt><font color="#003300"> s.count--;</font></tt></b>
<br><b><tt><font color="#003300"> if (s.count &lt; 0)</font></tt></b>
<br><b><tt><font color="#003300"> {</font></tt></b>
<br><b><tt><font color="#006600">  </font><font color="#660000">place_this_process_in_s.queue;</font></tt></b>
<br><b><tt><font color="#660000">  block_this_process;</font></tt></b>
<br><b><tt><font color="#006600"> </font><font color="#003300">}</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b>
</td>

<td>
<b><tt><font color="#003300">void signal(semaphore s)</font></tt></b>
<br><b><tt><font color="#003300">{</font></tt></b>
<br><b><tt><font color="#003300"> s.count++;</font></tt></b>
<br><b><tt><font color="#003300"> if (s.count &lt;= 0)</font></tt></b>
<br><b><tt><font color="#003300"> {</font></tt></b>
<br><b><tt><font color="#660000">  remove_a_process_from_s.queue(P);</font></tt></b>
<br><b><tt><font color="#660000">  place_the_process_on_ready_list(P);</font></tt></b>
<br><b><tt><font color="#003300"> }</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b>
</td>
</tr>
</table>

<p>    Пример ???.
</p>
<center><img src="05_08.gif" height="712" width="413"></center>
Ако <b><tt><font color="#003300">s.count </font></tt></b>е отрицателно
число (3, 6 и 7), -<font color="#003300"><b><tt>s.count</tt></b> е броят
на чакащите на семафора  <b><tt>s</tt></b> процеси, т.е. броят на
процесите в опашката </font><b><tt><font color="#660000">s.queue</font></tt></b>. 
Ако <b><tt><font color="#003300">s.count </font></tt></b>е положително
число (1), <font color="#003300"><b><tt>s.count</tt></b> е броят на процесите,
които могат да минат през семафора, преди той да се затвори. Опашката </font><b><tt><font color="#660000">s.queue</font></tt></b>
е празна. Ако <b><tt><font color="#003300">s.count </font></tt></b>е 1
(1), то един процес минава и затваря семафора. Ако <b><tt><font color="#003300">s.count
</font></tt></b>е
0 (2, 4 и 5), то идващ процес се блокира и отива на опашката.
<p>   Двоични семафори - семафорът има две състояния - отворен
(1) и затворен (0):
<br><b><tt><font color="#006600">struct binary_semaphore {</font></tt></b>
<br><b><tt><font color="#006600">int value; /* = 0, 1 */</font></tt></b>
<br><b><tt><font color="#006600">queueType queue;</font></tt></b>
<br><b><tt><font color="#006600">};</font></tt></b>
</p>
<table border cellspacing="0" cellpadding="4" cols="2" width="100%">
<tr>
<td>
<b><tt><font color="#006600">void waitB(binary_semaphore s)</font></tt></b>
<br><b><tt><font color="#006600">{</font></tt></b>
<br><b><tt><font color="#006600"> if (s.value==1) s.value=0;</font></tt></b>
<br><b><tt><font color="#006600"> else</font></tt></b>
<br><b><tt><font color="#006600"> {</font></tt></b>
<br><b><tt><font color="#006600">  </font><font color="#660000">place_this_process_in_s.queue;</font></tt></b>
<br><b><tt><font color="#660000">  block_this_process;</font></tt></b>
<br><b><tt><font color="#006600"> }</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b>
</td>

<td>
<b><tt><font color="#006600">void signalB(binary_semaphore s)</font></tt></b>
<br><b><tt><font color="#006600">{</font></tt></b>
<br><b><tt><font color="#006600"> if (s.queue.is_empty()) s.value=1;</font></tt></b>
<br><b><tt><font color="#006600"> else</font></tt></b>
<br><b><tt><font color="#006600"> {</font></tt></b>
<br><b><tt><font color="#006600">  </font><font color="#660000">remove_a_process_from
s.queue(P);</font></tt></b>
<br><b><tt><font color="#660000">  place_process_on_ready_list(P);</font></tt></b>
<br><b><tt><font color="#006600"> }</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b>
</td>
</tr>
</table>

<p>** Взаимно изключване - решение на задачата за ВИ със семафори.
<br><b><tt><font color="#003300">/* program mutual_exclusion */</font></tt></b>
<br><b><tt><font color="#003300">const int n; /* number of processes */</font></tt></b>
<br><b><tt><font color="#003300">semaphore s = 1;</font></tt></b>
<br><b><tt><font color="#003300">void P(int i)</font></tt></b>
<br><b><tt><font color="#003300">{</font></tt></b>
<br><b><tt><font color="#003300"> while (true)</font></tt></b>
<br><b><tt><font color="#003300"> {</font></tt></b>
<br><b><tt><font color="#003300">  wait(s);</font></tt></b>
<br><b><tt><font color="#003300">  &lt;critical section&gt;</font></tt></b>
<br><b><tt><font color="#003300">  signal(s);</font></tt></b>
<br><b><tt><font color="#003300">  &lt;remainder&gt;</font></tt></b>
<br><b><tt><font color="#003300"> }</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b>
<br><b><tt><font color="#003300">void main()</font></tt></b>
<br><b><tt><font color="#003300">{</font></tt></b>
<br><b><tt><font color="#003300"> parbegin(P(1), P(2),..., P(n));</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b>
<br>    Стойността на променливата <b><tt><font color="#003300">s.count
</font></tt></b>има
следния смисъл:
<br>- <b><tt><font color="#003300">s.count &gt;= 0 </font></tt></b>е броят
на процесите, които могат да изпълнят примитива <b><tt><font color="#006600">wait(s)</font></tt></b>без
да бъдат блокирани (и няма изпълнение на <b><tt><font color="#006600">signal(s)</font></tt></b>);
<br>- <b><tt><font color="#003300">s.count &lt; 0 </font></tt></b>е броят
на процесите, чакащи в <b><tt><font color="#006600">s.queue.</font></tt></b>
<br>
</p>
<hr width="100%">
<br><b>5.5 Задача за производител/потребител.</b>
<br>    Един или няколко производители генерират данни (записи,
символи) и ги поставят в един буфер. Един потребител взема по една данна
от буфера. Само един агент (производител или потребител) има достъп да
буфера в даден момент.
<center><img src="05_11.gif" height="337" width="547"></center>
* <b>Първи опит</b> за решение със семафори:
<br><b><tt><font color="#003300">/* program producer_consumer */</font></tt></b>
<br><b><tt><font color="#003300">int n;</font></tt></b>
<br><b><tt><font color="#003300">binary_semaphore s = 1;</font></tt></b>
<br><b><tt><font color="#003300">binary_semaphore delay = 0;</font></tt></b>
<table border cellspacing="0" cellpadding="4" cols="2" width="100%">
<tr>
<td valign="TOP">
<b><tt><font color="#003300">     void
producer()</font></tt></b>
<br><b><tt><font color="#003300">     {</font></tt></b>
<br><b><tt><font color="#003300">      while (true)</font></tt></b>
<br><b><tt><font color="#003300">      {</font></tt></b>
<br><b><tt><font color="#003300">/*p1*/ produce();</font></tt></b>
<br><b><tt><font color="#003300">/*p2*/ waitB(s);</font></tt></b>
<br><b><tt><font color="#003300">/*p3*/ append(); /*КС*/ </font></tt></b>
<br><b><tt><font color="#003300">/*p4*/ n++;</font></tt></b>
<br><b><tt><font color="#003300">/*p5*/ if (n==1) signalB(delay);</font></tt></b>
<br><b><tt><font color="#003300">/*p6*/ signalB(s);</font></tt></b>
<br><b><tt><font color="#003300">      }</font></tt></b>
<br><b><tt><font color="#003300">     }</font></tt></b>
</td>

<td>
<b><tt><font color="#003300">     void consumer()</font></tt></b>
<br><b><tt><font color="#003300">     {</font></tt></b>
<br><b><tt><font color="#003300">      waitB(delay);</font></tt></b>
<br><b><tt><font color="#003300">      while (true)</font></tt></b>
<br><b><tt><font color="#003300">      {</font></tt></b>
<br><b><tt><font color="#003300">/*c1*/ waitB(s);</font></tt></b>
<br><b><tt><font color="#003300">/*c2*/ take();    /*КС*/</font></tt></b>
<br><b><tt><font color="#003300">/*c3*/ n--;</font></tt></b>
<br><b><tt><font color="#003300">/*c4*/ signalB(s);</font></tt></b>
<br><b><tt><font color="#003300">/*c5*/ consume();</font></tt></b>
<br><b><tt><font color="#003300">/*c6*/ if (n==0) waitB(delay);</font></tt></b>
<br><b><tt><font color="#003300">      }</font></tt></b>
<br><b><tt><font color="#003300">     }</font></tt></b>
</td>
</tr>
</table>
<b><tt><font color="#003300">void main()</font></tt></b>
<br><b><tt><font color="#003300">{ n = 0;</font></tt></b>
<br><b><tt><font color="#003300">  parbegin(producer, consumer);</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b>
<br><font color="#000000">    Семафорът </font><b><tt><font color="#006600">s</font></tt></b><font color="#000000">
служи за взаимно изключване, семафорът </font><b><tt><font color="#006600">delay</font></tt></b><font color="#000000">
- за чакане на потребителя, когато буферът е празен.</font>
<br><font color="#000000">Проблем:</font>
<br> 
<table border cellspacing="0" cellpadding="4">
<tr>
<td><b><tt> </tt></b></td>

<td><b><tt> </tt></b></td>

<td><b><tt> </tt></b></td>

<td>
<center><b><tt>n</tt></b></center>
</td>

<td>
<center><b><tt>delay</tt></b></center>
</td>

<td></td>
</tr>

<tr>
<td>
<center><b><tt>1</tt></b></center>
</td>

<td>
<center><b><tt>Init</tt></b></center>
</td>

<td><b><tt> </tt></b></td>

<td>
<center><b><tt>0</tt></b></center>
</td>

<td>
<center><b><tt>0</tt></b></center>
</td>

<td></td>
</tr>

<tr>
<td>
<center><b><tt>2</tt></b></center>
</td>

<td>
<center><b><tt>Producer</tt></b></center>
</td>

<td>
<center><b><tt>КС</tt></b></center>
</td>

<td>
<center><b><tt>0-&gt;1</tt></b></center>
</td>

<td>
<center><b><tt>0-&gt;1</tt></b></center>
</td>

<td><b><tt>p1-&gt;p2-&gt;p3-&gt;p4-&gt;p5-&gt;p6</tt></b></td>
</tr>

<tr>
<td>
<center><b><tt>3</tt></b></center>
</td>

<td>
<center><b><tt>Consumer</tt></b></center>
</td>

<td>
<center><b><tt>waitB(delay)</tt></b></center>
</td>

<td>
<center><b><tt>1</tt></b></center>
</td>

<td>
<center><b><tt>1-&gt;0</tt></b></center>
</td>

<td></td>
</tr>

<tr>
<td>
<center><b><tt>4</tt></b></center>
</td>

<td>
<center><b><tt>Consumer</tt></b></center>
</td>

<td>
<center><b><tt>КС</tt></b></center>
</td>

<td>
<center><b><tt>1-&gt;0</tt></b></center>
</td>

<td>
<center><b><tt>0</tt></b></center>
</td>

<td><b><tt>c1-&gt;c2-&gt;c3-&gt;c4-&gt;c5-&gt;</tt></b></td>
</tr>

<tr>
<td>
<center><b><tt>5</tt></b></center>
</td>

<td>
<center><b><tt>Producer</tt></b></center>
</td>

<td>
<center><b><tt>КС</tt></b></center>
</td>

<td>
<center><b><tt>0-&gt;1</tt></b></center>
</td>

<td>
<center><b><tt>0-&gt;1</tt></b></center>
</td>

<td><b><tt>p1-&gt;p2-&gt;p3-&gt;p4-&gt;</tt></b></td>
</tr>

<tr>
<td>
<center><b><tt>6</tt></b></center>
</td>

<td>
<center><b><tt>Consumer</tt></b></center>
</td>

<td>
<center><b><tt><font color="#003300">if (n==0) waitB(delay)</font></tt></b></center>
</td>

<td>
<center><b><tt>1</tt></b></center>
</td>

<td>
<center><b><tt>1</tt></b></center>
</td>

<td><b><tt>-&gt;c6</tt></b></td>
</tr>

<tr>
<td>
<center><b><tt>7</tt></b></center>
</td>

<td>
<center><b><tt>Consumer</tt></b></center>
</td>

<td>
<center><b><tt>КС</tt></b></center>
</td>

<td>
<center><b><tt>1-&gt;0</tt></b></center>
</td>

<td>
<center><b><tt>1</tt></b></center>
</td>

<td><b><tt>c1-&gt;c2-&gt;c3-&gt;c4-&gt;c5-&gt;</tt></b></td>
</tr>

<tr>
<td>
<center><b><tt>8</tt></b></center>
</td>

<td>
<center><b><tt>Consumer</tt></b></center>
</td>

<td>
<center><b><tt><font color="#003300">if (n==0) waitB(delay)</font></tt></b></center>
</td>

<td>
<center><b><tt>0</tt></b></center>
</td>

<td>
<center><b><tt>1-&gt;0</tt></b></center>
</td>

<td><b><tt>-&gt;c6</tt></b></td>
</tr>

<tr>
<td>
<center><b><tt>9</tt></b></center>
</td>

<td>
<center><b><tt>Consumer</tt></b></center>
</td>

<td>
<center><b><tt>КС</tt></b></center>
</td>

<td>
<center><b><tt>-1</tt></b></center>
</td>

<td>
<center><b><tt>0</tt></b></center>
</td>

<td><b><tt>c1-&gt;c2-&gt; !!!</tt></b></td>
</tr>
</table>

<p>* <b>Втори опит</b> - решение:
<br><b><tt><font color="#333300">int n;</font></tt></b>
<br><b><tt><font color="#333300">binary_semaphore s = 1;</font></tt></b>
<br><b><tt><font color="#333300">binary_semaphore delay = 0;</font></tt></b>
</p>
<table border cellspacing="0" cellpadding="4" cols="2" width="100%">
<tr>
<td valign="TOP">
<b><tt><font color="#003300">void producer()</font></tt></b>
<br><b><tt><font color="#003300">{</font></tt></b>
<br><b><tt><font color="#003300"> while (true)</font></tt></b>
<br><b><tt><font color="#003300"> {</font></tt></b>
<br><b><tt><font color="#003300">  produce();</font></tt></b>
<br><b><tt><font color="#003300">  waitB(s);</font></tt></b>
<br><b><tt><font color="#003300">  append();n++;</font></tt></b>
<br><b><tt><font color="#003300">  if (n==1) signalB(delay);</font></tt></b>
<br><b><tt><font color="#003300">  signalB(s);</font></tt></b>
<br><b><tt><font color="#003300"> }</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b>
</td>

<td>
<b><tt><font color="#003300">void consumer()</font></tt></b>
<br><b><tt><font color="#003300">{ int m;  /* a local variable */</font></tt></b>
<br><b><tt><font color="#003300">  waitB(delay);</font></tt></b>
<br><b><tt><font color="#003300">  while (true)</font></tt></b>
<br><b><tt><font color="#003300">  {</font></tt></b>
<br><b><tt><font color="#003300">   waitB(s);</font></tt></b>
<br><b><tt><font color="#003300">   take(); n--;  m = n;</font></tt></b>
<br><b><tt><font color="#003300">   signalB(s);</font></tt></b>
<br><b><tt><font color="#003300">   consume();</font></tt></b>
<br><b><tt><font color="#003300">   if (m==0) waitB(delay);</font></tt></b>
<br><b><tt><font color="#003300">  }</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b>
</td>
</tr>
</table>
<b><tt><font color="#003300">void main()</font></tt></b>
<br><b><tt><font color="#003300">{ n = 0;</font></tt></b>
<br><b><tt><font color="#003300">  parbegin (producer, consumer);</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b>
<br>    Варианти на задачата - безкраен буфер и краен кръгов
буфер.
<center><img src="05_15.gif" height="557" width="495"></center>

<hr width="100%">
<br><b>5.6 Задачата на бръснаря.</b>
<center><img src="05_18.gif" height="491" width="661"></center>

<hr width="100%">
<br><b>5.7 Задачата на писатели/читатели.</b>
<br>    Данни (файл, блок от паметта) се използват от няколко
процеса. Някои от процесите само четат тези данни - читатили, а други само
променят данните - писатели. Следните условия трябва да се спазват:
<br>   1. Произволен брой читатели могат да четат едновременно
данните;
<br>   2. Само един писател може да пише данни;
<br>   3. Ако писател пише, никой читател не може да чете.
<br>    Ако всеки процес може и да пише и да чете, общото
решение за ВИ работи.
<br>    Ако един процес може или само да чете, или само
да пише - общото решение е неприемливо, а съществуват и по-ефективни решения.
<p>** Предимство на читателите.
<br><b><tt><font color="#006600">/* program readers_and_writers */</font></tt></b>
<br><b><tt><font color="#006600">int readcount;</font></tt></b>
<br><b><tt><font color="#006600">semaphore x = 1, wsem = 1;</font></tt></b>
</p>
<table border cellspacing="0" cellpadding="4" cols="2" width="100%">
<tr>
<td>
<b><tt><font color="#006600">void reader()</font></tt></b>
<br><b><tt><font color="#006600">{ while (true)</font></tt></b>
<br><b><tt><font color="#006600">  {</font></tt></b>
<br><b><tt><font color="#006600">   wait(x);</font></tt></b>
<br><b><tt><font color="#006600">   readcount++;</font></tt></b>
<br><b><tt><font color="#006600">   if (readcount==1) wait(wsem);</font></tt></b>
<br><b><tt><font color="#006600">   signal(x);</font></tt></b>
<br><b><tt><font color="#006600">   READUNIT();</font></tt></b>
<br><b><tt><font color="#006600">   wait(x);</font></tt></b>
<br><b><tt><font color="#006600">   readcount--;</font></tt></b>
<br><b><tt><font color="#006600">   if (readcount==0) signal(wsem);</font></tt></b>
<br><b><tt><font color="#006600">   signal(x);</font></tt></b>
<br><b><tt><font color="#006600">  }</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b>
</td>

<td valign="TOP">
<b><tt><font color="#006600">void writer()</font></tt></b>
<br><b><tt><font color="#006600">{</font></tt></b>
<br><b><tt><font color="#006600"> while (true)</font></tt></b>
<br><b><tt><font color="#006600"> {</font></tt></b>
<br><b><tt><font color="#006600">  wait(wsem);</font></tt></b>
<br><b><tt><font color="#006600">  WRITEUNIT();</font></tt></b>
<br><b><tt><font color="#006600">  signal(wsem);</font></tt></b>
<br><b><tt><font color="#006600"> }</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b>
<br> 
<br> 
<p> </p>
</td>
</tr>
</table>
<b><tt><font color="#006600">void main()</font></tt></b>
<br><b><tt><font color="#006600">{ readcount = 0;</font></tt></b>
<br><b><tt><font color="#006600">  parbegin(reader, writer);</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b>
<p>** Предимство на писателите.
<br><b><tt><font color="#006600">/* program readers_and_writers */</font></tt></b>
<br><b><tt><font color="#006600">int readcount, writecount;</font></tt></b>
<br><b><tt><font color="#006600">semaphore x = 1, y = 1, z = 1, wsem =
1, rsem = 1;</font></tt></b>
<br> 
</p>
<table border cellspacing="0" cellpadding="4" cols="2" width="100%">
<tr>
<td>
<b><tt><font color="#006600">void reader()</font></tt></b>
<br><b><tt><font color="#006600">{ while (true)</font></tt></b>
<br><b><tt><font color="#006600">  {</font></tt></b>
<br><b><tt><font color="#006600">   wait(z);</font></tt></b>
<br><b><tt><font color="#006600">   wait(rsem);</font></tt></b>
<br><b><tt><font color="#006600">   wait(x);</font></tt></b>
<br><b><tt><font color="#006600">   readcount++;</font></tt></b>
<br><b><tt><font color="#006600">   if (readcount==1) wait(wsem);</font></tt></b>
<br><b><tt><font color="#006600">   signal(x);</font></tt></b>
<br><b><tt><font color="#006600">   signal(rsem);</font></tt></b>
<br><b><tt><font color="#006600">   signal(z);</font></tt></b>
<br><b><tt><font color="#006600">   READUNIT();   /*
{КС} */</font></tt></b>
<br><b><tt><font color="#006600">   wait(x);</font></tt></b>
<br><b><tt><font color="#006600">   readcount--;</font></tt></b>
<br><b><tt><font color="#006600">   if (readcount==0) signal(wsem);</font></tt></b>
<br><b><tt><font color="#006600">   signal(x);</font></tt></b>
<br><b><tt><font color="#006600">  }</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b>
</td>

<td valign="TOP">
<b><tt><font color="#006600">void writer()</font></tt></b>
<br><b><tt><font color="#006600">{</font></tt></b>
<br><b><tt><font color="#006600"> while (true)</font></tt></b>
<br><b><tt><font color="#006600"> {</font></tt></b>
<br><b><tt><font color="#006600">  wait(y);</font></tt></b>
<br><b><tt><font color="#006600">  writecount++;</font></tt></b>
<br><b><tt><font color="#006600">  if (writecount==1) wait(rsem);</font></tt></b>
<br><b><tt><font color="#006600">  signal(y);</font></tt></b>
<br><b><tt><font color="#006600">  wait(wsem);</font></tt></b>
<br><b><tt><font color="#006600">  WRITEUNIT();  /* КС */</font></tt></b>
<br><b><tt><font color="#006600">  signal(wsem);</font></tt></b>
<br><b><tt><font color="#006600">  wait(y);</font></tt></b>
<br><b><tt><font color="#006600">  writecount--;</font></tt></b>
<br><b><tt><font color="#006600">  if (writecount==0) signal(rsem);</font></tt></b>
<br><b><tt><font color="#006600">  signal(y);</font></tt></b>
<br><b><tt><font color="#006600"> }</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b>
</td>
</tr>
</table>
<b><tt><font color="#006600">void main()</font></tt></b>
<br><b><tt><font color="#006600">{</font></tt></b>
<br><b><tt><font color="#006600"> readcount = writecount = 0;</font></tt></b>
<br><b><tt><font color="#006600"> parbegin (reader, writer);</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b>
<br>    Общо предназначение на семафорите:
<br>- <b><tt><font color="#006600">x </font></tt></b>- коректната работа
с обща глобална променлива <b><tt><font color="#006600">readcount;</font></tt></b>
<br>- <b><tt><font color="#006600">y </font></tt></b>- коректната работа
с обща глобална променлива <b><tt><font color="#006600">writecount;</font></tt></b>
<br>- <b><tt><font color="#006600">z </font></tt></b>- осигурява предимство
на писателите;
<br>- <b><tt><font color="#006600">rsem </font></tt></b>- свободно за четене
(няма писател в КС);
<br>- <b><tt><font color="#006600">wsem </font></tt></b>- свободно за писане
(няма читатели в КС).
<br>    Двойката семафори <b><tt>z</tt></b> и <b><tt>rsem</tt></b>
осигуряват най-много един читател на опашка за семафора <b><tt>rsem</tt></b>,
което позволява преминаването на първият писател през този семафор. Така
се дава предимството на писателите.
<br> 
<table border cellspacing="0" cellpadding="4">
<tr>
<td>Състояния на системата:</td>

<td>Състояния на семафорите <b><tt>wsem</tt></b>, <b><tt>rsem</tt></b>
и <b><tt>z:</tt></b>
</td>
</tr>

<tr>
<td>Само читатели в системата</td>

<td>
<b><tt>- wsem - 1</tt></b>
<br><b><tt>- няма опашки</tt></b>
</td>
</tr>

<tr>
<td>Само писатели в системата</td>

<td>
<b><tt>- rsem - 1</tt></b>
<br><b><tt>- опашка от писатели на wsem</tt></b>
</td>
</tr>

<tr>
<td>Много читатели четат, идва писател</td>

<td>
<b><tt>- wsem е затворен (от първия читател); rsem е отворен;</tt></b>
<br><b><tt>- писателят минава и затваря rsem;</tt></b>
<br><b><tt>- писателят чака на wsem;</tt></b>
<br><b><tt>- следващият идващ читател затваря z и чака на rsem;</tt></b>
<br><b><tt>- всички други идващи читатели чакат на z;</tt></b>
<br><b><tt>- последният читател, завършил четенето, отваря wsem;</tt></b>
</td>
</tr>

<tr>
<td>Последен писател пише, чакат читатели</td>

<td>
<b><tt>- wsem е затворен (от пишещия писател);</tt></b>
<br><b><tt>- опашките са както в предишния случай;</tt></b>
<br><b><tt>- писателят свършва и отваря wsem;</tt></b>
<br><b><tt>- писателят отваря rsem;</tt></b>
<br><b><tt>- читателят, чакащ на rsem минава, отваря z и чете;</tt></b>
</td>
</tr>
</table>

<p>
</p>
<hr width="100%">
</body>
</html>
