<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>A</title>
             
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
</head>
  <body>
         <br>
 <br>
     Един от начините за решеване на задачата е генерирането 
на всички подмножества на множеството на монетите и намиране на съответните 
суми. Най - естествения начин в това отношение е пълното изчерпване, базирано 
на рекурсивен алгоритъм с връщане. На всяка стъпка към текущото множество 
от монети се добавя нова монета, след което се извършва рекурсивно обръщение. 
Всяка получена сума се проверява с търсената и при равенство се прекратява 
рекурсивния процес. Към решението може да се добави и една оптимизация, произтичаща 
от строго положителната стойност на монетите. Ще прекратяваме по - нататъшното 
търсене, ако текущата сума надхвърли проверяваната сума. Тъй като броят на 
всички подмножества на дадено n - елементно множество е <img src="Image2.gif" alt="">
 , то алгоритъма ще има експоненциална алгоритмична сложност O(<img src="Image2.gif" alt="">
 ).<br>
 <br>
<font color="#3366ff"><font color="#3333ff"> #include &lt;cstdlib&gt;<br>
 #include &lt;cstring&gt;                                                                                             
<br>
 #include &lt;fstream&gt;                                                                                                                                      
<br>
 #include &lt;iostream&gt;<br>
 using namespace std;<br>
<br>
 #define MAXCOINS  1000                                                                           
<br>
 #define MAXSUM 1000    <br>
<br>
 ifstream fin("file.inp",ios::in);                                                          
<br>
 ofstream fout("file.out",ios::out);   <br>
 unsigned coins[MAXCOINS];<br>
 bool can[MAXSUM];<br>
 unsigned sum;<br>
 unsigned n;<br>
<br>
 void Check(int ind, int cur_sum){ <br>
     if(cur_sum == sum){<br>
         fout &lt;&lt;"Yes";<br>
         exit(1);<br>
     }<br>
     for(int i=ind; i&lt;=n; i++)<br>
         if(!can[i]){<br>
            can[i]=true;<br>
            Check(i,cur_sum+coins[i]);<br>
            can[i]=false;<br>
         }<br>
 }<br>
 int main(){<br>
     while(fin &gt;&gt;sum &gt;&gt;n){<br>
         for(int i=0; i&lt;n; i++)<br>
             fin &gt;&gt;coins[i]; 
<br>
             memset(can,false,MAXSUM);<br>
             Check(0,0);<br>
             fout
&lt;&lt;"No";<br>
     }<br>
     system("PAUSE");<br>
     return 0;<br>
 }</font><br>
</font>    <br>
   
</body>
</html>
