<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
   <meta name="GENERATOR" content="Mozilla/4.75 [en] (Win98; U) [Netscape]">
   <title>l05b</title>
</head>
<body>
<b>5b. Конкуренция: взаимно изключване и синхронизация</b>
<p>5.4 Семафори
<br>&nbsp;&nbsp; Основен принцип: два или повече процеса се кооперират
в смисъл на прости сигнали така, че един процес може да бъде спрян на определено
място и да остане в това състояние, докато не получи съответен сигнал.
<br>&nbsp;&nbsp; За да изпрати сигнал чрез семафора&nbsp; <b><tt><font color="#006600">s</font></tt></b>,
процесът трябва да изпълни примитива (процедурата) <b><tt><font color="#006600">signal(s)</font></tt></b>.
За да получи сигнал от семафор <b><tt><font color="#006600">s</font></tt></b>,
процесът трябва да изпълни <b><tt><font color="#006600">wait(s)</font></tt></b>&nbsp;
и ако съответният сигнал още не е изпратен, да остане в състояние на чакане
(блокиран).
<br>Дефинирани са 3 действия с променливата семафор:
<br>&nbsp;&nbsp; 1. Инициализира се с неотрицателно число;
<br>&nbsp;&nbsp; 2. Примитива <b><tt><font color="#006600">wait(s) </font></tt></b>намалява
стойността на <b><tt><font color="#006600">s</font></tt></b> с 1. Ако стойността
стане отрицателна, процесът (изпълняващ <b><tt><font color="#006600">wait</font></tt></b>)
се блокира.
<br>&nbsp;&nbsp; 3. Операцията <b><tt><font color="#006600">signal(s) </font></tt></b>увеличава
стойността на <b><tt><font color="#006600">s</font></tt></b> с 1. Ако стойността
не е положителна, процесът (блокиран с <b><tt><font color="#006600">wait</font></tt></b>)
се разблокира.
<br>&nbsp;&nbsp;&nbsp; Примитивите <b><tt><font color="#006600">wait </font></tt></b>и
<b><tt><font color="#006600">signal
</font></tt></b>се предполат неделими, т.е. те те не могат да бъдат прекъсвани.
<br><b><tt><font color="#006600">struct semaphore {</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;int count;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;queueType queue;</font></tt></b>
<br><b><tt><font color="#006600">};</font></tt></b>
<table BORDER CELLSPACING=0 CELLPADDING=4 COLS=2 WIDTH="100%" >
<tr>
<td><b><tt><font color="#003300">void wait(semaphore s)</font></tt></b>
<br><b><tt><font color="#003300">{</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;s.count--;</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;if (s.count &lt; 0)</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;{</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; </font><font color="#660000">place
this process in s.queue;</font></tt></b>
<br><b><tt><font color="#660000">&nbsp; block this process;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;</font><font color="#003300">}</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b></td>

<td><b><tt><font color="#003300">void signal(semaphore s)</font></tt></b>
<br><b><tt><font color="#003300">{</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;s.count++;</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;if (s.count &lt;= 0)</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;{</font></tt></b>
<br><b><tt><font color="#660000">&nbsp; remove a process P from s.queue;</font></tt></b>
<br><b><tt><font color="#660000">&nbsp; place process P on ready list;</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;}</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b></td>
</tr>
</table>
Двоични семафори:
<br><b><tt><font color="#006600">struct binary_semaphore {</font></tt></b>
<br><b><tt><font color="#006600">enum (zero, one) value;</font></tt></b>
<br><b><tt><font color="#006600">queueType queue;</font></tt></b>
<br><b><tt><font color="#006600">};</font></tt></b>
<table BORDER CELLSPACING=0 CELLPADDING=4 COLS=2 WIDTH="100%" >
<tr>
<td><b><tt><font color="#006600">void waitB(binary_semaphore s)</font></tt></b>
<br><b><tt><font color="#006600">{</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;if (s.value==one) s.value=zero;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;else</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;{</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; </font><font color="#660000">place
this process in s.queue;</font></tt></b>
<br><b><tt><font color="#660000">&nbsp; block this process;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;}</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b></td>

<td><b><tt><font color="#006600">void signalB(binary_semaphore s)</font></tt></b>
<br><b><tt><font color="#006600">{</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;if (s.queue.is_empty()) s.value=one;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;else</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;{</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; </font><font color="#660000">remove
a process P from s.queue;</font></tt></b>
<br><b><tt><font color="#660000">&nbsp; place process P on ready list;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;}</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b></td>
</tr>
</table>
** Взаимно изключване - решение на задачата за ВИ със семафори:
<br><b><tt><font color="#003300">/* program mutualexclusion */</font></tt></b>
<br><b><tt><font color="#003300">const int n = /* number of processes */;</font></tt></b>
<br><b><tt><font color="#003300">semaphore s = 1;</font></tt></b>
<br><b><tt><font color="#003300">void P(int i)</font></tt></b>
<br><b><tt><font color="#003300">{</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;while (true)</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;{</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; wait(s);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; /* critical section */</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; signal(s);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; /* remainder */</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;}</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b>
<br><b><tt><font color="#003300">void main()</font></tt></b>
<br><b><tt><font color="#003300">{</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;parbegin(P(1), P(2),..., P(n));</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b>
<br>&nbsp;&nbsp;&nbsp; Стойността на променливата <b><tt><font color="#003300">s.count
</font></tt></b>има
следния смисъл:
<br>- <b><tt><font color="#003300">s.count >= 0 </font></tt></b>е броят
на процесите, които могат да изпълнят примитива <b><tt><font color="#006600">wait
</font></tt></b>без
да бъдат блокирани (и няма изпълнение на <b><tt><font color="#006600">signal</font></tt></b>);
<br>- <b><tt><font color="#003300">s.count &lt; 0 </font></tt></b>е броят
на процесите, чакащи в <b><tt><font color="#006600">s.queue.</font></tt></b>
<p>** Задачата за производител/потребител.
<br>&nbsp;&nbsp;&nbsp; Един или няколко производители генерират данни (записи,
символи) и ги поставят в един буфер. Един потребител взема по една данна
от буфера. Само един агент (производител или потребител) има достъп да
буфера в даден момент.
<br>* <b>Първи опит</b> за решение със семафори:
<br><b><tt><font color="#003300">/* program producerconsumer */</font></tt></b>
<br><b><tt><font color="#003300">int n;</font></tt></b>
<br><b><tt><font color="#003300">binary_semaphore s = 1;</font></tt></b>
<br><b><tt><font color="#003300">binary_semaphore delay = 0;</font></tt></b>
<table BORDER CELLSPACING=0 CELLPADDING=4 COLS=2 WIDTH="100%" >
<tr>
<td VALIGN=TOP><b><tt><font color="#003300">void producer()</font></tt></b>
<br><b><tt><font color="#003300">{</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;while (true)</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;{</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; produce();</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; waitB(s);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; append();&nbsp; n++;</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; if (n==1) signalB(delay);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; signalB(s);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;}</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b></td>

<td><b><tt><font color="#003300">void consumer()</font></tt></b>
<br><b><tt><font color="#003300">{</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;waitB(delay);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;while (true)</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;{</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; waitB(s);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; take();&nbsp; n--;</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; signalB(s);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; consume();</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; if (n==0) waitB(delay);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;}</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b></td>
</tr>
</table>
<b><tt><font color="#003300">void main()</font></tt></b>
<br><b><tt><font color="#003300">{ n = 0;</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; parbegin(producer, consumer);</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b>
<br><font color="#000000">&nbsp;&nbsp;&nbsp; Семафорът </font><b><tt><font color="#006600">s</font></tt></b><font color="#000000">
служи за взаимно изключване, семафорът </font><b><tt><font color="#006600">delay</font></tt></b><font color="#000000">
- за чакане на потребителя когато буферът е празен. Проблем:</font>
<table BORDER CELLPADDING=4 >
<tr>
<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>
<center><b><tt>n</tt></b></center>
</td>

<td>
<center><b><tt>delay</tt></b></center>
</td>
</tr>

<tr>
<td>
<center>1</center>
</td>

<td>
<center>Init</center>
</td>

<td>&nbsp;</td>

<td>
<center>0</center>
</td>

<td>
<center>0</center>
</td>
</tr>

<tr>
<td>
<center>2</center>
</td>

<td>
<center>Producer</center>
</td>

<td>
<center>КС</center>
</td>

<td>
<center>1</center>
</td>

<td>
<center>1</center>
</td>
</tr>

<tr>
<td>
<center>3</center>
</td>

<td>
<center>Consumer</center>
</td>

<td>
<center><b><tt>waitB(delay)</tt></b></center>
</td>

<td>
<center>1</center>
</td>

<td>
<center>0</center>
</td>
</tr>

<tr>
<td>
<center>4</center>
</td>

<td>
<center>Consumer</center>
</td>

<td>
<center>КС</center>
</td>

<td>
<center>0</center>
</td>

<td>
<center>0</center>
</td>
</tr>

<tr>
<td>
<center>5</center>
</td>

<td>
<center>Producer</center>
</td>

<td>
<center>КС</center>
</td>

<td>
<center>1</center>
</td>

<td>
<center>1</center>
</td>
</tr>

<tr>
<td>
<center>6</center>
</td>

<td>
<center>Consumer</center>
</td>

<td>
<center><b><tt><font color="#003300">if (n==0) waitB(delay)</font></tt></b></center>
</td>

<td>
<center>1</center>
</td>

<td>
<center>1</center>
</td>
</tr>

<tr>
<td>
<center>7</center>
</td>

<td>
<center>Consumer</center>
</td>

<td>
<center>КС</center>
</td>

<td>
<center>0</center>
</td>

<td>
<center>1</center>
</td>
</tr>

<tr>
<td>
<center>8</center>
</td>

<td>
<center>Consumer</center>
</td>

<td>
<center><b><tt><font color="#003300">if (n==0) waitB(delay)</font></tt></b></center>
</td>

<td>
<center>0</center>
</td>

<td>
<center>0</center>
</td>
</tr>

<tr>
<td>
<center>9</center>
</td>

<td>
<center>Consumer</center>
</td>

<td>
<center>КС</center>
</td>

<td>
<center>-1</center>
</td>

<td>
<center>0</center>
</td>
</tr>
</table>

<p>* <b>Втори опит</b> - решение:
<br><b><tt><font color="#333300">int n;</font></tt></b>
<br><b><tt><font color="#333300">binary_semaphore s = 1;</font></tt></b>
<br><b><tt><font color="#333300">binary_semaphore delay = 0;</font></tt></b>
<table BORDER CELLSPACING=0 CELLPADDING=4 COLS=2 WIDTH="100%" >
<tr>
<td VALIGN=TOP><b><tt><font color="#003300">void producer()</font></tt></b>
<br><b><tt><font color="#003300">{</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;while (true)</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;{</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; produce();</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; waitB(s);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; append();n++;</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; if (n==1) signalB(delay);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; signalB(s);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;}</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b></td>

<td><b><tt><font color="#003300">void consumer()</font></tt></b>
<br><b><tt><font color="#003300">{ int m;&nbsp; /* a local variable */</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; waitB(delay);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; while (true)</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; {</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;&nbsp; waitB(s);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;&nbsp; take(); n--;&nbsp; m = n;</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;&nbsp; signalB(s);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;&nbsp; consume();</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;&nbsp; if (m==0) waitB(delay);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; }</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b></td>
</tr>
</table>
<b><tt><font color="#003300">void main()</font></tt></b>
<br><b><tt><font color="#003300">{ n = 0;</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; parbegin (producer, consumer);</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b>
<br>--- FIGURE 5.16 ---
<br>Варианти ва задачата - безкраен буфер и краен кръгов буфер.
<p>** Задачата на бръснаря
<br>--- <a href="http://www.math.bas.bg/~nkirov/bfu/Os/F5-19.PDF">FIGURE
5.19</a> ---
<br>
<hr WIDTH="100%">
<br>5.5 Монитори.
<br>** Монитор със сигнал.
<br>&nbsp;&nbsp;&nbsp; Мониторите са програмни модули, състоящи се от една
или повече процедури, инициализация и локални данни. Главни характеристики:
<br>&nbsp;&nbsp; 1. Локалните данни са достъпни само от процедурите на
монитора.
<br>&nbsp;&nbsp; 2. Един процес "влиза в монитора" като извика някоя от
процедурите му.
<br>&nbsp;&nbsp; 3. Само един процес може да се изпълнява в монитора, всеки
друг процес чака да се "освободи" монитора.
<br>&nbsp;&nbsp;&nbsp; Променливи на условия (condition variables). Функции
с тези променливи:
<br><b><tt><font color="#006600">- cwait(c)</font></tt></b>:&nbsp; Прекратяване
изпълнението на процеса с условие <b><tt><font color="#006600">c</font></tt></b>.&nbsp;
Мониторът е достъпен за друг процес;
<br><b><tt><font color="#006600">- csignal(c)</font></tt></b>: Въобновяване
на изпълнението на процеса, прекратен с <b><tt><font color="#006600">cwait</font></tt></b>
със същото условие. Ако има няколко такива процеса се избира един от тях,
ако няма - нищо не се прави.
<br>&nbsp;&nbsp;&nbsp; Разлика със семафорите - сигналът се "загубва",
ако няма чакащи процеси за този сигнал.
<br>--- <a href="http://www.math.bas.bg/~nkirov/bfu/Os/F5-22.PDF">FIGURE
5.22</a> ---
<br><b><tt><font color="#003300">/* program producerconsumer */</font></tt></b>
<br><b><tt><font color="#003300">monitor boundedbuffer;</font></tt></b>
<br><b><tt><font color="#003300">char buffer[N];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* space for N items */</font></tt></b>
<br><b><tt><font color="#003300">int nextin, nextout;&nbsp;&nbsp;&nbsp;
/* buffer pointers */</font></tt></b>
<br><b><tt><font color="#003300">int count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* number of items in buffer */</font></tt></b>
<br><b><tt><font color="#003300">int notfull, notempty;&nbsp; /* for synchronization
*/</font></tt></b>
<table BORDER CELLSPACING=0 CELLPADDING=4 COLS=2 WIDTH="100%" >
<tr>
<td VALIGN=TOP><b><tt><font color="#003300">void append (char x)</font></tt></b>
<br><b><tt><font color="#003300">{</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;if (count == N)</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;cwait(notfull); /* buffer is оull;*/</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* avoid overflow */</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;buffer[nextin] = x;</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;nextin = (nextin + 1) % N;</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;count++; /* one more item in buffer
*/</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;csignal(notempty);&nbsp;</font></tt></b>
<br><b><tt><font color="#003300">/* resume any&nbsp; waiting consumer */</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b></td>

<td VALIGN=TOP><b><tt><font color="#003300">void take (char x)</font></tt></b>
<br><b><tt><font color="#003300">{</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;if (count == 0)</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;cwait(notempty); /* buffer is empty;*/</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* avoid underflow */</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;x = buffer[nextout];</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;nextout = (nextout + 1) % N;</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;count--; /* one fewer item in buffer
*/</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;csignal(notfull);&nbsp;</font></tt></b>
<br><b><tt><font color="#003300">/* resume any&nbsp; waiting producer */</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b></td>
</tr>
</table>
<b><tt><font color="#003300">{</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;/* monitor body */</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;nextin = 0; nextout = 0; count =
0; /* buffer initially empty */</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b>
<table BORDER CELLSPACING=0 CELLPADDING=4 COLS=2 WIDTH="100%" >
<tr>
<td><b><tt><font color="#003300">void producer()</font></tt></b>
<br><b><tt><font color="#003300">{ char x;</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; while (true)</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; {</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;&nbsp; produce(x);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;&nbsp; append(x);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; }</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b></td>

<td><b><tt><font color="#003300">void consumer()</font></tt></b>
<br><b><tt><font color="#003300">{ char x;</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; while (true)</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; {</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;&nbsp; take(x);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp;&nbsp; consume(x);</font></tt></b>
<br><b><tt><font color="#003300">&nbsp; }</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b></td>
</tr>
</table>
<b><tt><font color="#003300">void main()</font></tt></b>
<br><b><tt><font color="#003300">{ parbegin(producer, consumer);</font></tt></b>
<br><b><tt><font color="#003300">}</font></tt></b>
<br>** Монитори със съобщения и разпространение.
<br>
<hr WIDTH="100%">
<br>5.6 Предаване на съобщения.
<br>&nbsp;&nbsp;&nbsp; Синхронизация и комуникация са двата проблема на
взаимодействащи си процеси - взаимно изключване и обмен на информация.
Двете задачи се решават с обмен на съобщения. Дефинират се два примитива
(процедури):
<br><b><tt><font color="#006600">send(destination, message)</font></tt></b>
<br><b><tt><font color="#006600">receive(source, message)</font></tt></b>
<br>Съществуват различини възможности за реализация на тези 2 процедури:
<br>&nbsp;
<table BORDER CELLPADDING=4 WIDTH="100%" >
<tr>
<td><b>Synchronization</b></td>

<td><b>Addressing&nbsp;</b></td>

<td><b>Format</b></td>
</tr>

<tr>
<td>Send</td>

<td>Direct</td>

<td>Content</td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; blocking</td>

<td>&nbsp;&nbsp;&nbsp; send</td>

<td>Length&nbsp;</td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; nonblocking</td>

<td>&nbsp;&nbsp;&nbsp; receive</td>

<td>&nbsp;&nbsp;&nbsp; fixed</td>
</tr>

<tr>
<td>Receive</td>

<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; explicit</td>

<td>&nbsp;&nbsp;&nbsp; variable</td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; blocking</td>

<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implicit</td>

<td></td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; nonblocking</td>

<td>Indirect</td>

<td></td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; test for arrival</td>

<td>&nbsp;&nbsp;&nbsp; static</td>

<td><b>Queuing Discipline</b></td>
</tr>

<tr>
<td></td>

<td>&nbsp;&nbsp;&nbsp; dynamic</td>

<td>FIFO</td>
</tr>

<tr>
<td></td>

<td>&nbsp;&nbsp;&nbsp; ownership</td>

<td>Priority</td>
</tr>
</table>
** Синхронизация.
<br><b><tt>&nbsp;&nbsp;&nbsp; Send</tt></b> -&nbsp; процесът се блокира,
докато събощението бъде получено (blocking send) или процесът не се блокира
(nonblocking send).
<br><b><tt>&nbsp;&nbsp;&nbsp; Receive</tt></b> - ако съобщението е изпратено,
то се получава и процесът продължава. Ако не е изпратено: процесът се блокира
до изпращане и получавене на съобщението (blocking receive) или процесът
продължава, изоставяйки опитите за получаването му (nonblocking receive).
<br>&nbsp;&nbsp;&nbsp; Възможни са 3 комбинации :
<br>-- Blocking send, blocking receive;
<br>-- Nonblocking send, blocking receive - най-често срещано, при грешка,
могат де се генерират много съобщения;
<br>-- Nonblocking send, nonblocking receive.
<br>** Адресиране.
<br>--- FIGURE 5.24 ---
<br>** Формат на съобщенията.
<br>--- FIGURE 5.25 ---
<br>** Дисциплина на опашките.
<br>
<hr WIDTH="100%">
<br>5.7 Задачата на писатели/читатели
<br>&nbsp;&nbsp;&nbsp; Данни (файл, блок от паметта) се използват от няколко
процеса. Някои от процесите само четат тези данни - читетили, а други само
променят данните - писатели. Следните условия трябва де се спазват:
<br>&nbsp;&nbsp; 1. Произволен брой читатели могат да четат едновременно
данните;
<br>&nbsp;&nbsp; 2. Само един писател може да пише данни;
<br>&nbsp;&nbsp; 3. Ако писател пише, никой читател не може да чете.
<br>Ако всеки процес може и да пише и да чете, общото решение за ВИ работи.
<br>Ако един процес може или само да чете, или само да пише - общото решение
е неприемливо, а съществуват и много по-ефективни решения.
<br>** Предимство на читателите.
<br><b><tt><font color="#006600">/* program readersandwriters */</font></tt></b>
<br><b><tt><font color="#006600">int readcount;</font></tt></b>
<br><b><tt><font color="#006600">semaphore x = 1, wsem = 1;</font></tt></b>
<table BORDER CELLSPACING=0 CELLPADDING=4 COLS=2 WIDTH="100%" >
<tr>
<td><b><tt><font color="#006600">void reader()</font></tt></b>
<br><b><tt><font color="#006600">{ while (true)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; {</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; wait(x);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; readcount++;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; if (readcount == 1) wait(wsem);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; signal(x);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; READUNIT();</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; wait(x);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; readcount--;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; if (readcount == 0) signal(wsem);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; signal(x);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; }</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b></td>

<td VALIGN=TOP><b><tt><font color="#006600">void writer()</font></tt></b>
<br><b><tt><font color="#006600">{</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;while (true)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;{</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; wait(wsem);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; WRITEUNIT();</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; signal(wsem);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;}</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b>
<br>&nbsp;
<br>&nbsp;
<p>&nbsp;</td>
</tr>
</table>
<b><tt><font color="#006600">void main()</font></tt></b>
<br><b><tt><font color="#006600">{ readcount = 0;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; parbegin(reader, writer);</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b>
<br>** Предимство на писателите.
<br><b><tt><font color="#006600">/* program readersandwriters */</font></tt></b>
<br><b><tt><font color="#006600">int readcount, writecount;</font></tt></b>
<br><b><tt><font color="#006600">semaphore x = 1, y = 1, z = 1, wsem =
1, rsem = 1;</font></tt></b>
<br>&nbsp;
<table BORDER CELLSPACING=0 CELLPADDING=4 COLS=2 WIDTH="100%" >
<tr>
<td><b><tt><font color="#006600">void reader()</font></tt></b>
<br><b><tt><font color="#006600">{ while (true)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; {</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; wait(z);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; wait(rsem);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; wait(x);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; readcount++;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; if (readcount == 1) wait(wsem);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; signal(x);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; signal(rsem);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; signal(z);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; READUNIT();</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; wait(x);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; readcount--;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; if (readcount == 0) signal(wsem);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp; signal(x);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; }</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b></td>

<td VALIGN=TOP><b><tt><font color="#006600">void writer ()</font></tt></b>
<br><b><tt><font color="#006600">{</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;while (true)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;{</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; wait(y);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; writecount++;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; if (writecount == 1) wait(rsem);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; signal(y);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; wait(wsem);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; WRITEUNIT();</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; signal(wsem);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; wait(y);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; writecount--;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; if (writecount == 0) signal(rsem);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; signal(y);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;}</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b></td>
</tr>
</table>
<b><tt><font color="#006600">void main()</font></tt></b>
<br><b><tt><font color="#006600">{</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;readcount = writecount = 0;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;parbegin (reader, writer);</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b>
<br>&nbsp;&nbsp;&nbsp; Предназначение на семафорите:
<br>- <b><tt><font color="#006600">x </font></tt></b>- коректната работа
с <b><tt><font color="#006600">readcount;</font></tt></b>
<br>- <b><tt><font color="#006600">y </font></tt></b>- коректната работа
с <b><tt><font color="#006600">writecount;</font></tt></b>
<br>- <b><tt><font color="#006600">z </font></tt></b>-
<br>- <b><tt><font color="#006600">rsem </font></tt></b>- свободно за четене
(няма писател);
<br>- <b><tt><font color="#006600">wsem </font></tt></b>- свободно за писане
(няма читатели).
<p>*&nbsp; Решение на задачата с размяна на съобщения.
<table BORDER CELLSPACING=0 CELLPADDING=4 COLS=2 WIDTH="100%" >
<tr>
<td><b><tt><font color="#006600">void readri()</font></tt></b>
<br><b><tt><font color="#006600">{</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;message: rmsg;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;while (true)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;{</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; rmsg = i;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; send(readrequest, rmsg);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; receive(mboxi, rmsg);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; READUNIT;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; rmsg = i;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; send(finished, rmsg);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;}</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b></td>

<td><b><tt><font color="#006600">void writerj()</font></tt></b>
<br><b><tt><font color="#006600">{</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;message: rmsg;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;while (true)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;{</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; rmsg = i;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; send(writerequest, rmsg);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; receive(mboxj, rmsg);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; WRITEUNIT;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; rmsg = i;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; send(finished, rmsg);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;}</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b></td>
</tr>
</table>

<p><b><tt><font color="#006600">void controller()</font></tt></b>
<br><b><tt><font color="#006600">{ while(true)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; { if (count > 0)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp; { if (not empty(finished))</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { receive(finished,
msg);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
count++;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if
(not empty(writerequest))</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { receive(writerequest,
msg);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
writer.id = msg.id;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
count -= 100;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if
(not empty(readrequest))</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { receive(readrequest,
msg);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
count--;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
send(msg.id, "OK");</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp; }</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp; if (count==0)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp; { send(writer.id, "OK");</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; receive(finished,
msg);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count =
100</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp; }</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp; while (count&lt;0)</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp; { receive(finished,
msg);</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count++;</font></tt></b>
<br><b><tt><font color="#006600">&nbsp;&nbsp;&nbsp; }</font></tt></b>
<br><b><tt><font color="#006600">&nbsp; }</font></tt></b>
<br><b><tt><font color="#006600">}</font></tt></b>
<br>
<hr WIDTH="100%">
</body>
</html>
