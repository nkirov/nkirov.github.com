<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>t3</title>
  </head>
  <body>
    <div align="center"><big>Тест 3</big><br>
    </div>
    <big><br>
      Класът <tt>BinarySearchTree</tt> съдържа следната член-функция
      (Code Fragment 9.3):<br>
      <tt>&nbsp;void setItem(const BTPosition&amp; p, </tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        const BSTItem&amp; i) const </tt><tt><br>
      </tt><tt>&nbsp;{</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp; /*add*/</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp; p.element().setKey(i.key());</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp; p.element().setElement(i.element()); </tt><tt><br>
      </tt><tt>&nbsp;}</tt><br>
      Отбележете верни/неверни твърдения за тази функция.<br>
      <br>
      (да) Функцията поставя <tt>Item</tt> от <tt>BST</tt> (речник) на
      позиция <tt>p</tt> в <tt>LinkedBinaryTree</tt>.<br>
      (не)&nbsp; Като заместим <tt>/*add*/</tt> с <tt>Element e =
        i.element(); </tt>получаваме синтактична грешка.<br>
      <br>
      <br>
      Отбележете верни/грешни твърдения за асимпотична оценка за
      следните функции:<br>
      &nbsp;</big><big>(да) <i>n</i><sup>2</sup> e <i>O</i>(<i>n</i><sup>3</sup>)<br>
      (не) 3 + <i>n</i></big><big><sup>2</sup> e <i>o</i>(<i>n</i>)<br>
      <br>
      <br>
      Дадени са следните дефиниции:<br>
      <tt>int i = 4, j = 2, k = 1;</tt><br>
      Определете дали дадената като коментар стойност е вярна/грешна
      стойност на израза.<br>
      <br>
      (да) <tt>i -= j // 2</tt><br>
      (не) <tt>j &lt;&lt;= j // 4</tt><br>
      <br>
      <br>
      Посочете верни/неверни дефиниции и твърдения за търсещи дървета.<br>
      <br>
      (да) Търсене в AVL дърво с n члена отнема време <i>O</i>(log <i>n</i>).<br>
      (не) Всеки вътрешен възел от многоканално търсещо дърво има
      най-много две деца.<br>
      <br>
      <br>
      Дадено е (2,4) дърво АТД: <tt>T = {12}({3,6,9},{15})</tt>.
      Външните възли не са включени в представянето. Определете дали
      даденото след операцията (2,4)-дърво е получено като резултат от
      прилагане на операцията.<br>
      <br>
      (да)<tt> insertItem(1) - T={6,12}({1,3}, {9},{15})</tt><br>
      (не) <tt>insertItem(1) - T={3,12}({1,6,9},{15})</tt><br>
      <br>
      <br>
      Дадено е <font color="#ff0000">червено</font>-<b>черно</b> дърво
      АТД, като <b>черните</b> възли са <b>bold</b>, а <font
        color="#ff0000"><i>червените</i></font> - <font color="#ff0000"><i>italic</i></font>.
      Външните възли не са включени <br>
      в представянето. Определете дали даденото след операцията <font
        color="#ff0000">червено</font>-<b>черно</b> дърво е получено
      като резултат от прилагане на операцията.<br>
      <br>
      (да) <b>6</b>(<font color="#ff0000"><i>8</i></font>) -
      insertItem(7) - <b>7</b>(<font color="#ff0000"><i>6</i></font>,<font
        color="#ff0000"><i>8</i></font>)<br>
      - <b>5</b>(<font color="#ff0000"><i>7</i></font>) - insertItem(6)
      - <b>5</b>(<font color="#ff0000"><i>6</i></font>, <font
        color="#ff0000"><i>7</i></font>)<br>
      <br>
      <br>
      Прост алгоритъм за разрешаване на колизии в хеш таблици e линейно
      пробване. Даден е клетъчен масив <tt>A = {35, 14, D, 21, E, 12,
        E} </tt>с капацитет <tt>N=7</tt>, където <tt>E</tt> означава
      "empty" и <tt>D</tt> означава "deattached" (или "available")
      елемент на масива. Хеш функцията e <i>h</i>(<i>k</i>) = <i>k</i>
      mod 7. Посочете верни/неверни съответствия, като след <tt>-&gt;</tt>
      е дадено предполагаемото място на добавения елемент в масива.<br>
      <br>
      (да) <tt>insrtItem(7) -&gt; A[2] = 7</tt><br>
      (не) <tt>insrtItem(10) -&gt; A[3] = 10</tt><br>
      <br>
      <br>
      Дадено е двоично дърво АТД: <tt>T =
        a(b(c(d,e),f),g(h,i(j(k,l),m))</tt>. Дали дадената редица е част
      от редицата от възли, получена чрез Ойлерово обхождане на
      двоичното дърво?<br>
      <br>
      (да) <tt>abcd</tt><br>
      (не) <tt>ecbc</tt><br>
      <br>
      <br>
      Постройте двоично дърво, представящо следния аритметичен
      израз:&nbsp; <tt>(</tt><tt>x</tt><tt> + 2*(</tt><tt>y</tt><tt> -
        2)) / 2</tt>. Дали дадената редица е част от редицата от възли,
      получена чрез preorder обхождане на двоичното дърво?<br>
      <br>
      (да)<tt> / + x</tt><br>
      (не) <tt>x + 2</tt><br>
      <br>
      <br>
      Даден е стек АТД: <tt>S = (5,3,4,9)</tt>. Върхът на стека е <tt>5</tt>.
      Посочете вярно/невярно съответствие функция <tt>-</tt> върната
      стойност <tt>-</tt> стека <tt>S</tt> след изпълнението на
      функцията.<br>
      <br>
      (да) <tt>push(1) - NONE - S=(1,5,3,4,9)</tt><br>
      (не) <tt>push(10) - NONE - S=(5,3,4,9,10)</tt><br>
      <br>
      <br>
      Дадена е опашка АТД: <tt>Q = (8,7,2)</tt>. Начало на опашката е
      елементът <tt>8</tt>. Посочете вярно/невярно съответствие функция
    </big><big><big><tt>-</tt></big> върната стойност </big><big><big><tt>-</tt></big>
      опашката <tt>Q </tt>след изпълнението на функцията.<br>
      <br>
      (да) <tt>enqueue(5) - NONE - Q=(8,7,2,5)</tt><br>
      (не) <tt>enqueue(7) - 7 - Q=(8,7,2,7)</tt><br>
      <br>
      <br>
      Даден е дек АТД: <tt>D = (8,1,3)</tt>. Начало на дека е елемантът
      <tt>8</tt>. Посочете вярно/невярно съответствие функция </big><big><big><tt>-</tt></big>
      върната стойност </big><big><big><tt>-</tt></big> декът <tt>D </tt>след

      изпълнението на функцията.<br>
      <br>
      (да) <tt>insertFirst(5) - NONE - D =(5,8,1,3)</tt><br>
      (не) <tt>insertFirst(6) - NONE - D =(8,6,1,3)</tt><br>
      <br>
      <br>
      Дадено е AVL дърво: <tt>44(17(-,32),78(50(48,62),88))</tt>.
      Външните възли не са включени в представянето. Определете дали
      даденото след операцията AVL дърво е получено като резултат от
      прилагане на операцията.<br>
      <br>
      (да) <tt>insertItem(54)\\ 44(17(-,32),62(50(48,54),78(-,88)))</tt><br>
      (не) <tt>removeItem(32) 44(17,78(50(48,62),88))</tt><br>
      <br>
      <br>
      Дадено е двоично дърво. Да се провери дали редицата след <tt>;</tt>
      е част от inorder обхождане на дървото.<br>
      <br>
      (да) <tt>c(b(a,d),e);bdc</tt><br>
      (не) <tt>c(b(a,d),e(f,g));cfd</tt><br>
      <br>
      <br>
      Постройте двоично дърво, представящо дадения аритметичен израз и
      проверете дали редицата <tt>x2y </tt>e част от postorder
      обхождане на полученото дърво.<br>
      <br>
      (да)&nbsp; <tt>x+2*y</tt><br>
      (не) <tt>x/2-y</tt><br>
      <br>
      <br>
      Класът <tt>Position</tt> e включен в дефиницията на класа <tt>BinarySearchTree</tt>
      (Code Fragment 9.2). Отбележете верни/неверни твърдения за
      член-функцията<br>
      <tt>&nbsp;Element&amp; element()&nbsp; &nbsp;&nbsp;&nbsp;
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </tt><tt><br>
      </tt><tt>&nbsp;{ </tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp; return btPos.element().element(); </tt><tt><br>
      </tt><tt>&nbsp;}</tt><br>
      от <tt>class Position</tt>.<br>
      <br>
      (да) Върнатата стойност е псевдоним на член-данна на класа <tt>Item</tt>.<br>
      (не) <tt>btPos</tt> e член-данна в класа <tt>BinarySearchTree</tt>.<br>
      <br>
      &nbsp; <br>
      Посочете верните и неверни дефиниции и твърдения за линейни
      структури от данни.<br>
      <br>
      (да) Дек е контейнер от обекти, който поддържа добавяне и
      изваждане от двата края на редицата.<br>
      (не) Линейна редица, която поддържа достъп до елементите си чрез
      техните рангове се нарича списък.<br>
      <br>
      <br>
      Отбележете верни/грешни дефиниции за асимптотични нотации.<br>
      <br>
      (да) <i>f</i>(<i>n</i>) e <i>O</i>(<i>g</i>(<i>n</i>)), ако има
      положителни константи <i>c</i> и <i>N</i>, такива, че <i>f</i>(<i>n</i>)&lt;<i>cg</i>(<i>n</i>)
      за <i>n</i>&gt;<i>N</i>.<br>
      (не) <i>g</i>(<i>n</i>) e O(<i>f</i>(<i>n</i>)), ако има
      положителни константи <i>c</i> и <i>N</i>, такива, че <i>f</i>(<i>n</i>)&lt;<i>cg</i>(<i>n</i>)
      за всяко <i>n</i>&gt;<i>N</i>.<br>
      <br>
      <br>
      Даден е следния код:<br>
      &nbsp;<tt>void fun1() </tt><tt><br>
      </tt><tt>&nbsp;{ throw runtime_error("ERR" ); }</tt><tt><br>
      </tt><tt>&nbsp;void fun2() throw(runtime_error) </tt><tt><br>
      </tt><tt>&nbsp;{ ... }</tt><tt><br>
      </tt><tt>&nbsp;void fun3() throw(runtime_error) </tt><tt><br>
      </tt><tt>&nbsp;{ fun2(); }</tt><tt><br>
      </tt><tt>&nbsp;int main()</tt><tt><br>
      </tt><tt>&nbsp;{ try </tt><tt><br>
      </tt><tt>&nbsp;&nbsp; { fun3(); }</tt><tt><br>
      </tt><tt>&nbsp;&nbsp; catch (runtime_error e) </tt><tt><br>
      </tt><tt>&nbsp;&nbsp; { </tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp; cout &lt;&lt; e.what(); </tt><tt><br>
      </tt><tt>&nbsp;&nbsp; }</tt><tt><br>
      </tt><tt>&nbsp;&nbsp; return 0; </tt><tt><br>
      </tt><tt>&nbsp;}</tt><br>
      Като заместим <tt>...</tt> с дадения оператор, дали <tt>ERR </tt>ще

      се отпечати на екрана?<br>
      <br>
      (да) <tt>fun1();</tt><br>
      (не) <tt>fun2();</tt><br>
      <br>
      <br>
      Посочете верните/неверните дефиниции и твърдения за дървета.<br>
      <br>
      (да) Ако възел <i>u</i> е родител на възел <i>v</i>, казваме, че
      <i>v</i> е дете на <i>u</i>.<br>
      (не) Един възел е вътрешен, ако няма деца и външен, ако има едно
      или повече деца.<br>
    </big>
  </body>
</html>
