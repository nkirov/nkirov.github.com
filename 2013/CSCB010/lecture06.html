<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <title>l6</title>
  </head>
  <body>
    <h2>6.  Сортиране. Хеширане<br>
    </h2>
    <h3 style="font-weight: normal;"> <font color="#000000">Сортиране -
        общи положения; сортиране чрез сравнение</font><br>
    </h3>
    <p><big>** Класификации на алгоритмите за сортиране [Глава 3,
        стр.187]<br>
      </big></p>
    <p><big>* В зависимост от местонахождението на данните: <br>
         - вътрешно (директен достъп), например бързо сортиране и <br>
         - външно (последователен достъп), например сливане.<br>
        * В зависимост от операцията: <br>
         - чрез сравнение (<span style="font-family: monospace;">&lt;</span>,
        <span style="font-family: monospace;">&gt;</span> и <span style="font-family: monospace;">==</span>) на двойки елементи
        и <br>
         - чрез трансформация, напр. сортиране чрез броене.<br>
        * Свойство на алгоритъма за сортиране:<br>
         - устойчиви - относителният ред на елементите с равни
        ключове остава непроменен и<br>
         - неустойчиви - разместване на елементи с равни ключове
        (сортиране с 2 ключа)<br>
        * Ефективност на алгоритмите за сортиране - брой на извършени
        сравнения и размени (присвоявания).<br>
        * Използване на допълнителна памет.<br>
      </big></p>
    <big>** Дърво на сравненията; сортиране на 3 числа.<br>
      <br>
      ** Класически универсални "елементарни" методи за сортиране чрез
      сравнение <span style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span><sup>2</sup>):<br>
       - пряко вмъкване - намираме елемент, който "не е сортиран" и
      го поставяме на мястото му в сортираната част;<br>
       - пряка селекция (избор) - намираме най-малкия елемент и го
      поставяме на мястото му в окончателно сортираната част;<br>
       - мехурчето - последователно се разглеждат двойки елементи и
      евентуално се разменят.<br>
    </big>
    <p><big>** Бързо сортиране на Хоор - <span style="font-style:
          italic;">O</span>(<span style="font-style: italic;">n</span>
        log</big><sub>2</sub><big><span style="font-style: italic;">n</span>)
        средно и <span style="font-style: italic;">O</span>(<span style="font-style: italic;">n</span><sup>2</sup>) в най-лошия
        случай.<br>
      </big></p>
    <p><big>** Пирамидално сортиране, сортиране чрез сливане: <span style="font-style: italic;">O</span>(<span style="font-style:
          italic;">n</span> log</big><sub>2</sub><big><span style="font-style: italic;">n</span>) и тази оценка не може да
        се подобри при сортиране чрез сравняване.<br>
      </big></p>
    <big> </big>
    <h3 style="font-weight: normal;"><big>** <font color="#000000">Сортиране







          чрез трансформация [3.2]</font> </big></h3>
    <big>** Сортиране чрез множество [3.2.1]<br>
          Дадено е множество <span style="font-style:
        italic;">M</span> от числа в затворения интервал [<span style="font-style: italic;">a, b</span>] и инективна функция за
      нареждане <span style="font-style: italic;">f:</span> <span style="font-style: italic;">M <span style="font-family:
          monospace;">-&gt;</span> </span>[<span style="font-style:
        italic;">a, b</span>], т.е. ако <span style="font-style:
        italic;">x</span><sub>1</sub> и <span style="font-style:
        italic;">x</span><sub>2</sub> са различни, то са различни и <span style="font-style: italic;">f</span> (<span style="font-style:
        italic;">x</span><sub>1</sub>) и <span style="font-style:
        italic;">f</span> (<span style="font-style: italic;">x</span><sub>2</sub>).<br>
          Построяваме нулев масив <span style="font-family: monospace;">S</span> с индекси от <span style="font-style: italic;">a</span> до <span style="font-style: italic;">b</span> <span style="font-style:
        italic;"></span>и с едно минаване през множеството <span style="font-style: italic;">M </span>поставяме стойности 1 на <span style="font-family: monospace;">S[</span><span style="font-style: italic;">f</span> (<span style="font-style:
        italic;">x</span>)<span style="font-family: monospace;">]</span>
      за всяко <span style="font-style: italic;">x</span> от <span style="font-style: italic;">M</span><span style="font-style:
        italic;"></span><span style="font-style: italic;"></span>. 
      След това минаваме през масива <span style="font-family:
        monospace;">S</span> за да подредим елементите на <span style="font-style: italic;">M.<br>
            </span> Сложност <span style="font-style: italic;">O</span>(<span style="font-style:
        italic;">m+n</span>)<span style="font-style: italic;">, </span>където<span style="font-style: italic;"> n </span>е броят на елементите на<span style="font-style: italic;"> M</span>, а<span style="font-style:
        italic;"> m = b - a +</span> 1<span style="font-style: italic;">.</span><span style="font-style: italic;"></span> <br>
      ** Сортиране чрез броене [3.2.2] <br>
      ** Побитово сортиране [3.2.3] <br>
      ** Метод на бройните системи [3.2.4] <br>
      ** Сортиране чрез пермутация [3.2.5]<br>
      <br>
         Дадено е множество <span style="font-style: italic;">M</span>
      от <span style="font-style: italic;">n</span> елементи.
      Означаваме с <span style="font-style: italic;">S</span>
      множеството {1, 2, 3, ..., <span style="font-style: italic;">n</span>}<span style="font-style: italic;">.</span>  Функцията за
      нареждане е <span style="font-style: italic;">f:</span> <span style="font-style: italic;">S <span style="font-family:
          monospace;">-&gt;</span> </span><span style="font-style:
        italic;">S</span> е сюрективна, т.е. ако <span style="font-style: italic;">x</span><sub>1</sub> и <span style="font-style: italic;">x</span><sub>2</sub> са различни, то
      са различни и <span style="font-style: italic;">f</span> (<span style="font-style: italic;">x</span><sub>1</sub>) и <span style="font-style: italic;">f</span> (<span style="font-style:
        italic;">x</span><sub>2</sub>) и за всяко <span style="font-style: italic;">y</span> от <span style="font-style: italic;">S</span> съществува <span style="font-style: italic;">x</span> от <span style="font-style: italic;">S</span> такова, че <span style="font-style: italic;">y</span> = <span style="font-style:
        italic;">f</span> (<span style="font-style: italic;">x</span>).<br>
          Разменяме <span style="font-family:
        monospace;">m[1]</span> с <span style="font-family: monospace;">m[m[1]]</span>
      докато на <span style="font-family: monospace;">1</span>-во място
      не дойде <span style="font-family: monospace;">1</span>. После по
      същия начин с втория елемент и т.н.<br>
      <span style="font-family: monospace;">позиции <span style="text-decoration: underline;">1234567</span></span><br style="font-family: monospace;">
      <span style="font-family: monospace;">       







        <span style="font-weight: bold;">4</span>37<span style="font-weight: bold;">5</span>612</span><br>
      <span style="font-family: monospace;">       







        <span style="font-weight: bold;">5</span>374<span style="font-weight: bold;">6</span>12</span><br>
      <span style="font-family: monospace;">       







        <span style="font-weight: bold;">6</span>3745<span style="font-weight: bold;">12</span></span><br>
      <span style="font-family: monospace;"><span style="font-weight:
          bold;">        </span>1<span style="font-weight: bold;">37</span>4562</span><br>
      <span style="font-family: monospace;">       







        1<span style="font-weight: bold;">7</span>3456<span style="font-weight: bold;">2</span></span><br>
      <span style="font-family: monospace;"><span style="font-weight:
          bold;">        </span>1234567<span style="font-weight: bold;"> </span></span><br>
      <span style="font-family: monospace;"><span style="font-weight:
          bold;"></span></span>Броят на размените не недвишава <span style="font-style: italic;">n</span>, а броят на сравненията - 2<span style="font-style: italic;">n.<br>
      </span></big><big><span style="font-weight: bold;"></span></big>
    <hr style="width: 100%; height: 2px;">
    <h3>Бързо сортиране</h3>
    <font size="+1"> А. Разделяне на дялове: <br>
       1. Избираме случаен елемент </font><font size="+1"><span style="font-family: monospace;">x</span></font><font size="+1">
      от масива </font><font size="+1"><span style="font-family:
        monospace;">a</span></font><font size="+1"> <br>
       2. Преглеждаме масива отляво (от началото), докато достигнем
      до елемент </font><font size="+1"><span style="font-family:
        monospace;">&gt;</span></font><font style="font-family:
      monospace;" size="+1"> x</font><font size="+1"> </font><font size="+1"><br>
       3. Преглеждаме масива отдясно (от края), докато достигнем до
      елемент </font><font size="+1"><span style="font-family:
        monospace;">&lt; x </span></font><font size="+1"><br>
       4. Разменяме местата на двата елемента <br>
      <b><tt><font color="#006600">vector&lt;int&gt; a(n);</font></tt></b><br>
      <b><tt><font color="#006600">void partition(int x)</font></tt></b><br>
      <b><tt><font color="#006600">{</font></tt></b><br>
      <b><tt><font color="#006600"> int i=1, j=n;</font></tt></b><br>
      <b><tt><font color="#006600"> do</font></tt></b><br>
      <b><tt><font color="#006600"> {</font></tt></b><br>
      <b><tt><font color="#006600">  while (a[i] &lt; x) i++;</font></tt></b><br>
      <b><tt><font color="#006600">  while (a[j] &gt; x) j--;</font></tt></b><br>
      <b><tt><font color="#006600">  if (i&lt;=j)</font></tt></b><b><tt><font color="#006600"> { swap(a[i], a[j]);  i++; j--; }</font></tt></b><br>
      <b><tt><font color="#006600"> }</font></tt></b><br>
      <b><tt><font color="#006600"> while (i&lt;=j);</font></tt></b><br>
      <b><tt><font color="#006600">}</font></tt></b></font>
    <p><font size="+1">Б. Сортиране - след като масивът се раздели,
        двата му дяла се подлагат на същата обработка и това продължава,
        докато се получат дялове само с по един елемент. </font><br>
    </p>
    <p><b><tt><font color="#000099"><span style="color: rgb(204, 0, 0);">//







              <big><a href="sources/qsort.cpp">qsort.cpp</a></big></span><br>
            <font size="+1">void quicksort(int left, int right)</font></font></tt></b>
      <font size="+1"><br>
        <b><tt><font color="#000099">{</font></tt></b><br>
        <b><tt><font color="#000099"> int i=left, j=right;</font></tt></b><br>
        <b><tt><font color="#000099"> int x=a[(i + j)/2];</font></tt></b><br>
        <b><tt><font color="#000099"> do</font></tt></b><br>
        <b><tt><font color="#000099"> {</font></tt></b><br>
        <b><tt><font color="#000099">  while (a[i] &lt; x) i++;</font></tt></b><br>
        <b><tt><font color="#000099">  while (a[j] &gt; x) j--;</font></tt></b><br>
        <b><tt><font color="#000099">  if (i&lt;=j)</font></tt></b><br>
        <b><tt><font color="#000099">  { swap(a[i], a[j]); i++;
              j--; }</font></tt></b><br>
        <b><tt><font color="#000099"> }</font></tt></b><br>
        <b><tt><font color="#000099"> while (i&lt;=j);</font></tt></b><br>
        <b><tt><font color="#000099"> if (left&lt;j)
              quicksort(left, j);</font></tt></b><br>
        <b><tt><font color="#000099"> if (i&lt;right) quicksort(i,
              right);</font></tt></b><br>
        <b><tt><font color="#000099">}</font></tt></b></font> <br>
    </p>
    <p><big>Сортиране чрез сливане<br>
      </big></p>
    <a style="font-family: monospace;" href="sources/mergesort.cpp"><big>mergesort.cpp</big></a><br>
    <hr size="2" width="100%">
    <h3><a href="../../2012/WCP/STL/STL.pdf">Въведение в STL</a></h3>
    <h3>Сортиране в STL</h3>
    <big>- <tt>sort, qsort </tt><br>
      - контейнер <tt>set</tt></big><br>
    <hr style="width: 100%; height: 2px;">
    <h3>Хеширане</h3>
    <font size="+1">** Структура от данни речник (dictionary):
      ключ-елемент<br>
      <br>
      ** Търсене в речник<br>
      <br>
      ** Хеш-функция <span style="font-style: italic;">h</span>: key <span style="font-family: monospace;">-&gt;</span> [0, <span style="font-style: italic;">N</span>-1], пример</font> <span class="Apple-style-span" style="border-collapse: separate; color:
      rgb(0, 0, 0); font-family: 'Times New Roman'; font-style: normal;
      font-variant: normal; font-weight: normal; letter-spacing: normal;
      line-height: normal; orphans: 2; text-indent: 0px; text-transform:
      none; white-space: normal; widows: 2; word-spacing: 0px;
      font-size: medium;"><span class="Apple-style-span" style="font-size: 19px;"><span style="font-style: italic;">h</span>(<span style="font-style: italic;">x</span>) =<span class="Apple-converted-space"> </span><span style="font-style: italic;">x</span><span class="Apple-converted-space"> </span>mod<span class="Apple-converted-space"> </span><span style="font-style: italic;">N </span></span></span><br>
    <br>
    ** <font size="+1"> <a href="../NETB201/slides/ch08/ch08.html">Хеширане

        в курса <i>Структури от данни</i> (а<font size="+1">н</font>гл.)</a></font>
    <hr size="2" width="100%">
<font size="+1"><br>
      Тренинг 4<br>
      - кога каква сортиров<font size="+1">о</font>ка е възможна и/или
      най-ефективна</font><br>
    <font size="+1">- големи цели числа, типа </font><font size="+1"><tt>long


        long</tt></font><font size="+1">, максимално число от даден тип</font><br>
    <tt><font size="+1">unsigned long long k = 0; // всички битове на
        числото са нули<br>
        cout &lt;&lt; (~k) &lt;&lt; endl;  // </font></tt><tt><font size="+1"><tt><font size="+1">всички битове на числото са <font size="+1">единици</font></font></tt></font></tt><br>
    <big>отпечатва най-голямото число от този (без знак!) тип, в случая
    </big><big><tt>unsigned long long</tt> <br>
      - сравняване на големи цели числа като низов, напр.</big><br>
    <tt><font size="+1">string s1 = "1234", s2 = "99";</font></tt><br>
    <big>един начин:</big><br>
    <font size="+1"><tt>s1.length() &lt; s2.length() </tt></font><big>следва,
      че числото, записано в </big><big><font size="+1"><tt>s1 </tt></font>е
      по-малко от числото, записано в </big><font size="+1"><tt>s2<br>
      </tt></font><font size="+1"><tt>s1.length() <font size="+1">&gt;</font>
        s2.length() </tt></font><big>следва, че числото, записано в </big><big><font size="+1"><tt>s1 </tt></font>е по-голямо от числото, записано в
    </big><font size="+1"><tt>s2<br>
      </tt></font><font size="+1"><tt>s1.length() <font size="+1">==</font>
        s2.length() </tt></font><big>наредбата на числата е както
      наредбата на низовете, т. е. </big><big><font size="+1"><tt>s1
          &lt;= </tt></font></big><big><font size="+1"><tt><big><font size="+1"><tt>s</tt></font></big></tt></font></big><font size="+1"><tt>2</tt></font><br>
    <hr style="width: 100%; height: 2px;">
  </body>
</html>
