    Да научите повече за езиците за програмиране
    За да се разбере първо C + + програма
    Да разпознавате синтактични и логически грешки
    Да научите повече за алгоритми
За да използвате стандартните C + + стринг, които ще определят и манипулират символни низове
За да може да се пишат прости програми, които четат номера и текстови, обработва входа, и показва резултатите

Езици за програмиране 


    
Преразглеждане на Сталинград
Поглед отвътре към най-кървавата битка през Втората световна война



    Специална компютърна програма, така наречения компилатор превежда по-високо ниво описание в машинни инструкции за конкретен процесор.
    Съставители следват стриктни конвенции относно използването на език за програмиране. Когато компилатор чете програмните инструкции (изрази, оператори, отчети) в език за програмиране, ще ги преведат в машинен код, само ако на входа следва езикови конвенции точно.
    Строги правила за предотвратяване на по-катастрофални грешки, които биха могли да възникнат, ако компилатора "Предполагам, че".
    Има много (стотици) езици за програмиране.
    Различията в езиците за програмиране понякога са слабо, но в други моменти от съществено.
        C + +:

        ако (int_rate> 100) message_box ("Лихвен процент на грешки");

        Паскал:

        ако int_rate> 100 message_box ("Лихвен процент на грешки");

Език за програмиране Дизайн и еволюция
Общ и специфичен Езици предназначение

    Много езици за програмиране са създадени с конкретна цел.
        обработка на бази данни (SQL)
        "Изкуствен интелект"
        мултимедийна обработка (HTML)
    Със специално предназначение, езици, които не се използват много извън тяхната сфера на специализация.
    Общи езици предназначение може да се използва за всяка задача.
        Паскал: като езиково обучение (целенасочено са прости).
        C: разработени, за да бъдат преведени ефективно в бързо машинен код, с минимум домакинство.
        C + +: добавя "Обектно-ориентирано програмиране" аспекти на C.

Планирани Езици

    Планирани езици (като Pascal и Ada) са внимателно проектирани за предвиждане на нуждите на бъдещите ползватели.
    Повече помислих, отива в планираните езици.
    Характеристики на планираните езици са склонни да бъдат по-свързани една с друга.
    Дизайнерите обръщат повече внимание на четимостта и последователност.
    Добре проектирана езици са по-лесно да се използва и да се учат.

Incremental растеж

    C и C + + са езици, които са израснали на стъпки, като потребителите на езикови възприемани недостатъци, те добавят характеристики:
        1972 - оригинален дизайн на C от Денис Ричи (линк). Много компилатори добавите различни функции, поникване диалекти на C.
        1985 - Бярне Stroustrup на AT & T добавя обектно-ориентирани функции на C, създаване на C + +.
        1989 - ANSI стандарт на C разработени за преодоляване на различията между отделните версия на C.
        1998, 2003 - стандарти, разработени за нови версии на C + + (C + + стандарти комитет).
        2011-09-11: Новият C + + стандарт - C + единайсет - се публикува!
    Възрастните езици са склонни да бъде разхвърлян различни функции се добавят от хора с различни вкусове.
    Възрастните езици са променени в бързаме за решаване на конкретна необходимост, без да отчитат последиците.
    Възрастните езици натрупват смесица от функции, които не е задължително да си взаимодействат добре заедно.
    Но отглеждани езици имат предимство на пазара (C + + позволява на програмистите да използват новите функции, без да изхвърлите стария C код).
    По това време, C + + е най-добрият език за програмиране с общо предназначение.
    Целта на курса ни не е да ви научи на C + +, но да използвате C + + за преподаване на изкуството и науката на писане на компютърни програми!

Съставянето на проста програма (hello.cpp)

    [Работи]
    C + + е чувствителна (главната, Майн и главните са различни имена)
    C + + свободна форма оформление (пространства и нови редове не са важни)
        Добър вкус диктува, че използвате четене програма оформление (вж. езика С + + правила за кодиране).
        Можете да напишете цялата програма на един ред:

            INT главната () {съд << "Hello, World \ N"; връщането на 0;}

        или пишете всяка дума на отделен ред:

            INT
            главната ()
            {
            cout
            <<
            "Hello, World! \ N"
            ;
            връщане
            0
            ;
            }

    # Включват <iostream> - прочетете файла iostream.h, който съдържа определението за потока пакет за вход / изход.
    използвате пространство от имена STD; - всички имена в програмата принадлежат към "стандартното пространство от имена"
    INT главната () {... } Дефинира функция, наречена главната. Функцията е колекция от инструкциите, които се извършват конкретна задача. Всеки C + + програма трябва да имат основна функция!
    Отчети (инструкции) вътре в тялото (в рамките на фигурните скоби {...}) на основната функция се изпълняват една по една.
    Всяка декларация завършва с точка и запетая;
    Последователност от символи, затворени в цитати марка ("Hello, World \ N") се нарича низ.
        Escape последователността \ показва нов ред (единна непечатна характер).
        Използвайте \ "за да се покаже цитати и \ \ за да се покаже \.
    Операторът << означава "Изпращане до" или "на изхода поток" команда.
    връщане обозначава края на основната функция. Нулева стойност е сигнал, че програмата се проведе успешно.

Синтаксис 1.1: проста програма

заглавните файлове
използвате пространство от имена STD;
INT главната ()
{
   отчети
   връщането на 0;
}

Пример:

# Включват <iostream>
използвате пространство от имена STD;
INT главната ()
{
   съд << "Hello, World \ N";
   връщането на 0;
}

Предназначение: проста програма, с всички програмни инструкции в основна функция.

 
Грешки (синтаксис и логически грешки)

    Синтактична грешка или грешка по време на компилация:
        Нещо, което нарушава езиковите правила.
        Състав намира грешка.

        легло << "Hello, World \ N";
        съд << "Hello, World \";

    Run-време грешка:
        Програма компилира и изпълнява, но операционната система прекратява изпълнението.
        Невъзможно операция, например деление на нула.
        Автор програма, трябва да тествате и да откриете грешката.

        съд << 1 / (4 - 2 * 2);

        Преливане и препълване грешки могат да възникнат, когато в резултат на изчисление е извън числов диапазон на компютъра (т.е. или много голям, 101000 или много малки, 10-1000 в абсолютна стойност).
    Logic грешка
        Програмата не направи това, което трябваше да направя - ще се компилира и работи, но неговата продукция ще бъде наред.
        Автор програма, трябва да тествате и да откриете грешката.

        съд << "По дяволите, World \ N";

    Изчисляване точност (roundoff грешка)
        Стойност не може да бъде представен точно
        Пример: 1/3 = 0.333333 ... 1 - 3 * (1/3) = 0.000001
    Структуриране програми, така че грешка в място не предизвика катастрофална реакция се нарича защитна програмиране.
    Програмна грешка обикновено се нарича бъг специални софтуерни инструменти, наречени дебъгерите ви помогне да намерите бъгове.

Вход и изход (coins2.cpp)
Програмата може да попитам колко монети имам от всякакъв вид, и след това да се изчисли общата сума.

    Оператор на входния поток (>>) гласи конзола вход:

        CIN >> пари;

    Програмата чака на потребителя да въведете номер и клавиша.
    Номер се поставя в променливата, а програмата изпълнява следващия отчет.
    Ако потребителят не влиза в съответния вход, тогава потока не успее (комплекти CIN в "неиздържал"). Всяка по-нататъшна вход също се провали.
    [Г]
    Можеш да прочетеш няколко стойности:

        CIN >> стотинки >> петачета >> Dimes >> тримесечия;

    Потребителят влиза вход, разделени с интервали или нови редове, например

        8 0 4 3

    или

        8
        0
        4
        3

    Входен буфер. Ако въведете два входа на един ред, втората се запазва за следващия отчет за вход.
    [Г]

Синтаксис 2.4: Декларация Input

CIN >> variable1 >> variable2 >> ... >> Variablen;

Пример:

CIN >> пари;
CIN >> първият >> среда >> последна;

Предназначение: Прочетете стойността на една или повече променливи в от конзолата.
Константи (volume1.cpp)

    Даване на символни имена на константи прави програмите по-лесно да четат и променят.
    Пример: Да предположим, че преминавате от 2-литрова бутилка за половин литрови бутилки:
        Трябва да намери всеки две в програмата.
        Преценете дали брой представлява бутилка обем, или нещо друго.
        Заменете я с 1,893, ако е необходимо.
    Константи означава само промяна на програмата на едно място.

Константи (volume2.cpp)

Синтаксис 2.7: Constant Definition

Const type_name constant_name = initial_value;

Пример:

Const двойно LITER_PER_OZ = 0.029586

Цел: Определяне на нова константа на определен тип и доставка на стойността му.
Strings

    Низ е последователност от символи.
    За да използвате тип низ, включва заглавния файл за низове: # Включват <string>.
    C + + стрингове са затворени в кавички, които не са част от низ.
    Низ тип се държи като редица видове по отношение на декларация, задача, изхода и входа:

        низ име = "Иван" / / деклариране и инициализация
        име = "Карл"; / / задача
        съд << име << ", моля, въведете вашето име:"; / / извежда
        CIN >> име / / вход (спира на първото пространство)

    Използвайте изявление

        getline (CIN, име);

    да прочетете всички клавиши, докато Enter ключ; напр. Ако потребителят тип

        Хари Hacker

Strings (член-функции)

    Броят на знаците в низ се нарича дължина на низа.
    Можете да се изчисли дължината на низ с дължина () функцията.
    Дължината функция е член функция, и трябва да се ползва с помощта на точкова нотация.

    Име
    
    Цел
    s.length ()
    Дължината на S
    s.substr (н)
    Подниз дължина н а започвайки от индекс
    getline (F, S)
    Прочети низ от входния поток е

Синтаксис 2.9: Член извикване на функция

expression.function_name (израз1, expressioun2, ..., expressionn)

Пример:

name.length ()
name.substr (0, N - 1)

Цел: Резултатът на повикващата функция и предоставяне на стойности за функционални параметри.

 
Strings (поднизове)

    Substr (начало, дължина) член функция се използва за извличане на поднизове.

        низ поздрав = "Hello, World \ N";
        низ под = greeting.substr (0,4);
        / * Под "Ада" * /

    Номерата на позициите в низ започва от 0. Последният знак винаги е с един по-малко от дължината на низа.

        H
        
        д
        
        л
        
        л
        
        о
        
        ,
        
        
        W
        
        о
        
        R
        
        л
        
        г
        
        !
        
        \ N
        0
        
        1
        
        2
        
        3
        
        4
        
        5
        
        6
        
        7
        
        8
        
        9
        
        10
        
        11
        
        12
        
        13

    низ w = greeting.substr (7, 5);

        H
        
        д
        
        л
        
        л
        
        о
        
        ,
        
        
        W
        
        о
        
        R
        
        л
        
        г
        
        !
        
        \ N
        0
        
        1
        
        2
        
        3
        
        4
        
        5
        
        6
        
        7
        
        8
        
        9
        
        10
        
        11
        
        12
        
        13

Strings (конкатенация)

    Конкатенира Операторът + две струни.

        низ fname = "Хари";
        низ lname = "Hacker";
        низ име = fname + "" + lname;

    Едната или двете струни около + трябва да бъде променливо.

Strings (initials.cpp)
Strings (Output форматиране)

    Неформатиран изход:

        съд << пари << "" << пари * 0,01 << "\";
        съд << петачета << "" << петачета * 0,05 << "\";
        съд << Dimes << "" << Dimes * 0.1 << "\";
        съд << квартали << "" << четвърти * 0,25 << "\";

    ще произвежда (form1.cpp):

     Един 0,01
     12 0.60
     4 0.40
     Сто и двайсет 30,00

    За да форматирате изход, ние използваме манипулатори, достъпни чрез включване # включват <iomanip>
    Setw () манипулатор определя ширината на полето на следващия изход.
    Setprecision () манипулатор се използва за задаване на точността на следващото число с плаваща запетая.
    С помощта на фиксирана манипулатор, ви гарантира, че крайните нули се показват.
    Последователност от команди

        съд << фиксирана << setprecision (2);
        съд << setw (8) << пари << ""
             << Setw (8) << пари * 0,01 << "\";
        съд << setw (8) << петачета << ""
             << Setw (8) << петачета * 0,05 << "\";
        съд << setw (8) << Dimes << ""
             << Setw (8) << Dimes * 0.1 << "\";
        съд << setw (8) << квартали << ""
             << Setw (8) << четвърти * 0,25 << "\";

    създава таблицата (form2.cpp):