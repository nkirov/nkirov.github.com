<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;
      charset=windows-1251">
    <meta name="GENERATOR" content="Mozilla/4.75 [en] (Win98; U)
      [Netscape]">
    <title>Тest 3</title>
  </head>
  <body>
    <center>
      <h3>ТЕСТ 3<br>
      </h3>
      <p><b>въпросите на теста, един верен отговор (да), и един грешен
          "отговор" (не)</b><br>
      </p>
    </center>
    Отбележете с "да" операторите за дефиниране на обекти и указатели
    към обекти от класовете <tt>Time</tt> и <tt>Employee</tt>, дадени
    в учебника на К. Хорстман.<br>
    <br>
    (да) <tt>Employee harry("Harry", 20000);</tt><br>
    (не)<tt> Employee johny("Johny");</tt><br>
    <hr size="2" width="100%">Дадена са следната декларация на функция:<br>
    <br>
    <tt>void solve(int, int&amp;);</tt><br>
    <br>
    Отбележете верните и неверни оператори, съдържащи извикване на
    функцията. Предполгаме, че цялата променлива <tt>task</tt> е
    дефинирана и има стойност 0.<br>
    <br>
    (да)<tt> solve(10, task);</tt><br>
    (не) <tt>solve(task, 10);</tt><br>
    <hr size="2" width="100%">Дадени са следните дефиниции:<br>
    &nbsp;<br>
    <tt>class Sim {</tt><tt><br>
    </tt><tt>public:&nbsp;&nbsp; Sim() { x = 0; }</tt><tt><br>
    </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int
      get_x() const { return x; }</tt><tt><br>
    </tt><tt>private:&nbsp; int x;</tt><tt><br>
    </tt><tt>};</tt><tt><br>
    </tt><tt>Sim t, *ptr_t = &amp;t, &amp;ref_t = t;</tt><br>
    <br>
    Отбележете&nbsp; с "да" обръщенията към функцията <tt>get_x</tt> на
    класа <tt>Sim</tt> от функция <tt>main</tt>, които не са
    синтактични грешки.<br>
    <br>
    (да) <tt>t.get_x()</tt><br>
    (не) <tt>t-&gt;get_x()</tt><br>
    <hr size="2" width="100%">Даден е вектор и стойности на елементите
    му:<br>
    <br>
    <tt>vector&lt;int&gt; v(2); </tt><tt><br>
    </tt><tt>v[0] = 1; </tt><tt><br>
    </tt><tt>v[1] = 3; </tt><br>
    <br>
    Отбележете верни и грешни (относно синтаксис и/или логика)
    оператори.<br>
    <br>
    (да) <tt>cin &gt;&gt; v[0];</tt><br>
    (не) <tt>cout &lt;&lt; v[2];</tt><br>
    <hr size="2" width="100%">Дадена са следните дефиниции на класове:<br>
    <br>
    <tt>class Animal { ... };</tt><tt><br>
    </tt><tt>class Dog : public Animal { ... };</tt><br>
    &nbsp;<br>
    Определете верните и неверните твърдения за връзките между класовете
    <tt>Animal</tt> и <tt>Dog</tt>:<br>
    <br>
    (да) Класът <tt>Dog</tt> е производен клас на класа <tt>Animal</tt>.<br>
    (не) Класът <tt>Animal</tt> е производен клас на класа <tt>Dog</tt>.<br>
    <hr size="2" width="100%">Дадени са файловите променливи:<br>
    &nbsp;<br>
    <tt>ifstream fi;</tt><tt><br>
    </tt><tt>ofstream fo;</tt><tt><br>
    </tt><tt>fstream fio;</tt><br>
    <br>
    и променливите:<br>
    <br>
    <tt>int k = 10;</tt><tt><br>
    </tt><tt>double x = 1.1;</tt><tt><br>
    </tt><tt>char ch = 'Y';</tt><tt><br>
    </tt><tt>string s = "No";</tt><br>
    &nbsp;<br>
    Отбележете верните оператори с използване на файлови променливи.<br>
    <br>
    (да) <tt>fo &lt;&lt; x;</tt><br>
    (не)<tt> </tt><tt>fo &gt;&gt; x;</tt>
    <hr size="2" width="100%">Даден е свързан списък от цели числа,
    състоящ се от 3 елемента.<br>
    <br>
    <tt>class Node2 { Node2 *nn, *pp; int number; };</tt><tt><br>
    </tt><tt>Node2 *h;</tt><tt><br>
    </tt><br>
    Полето <tt>nn</tt> съдържа адреса на следващия елемент, а полето <tt>pp</tt>
    - адреса на предишния елемент от списъка. <tt>h</tt> е указател,
    съдържащ адреса за първия елемент на списъка. Определете верните и
    неверните твърдения.<br>
    <br>
    (да) <tt>h-&gt;pp</tt> е <tt>NULL</tt><br>
    (не) <tt>(h-&gt;pp)-&gt;number</tt> е цяло число.<br>
    <hr size="2" width="100%">Възможно ли е да се предефинира следващата
    операция за обекти от класа <tt>Tim</tt><tt>e</tt>, като използваме
    следната декларация на обикновена функция?<br>
    <br>
    (не) <tt>bool operator&gt;(Time);</tt><br>
    (да) <tt>long operator-(Time, Time); </tt><br>
    <hr size="2" width="100%">Възможно ли е да се предефинира следващата
    операция за обекти от класа <tt>Tim</tt><tt>e</tt>, като използваме
    следната декларация на член-функция от класа <tt>Tim</tt><tt>e</tt>?<br>
    <br>
    (да) <tt>bool Time::operator==(Time);</tt><br>
    (не)<tt> </tt><tt>istream&amp; Time::operator&gt;&gt;(Time&amp;);</tt><br>
    <hr size="2" width="100%">Може ли даденият ред от програма да бъде
    дефиниция на деструктор?<br>
    <br>
    (да) <tt>Department::~Department() {}</tt><br>
    (не) <tt>Dept::~Department() {}</tt><br>
    <hr width="100%">
    Дадена е следната част от програма:<br>
    <br>
    <tt>void fun3() { throw runtime_error("RTE" ); }</tt><tt><br>
    </tt><tt>void fun2() throw(runtime_error) { ... }</tt><tt><br>
    </tt><tt>void fun1() throw(runtime_error) { fun2(); }</tt><tt><br>
    </tt><tt>int main()</tt><tt><br>
    </tt><tt>{ try { fun1(); }</tt><tt><br>
    </tt><tt>&nbsp; catch (runtime_error e) { cout&lt;&lt;e.what(); }</tt><tt><br>
    </tt><tt>&nbsp; return 0; }</tt><br>
    &nbsp;<br>
    Отбележете с "да" онзи оператор от блока на <tt>fun2</tt>, който ще
    предизвика отпечатване на екрана на съобщение <tt>RTE</tt>.<br>
    <br>
    (да) <tt>fun3();</tt><br>
    (не) <tt>fun1();</tt><br>
    <hr width="100%">Дадена е част от програма:<br>
    <br>
    <tt>class Vec { int *p;</tt><tt><br>
    </tt><tt>public:</tt><tt><br>
    </tt><tt>&nbsp;&nbsp; class Range {</tt><tt><br>
    </tt><tt>&nbsp;&nbsp; public:</tt><tt><br>
    </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp; int index;</tt><tt><br>
    </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp; Range(int j):index(j) {} };</tt><tt><br>
    </tt><tt>&nbsp;&nbsp; int&amp; operator[](int i)</tt><tt><br>
    </tt><tt>{ if (0&lt;=i &amp;&amp; i&lt;100) return p[i]; throw
      Range(i); }</tt><tt><br>
    </tt><tt>... };</tt><tt><br>
    </tt><tt>void do_any(Vec &amp; w);</tt><tt><br>
    </tt><tt>void do_some(Vec &amp; w);</tt><tt><br>
    </tt><tt>void f(Vec &amp; v)</tt><tt><br>
    </tt><tt>{ do_any(v);</tt><tt><br>
    </tt><tt>&nbsp; try { do_some(v); }</tt><tt><br>
    </tt><tt>&nbsp; catch(Vec::Range r)</tt><tt><br>
    </tt><tt>&nbsp; { cerr &lt;&lt; "ERROR" &lt;&lt; r.index; ... } ...</tt><tt><br>
    </tt><tt>} ...</tt><br>
    <br>
    Верни ли са следните твърдения?<br>
    <br>
    (да) <tt>r</tt> е обект от тип <tt>Vec::Range</tt>.<br>
    (не) <tt>r</tt> е обект от тип <tt>Range.</tt>
    <hr width="100%">
  </body>
</html>
