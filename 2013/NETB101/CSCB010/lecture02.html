<!DOCTYPE HTML PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=windows-1251">
  <meta name="Author" content="Nikolay Kirov">
  <meta name="GENERATOR"
 content="Mozilla/4.75 [en] (Win98; U) [Netscape]">
  <title>l2</title>
</head>
<body>
<h3><span style="font-weight: normal;">
2. Оценка и сложност на алгоритми [1.4] </span><br>
</h3>
<font color="#000000">&nbsp;&nbsp;&nbsp; Три главни свойства на
компютърен алгоритъм:</font>
<li><font color="#000000">простота и елегантност;</font></li>
<li> <font color="#000000">коректност;</font></li>
<li> <font color="#000000">бързодействие.</font></li>
<br>
<font color="#000000">&nbsp;&nbsp;&nbsp; Нека разгледаме следния
програмен
фрагмент:</font>
<p><b><tt><font color="#006600">cin &gt;&gt; n;</font></tt></b>
<br>
<b><tt><font color="#006600">sum = 0;</font></tt></b>
<br>
<b><tt><font color="#006600">for (i=0; i&lt;n; i++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;for (j=0; j&lt;n; j++) sum++;</font></tt></b>
<br>
&nbsp;
<table width="100%" cellpadding="6" cols="2">
  <tbody>
    <tr>
      <td valign="top"><font color="#000000">Колко бързо ще работи
горната програма,
т.е. какви са критериите по които се определя бързината й? Това, което
можем да направим експериментално е да проверим за колко време ще се
изпълни
и ще завърши работата си. За да изследваме по-общо нейното поведение е
възможно да я изпълним за други стойности на </font><span
 style="font-style: italic;">n.</span><font color="#000000"> <br>
      <br>
Резултатите
от последното са обобщени в следната таблица:</font></td>
      <td>
      <center>
      <table border="1" cellpadding="6" cellspacing="0">
        <tbody>
          <tr>
            <td>Размер на входа <br>
            <span style="font-style: italic;">n</span></td>
            <td>Време за изпълнение <br>
сек.</td>
          </tr>
          <tr>
            <td>10</td>
            <td>10<sup>-6</sup></td>
          </tr>
          <tr>
            <td>100</td>
            <td>10<sup>-4</sup></td>
          </tr>
          <tr>
            <td>1000</td>
            <td>0.01</td>
          </tr>
          <tr>
            <td>10<sup>4</sup></td>
            <td>1.071</td>
          </tr>
          <tr>
            <td>10<sup>6</sup></td>
            <td>106.5</td>
          </tr>
          <tr>
            <td>10<sup>8</sup></td>
            <td>10663.6</td>
          </tr>
        </tbody>
      </table>
      </center>
      </td>
    </tr>
  </tbody>
</table>
<font color="#000000">От таблицата се вижда, че когато увеличаваме
</font><font color="#000000"><span style="font-style: italic;">n</span><span
 style="font-style: italic;">
</span>(</font><font color="#000000">размерността на входа)</font><font
 color="#000000"><span style="font-style: italic;"></span></font><font
 color="#000000">10 пъти, времето за изпълнение се
увеличава 100 пъти.</font>
<br>
<font color="#000000">Времето за изпълнение е пророрционално на&nbsp; <i>f
</i>(<i>n</i>)<i> =
c</i><sub>1</sub><i>n</i><sup>2 </sup>+ <i>c</i><sub>2</sub><i>n</i>+
<i>c</i><sub>3</sub>,
където <i>c</i><sub>1</sub>, <i>c</i><sub>2</sub>,
<i>c</i><sub>3</sub>
са константи, които могат да се определят от дадената част от
програмата.</font>
<br>
&nbsp;
<table width="100%" border="0" cellpadding="6" cols="2">
  <tbody>
    <tr>
      <td valign="top"><font color="#000000">Сравняване на двете
функции <i>f </i>(<i>n</i>)<i>= </i>2<i>n</i><sup>2 </sup>и <i>g</i>(<i>n</i>)<i>=





      </i>200<i>n</i>,
които показват времето за изпълнение на два дадени алгоритъма А<sub>1</sub>
и A<sub>2</sub>, в зависимост от <i>n</i>.&nbsp;</font> <br>
&nbsp; <br>
&nbsp;
      <p>Асимптотично алгоритъмът A<sub>2</sub> е по-бърз и неговата
сложност
е линейна, докато тази на A<sub>1</sub> е квадратична.</p>
      </td>
      <td>
      <center>
      <table border="1" cellpadding="6" cellspacing="0">
        <tbody>
          <tr>
            <td><i><font color="#000000">n</font></i></td>
            <td><font color="#000000"><i>f </i>(<i>n</i>)</font></td>
            <td><font color="#000000"><i>g</i>(<i>n</i>)</font></td>
          </tr>
          <tr>
            <td>1</td>
            <td>2</td>
            <td>200</td>
          </tr>
          <tr>
            <td>10</td>
            <td>200</td>
            <td>2000</td>
          </tr>
          <tr>
            <td>100</td>
            <td>2.10<sup>4</sup></td>
            <td>2.10<sup>4</sup></td>
          </tr>
          <tr>
            <td>1000</td>
            <td>2.10<sup>6</sup></td>
            <td>2.10<sup>5</sup></td>
          </tr>
          <tr>
            <td>10<sup>4</sup></td>
            <td>2.10<sup>8</sup></td>
            <td>2.10<sup>6</sup></td>
          </tr>
          <tr>
            <td>10<sup>6</sup></td>
            <td>2.10<sup>12</sup></td>
            <td>2.10<sup>8</sup></td>
          </tr>
        </tbody>
      </table>
      </center>
      </td>
    </tr>
  </tbody>
</table>
</p>
<h4><font color="#000000">&nbsp;<span style="font-weight: bold;">Размер
на входните данни</span></font></h4>
<p><font color="#000000">&nbsp;&nbsp;&nbsp; Нека е дадена задача, в
която
размерът на входните данни е определен от дадено цяло число <i>n</i>.
Почти
всички задачи, които ще разглеждаме, притежават това свойство. Ще
поясним
последното като разгледаме няколко примера:</font>
</p>
<p><font style="font-weight: bold;" color="#000000">Пример 1.</font><span
 style="font-weight: bold;">
</span><br>
<font color="#000000">Да се сортира масив с <i>n</i> елемента.</font>
<br>
<font color="#000000">Размерът на входните данни се определя от броя
<i>n
</i>на
елементите на масива .</font>
</p>
<p><font style="font-weight: bold;" color="#000000">Пример 2.</font><span
 style="font-weight: bold;">
</span><br>
<font color="#000000">Да се намери най-големият общ делител на <i>a</i>
и <i>b</i>.</font>
<br>
<font color="#000000">В този пример размерът на входните данни се
определя
от броя на двоичните цифри (битовете) на по-голямото от числата <i>a</i>
и <i>b</i>.</font>
</p>
<p><font style="font-weight: bold;" color="#000000">Пример 3.</font><span
 style="font-weight: bold;">
</span><br>
<font color="#000000">Да се намери покриващо дърво на граф.</font>
<br>
<font color="#000000">В този случай характеризираме размера на входа
с две числа: брой на върховете и брой на ребрата.</font>
</p>
<h4><font color="#000000">Асимптотична нотация</font></h4>
<p><font color="#000000">&nbsp;&nbsp;&nbsp; Когато се интересуваме от
сложността
на алгоритъм най-често се интересуваме как ще работи при достатъчно
голям
размер <span style="font-style: italic;">n</span> на входните данни.
При формалното оценяване на сложността на алгоритмите
изследваме поведението им при "достатъчно голямо" <i>n</i>, т.е.
клонящо към
безкрайност.</font>
</p>
<p><font color="#000000">1.<i> O</i>(<i>F</i>) определя множеството от
всички функции&nbsp; <i>f</i>, които нарастват <b>не</b> по-бързо от <i>F</i>,
т.е.
съществува
константа
<i>c </i>&gt; 0 такава, че <i>f </i>(<i>n</i>)
&lt;=
<i>cF</i>(<i>n</i>),
за всички достатъчно големи стойности на
<i>n.</i></font>
</p>
<p>2. <i><font face="Symbol">Theta </font></i><font color="#000000">(<i>F</i>)
определя
множеството
от
всички
функции
<i>f</i>, които нарастват
толкова
бързо, колкото и <i>F</i> (с точност до константен множител), т.е.
съществуват
константи <i>c</i><sub>1</sub><i> </i>&gt; 0 и <i>c</i><sub>2</sub><i>
</i>&gt;
0 такава, че <i>c</i><sub>1</sub><i>F</i>(<i>n</i>) &lt;=&nbsp; <i>f </i>(<i>n</i>)
&lt;=
<i>c</i><sub>2</sub><i>F</i>(<i>n</i>), за всички достатъчно
големи
стойности на
<i>n.</i></font>
</p>
<p><font color="#000000">3. <i><font face="Symbol">Omega </font></i>(<i>F</i>)
определя
множеството
от
всички
функции
<i>f</i>, които нарастват <b>не</b>
по-бавно
от <i>F</i>, т.е. съществува константа <i>c </i>&gt; 0 такава, че
<i>f </i>(<i>n</i>)
&gt;= <i>cF</i>(<i>n</i>), за всички достатъчно големи стойности на
<i>n.</i></font>
</p>
<p style="font-weight: bold;"><font color="#000000"><i>O</i>(<i>F</i>):
Свойства и примери</font>
</p>
<p><font color="#000000">Нотацията <i>О</i>(<i>f</i>) е най-често
използваната
при оценка на сложност на алгоритми и програми.</font>
<br>
<font color="#000000">По-важни свойства на </font><font color="#000000"><i>О</i>(<i>f</i>)</font><font
 color="#000000"> (с ~ означаваме принадлежност):</font>
</p>
<li><font color="#000000">&nbsp;рефлексивност: <i>f</i> <span
 style="font-family: symbol;">~</span><i> О</i>( <i>f </i>);</font></li>
<li> <font color="#000000">транзитивност: ако <i>f</i> ~<i> О</i>(<i>g</i>),<i>
g</i> <font face="Symbol">~ </font><i>О</i>(<i>h</i>), то&nbsp; <i>f</i><span
 style="font-family: symbol;"> ~</span> <i>О</i>(<i>h</i>);</font></li>
<li> <font color="#000000">транспонирана симетрия:&nbsp; ако <i>f</i>&nbsp;





  <font face="Symbol">~ <i>Omega </i></font>(<i>g</i>),
то <i>g</i> <font face="Symbol">~ </font><i>O</i>( <i>f </i>) и
обратно;</font></li>
<li> <font color="#000000">константите могат да бъдат игнорирани: за
всяко <i>k
&gt; </i>0, <i>kF</i><span style="font-family: symbol;"> ~ </span><i>О</i>(<i>F</i>);</font></li>
<li> <font color="#000000"><i>n</i>, повдигнато в по-висока степен,
нараства
по-бързо: <i>n<sup>r</sup></i><span style="font-family: symbol;">~ </span><i>О</i>(<i>n<sup>s</sup></i>),
за
0
&lt;


  <i>r</i> &lt; <i>s</i>.</font></li>
<li> <font color="#000000">нарастването на сума от функции се определя
от
най-бързо
нарастващата от тях: <i>f + g</i> ~ max(<i>O</i>( <i>f </i>), <i>O</i>(<i>g</i>));</font></li>
<li> <font color="#000000">ако <i>f</i>(<i>n</i>) е полином от степен
  <i>d</i>,
то <i>f</i><font face="Symbol"> ~ </font><i>О</i>(<i>n<sup>d</sup></i>);</font></li>
<li> <font color="#000000">ако <i>f</i> нараства по-бързо от <i>g</i>,
а




  <i>g</i>
нараства по-бързо от <i>h</i>, то следва, че <i>f</i> нараства
по-бързо
от <i>h.</i></font></li>
<p style="font-weight: bold;"><font color="#000000">Нарастване на
най-често използваните функции:</font>
</p>
<center>
<table width="59%" border="1" cellpadding="4" cellspacing="0" cols="6">
  <tbody>
    <tr>
      <td>
      <center>Функция / <span style="font-style: italic;">n</span><br>
      </center>
      </td>
      <td>
      <center>1</center>
      </td>
      <td>
      <center>2</center>
      </td>
      <td>
      <center>10</center>
      </td>
      <td>
      <center>100</center>
      </td>
      <td>
      <center>1000</center>
      </td>
    </tr>
    <tr>
      <td>
      <center>5</center>
      </td>
      <td>
      <center>5</center>
      </td>
      <td>
      <center>5</center>
      </td>
      <td>
      <center>5</center>
      </td>
      <td>
      <center>5</center>
      </td>
      <td>
      <center>5</center>
      </td>
    </tr>
    <tr>
      <td>
      <center>log <i>n</i></center>
      </td>
      <td>
      <center>0</center>
      </td>
      <td>
      <center>1</center>
      </td>
      <td>
      <center>3.32</center>
      </td>
      <td>
      <center>6.64</center>
      </td>
      <td>
      <center>9.96</center>
      </td>
    </tr>
    <tr>
      <td>
      <center><i>n</i></center>
      </td>
      <td>
      <center>1</center>
      </td>
      <td>
      <center>2</center>
      </td>
      <td>
      <center>10</center>
      </td>
      <td>
      <center>100</center>
      </td>
      <td>
      <center>1000</center>
      </td>
    </tr>
    <tr>
      <td>
      <center><i>n</i> log <i>n</i></center>
      </td>
      <td>
      <center>0</center>
      </td>
      <td>
      <center>2</center>
      </td>
      <td>
      <center>33.2</center>
      </td>
      <td>
      <center>664</center>
      </td>
      <td>
      <center>9996</center>
      </td>
    </tr>
    <tr>
      <td>
      <center><i>n</i><sup>2</sup></center>
      </td>
      <td>
      <center>1</center>
      </td>
      <td>
      <center>4</center>
      </td>
      <td>
      <center>100</center>
      </td>
      <td>
      <center>10<sup>4</sup></center>
      </td>
      <td>
      <center>10<sup>6</sup></center>
      </td>
    </tr>
    <tr>
      <td>
      <center><i>n</i><sup>3</sup></center>
      </td>
      <td>
      <center>1</center>
      </td>
      <td>
      <center>8</center>
      </td>
      <td>
      <center>1000</center>
      </td>
      <td>
      <center>10<sup>6</sup></center>
      </td>
      <td>
      <center>10<sup>9</sup></center>
      </td>
    </tr>
    <tr>
      <td>
      <center>2<i><sup>n</sup></i></center>
      </td>
      <td>
      <center>2</center>
      </td>
      <td>
      <center>4</center>
      </td>
      <td>
      <center>1024</center>
      </td>
      <td>
      <center>10<sup>30</sup></center>
      </td>
      <td>
      <center>10<sup>300</sup></center>
      </td>
    </tr>
    <tr>
      <td>
      <center><i>n</i>!</center>
      </td>
      <td>
      <center>1</center>
      </td>
      <td>
      <center>2</center>
      </td>
      <td>
      <center>3628800</center>
      </td>
      <td>
      <center>10<sup>157</sup></center>
      </td>
      <td>
      <center>10<sup>2567</sup></center>
      </td>
    </tr>
    <tr>
      <td>
      <center><i>n<sup>n</sup></i></center>
      </td>
      <td>
      <center>1</center>
      </td>
      <td>
      <center>4</center>
      </td>
      <td>
      <center>10<sup>10</sup></center>
      </td>
      <td>
      <center>10<sup>200</sup></center>
      </td>
      <td>
      <center>10<sup>3000</sup></center>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><font color="#000000">Определяне на сложност на алгоритъм:</font>
<br>
<font color="#000000">- елементарна операция - не зависи от размера
на обработваните данни - <i>O</i>(1) ;</font>
<br>
<font color="#000000">- последователност от оператори - определя се
от асимтотично най-бавния -&nbsp; <i>f + g</i> </font><font
 color="#000000"><span style="font-family: symbol;">~</span></font><font
 color="#000000">
max(<i>O</i>(
<i>f
</i>),
<i>O</i>(<i>g</i>));</font>
<br>
<font color="#000000">- композиция на оператори - произведение от
сложностите - <i>f&nbsp; g</i> </font><font color="#000000"><span
 style="font-family: symbol;">~</span></font><font color="#000000"> <i>O</i>(
<i>f g</i>);</font>
<br>
- условни оператори - <font color="#000000">определя се от асимтотично
най-бавния между условието и различните случаи;</font>
<br>
<font color="#000000">- цикли, вложени цикли - <i>O</i>(<i>n</i>),
<i>O</i>(<i>n<sup>p</sup></i>) .</font>
</p>
<font color="#000000">Оценка на сложността на следните цикли (колко
пъти ще се изпълни цикъла в най-лошия случай):</font>
<br>
<p><b><tt><font color="#000099">/</font><font color="#006600">/ 1</font></tt></b>
<br>
<b><tt><font color="#006600">for (i = 0; i &lt; n; i++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;for (j = 0; j &lt; n; j++, sum++);</font></tt></b>
<br>
<b><tt><font color="#006600">// 2</font></tt></b>
<br>
<b><tt><font color="#006600">for (i = 0; i &lt; n; i++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;for (j = 0; j &lt; n; j++) if
(a[i] == b[j])
return;</font></tt></b>
<br>
<b><tt><font color="#006600">// 3</font></tt></b>
<br>
<b><tt><font color="#006600">for (i = 0; i &lt; n; i++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;for (j = 0; j &lt; n; j++) if
(a[i] != b[j])
return;</font></tt></b>
<br>
<b><tt><font color="#006600">// 4</font></tt></b>
<br>
<b><tt><font color="#006600">for (i = 0; i &lt; n; i++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;for (j = 0; j &lt; n; j++) if
(a[i] == a[j])
return;</font></tt></b>
<br>
<b><tt><font color="#006600">// 5</font></tt></b>
<br>
<b><tt><font color="#006600">for (i = 0; i &lt; n; i++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;for (j = 0; j &lt; i; j++) sum++;</font></tt></b>
<br>
<b><tt><font color="#006600">// 6</font></tt></b>
<br>
<b><tt><font color="#006600">for (i = 0; i &lt; n; i++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;for (j = 0; j &lt; n*n; j++) sum++;</font></tt></b>
<br>
<b><tt><font color="#006600">// 7</font></tt></b>
<br>
<b><tt><font color="#006600">for (i = 0; i &lt; n; i++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;for (j = 0; j &lt; i*i; j++) sum++;</font></tt></b>
<br>
<b><tt><font color="#006600">// 8</font></tt></b>
<br>
<b><tt><font color="#006600">for (i = 0; i &lt; n; i++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;for (j = 0; j &lt; i*i; j++)</font></tt></b>
<br>
<b><tt><font color="#006600">&nbsp;&nbsp; for (k = 0; k &lt; j*j; k++)
sum++;</font></tt></b>
<br>
</p>
<hr style="width: 100%; height: 2px;"><span style="font-weight: bold;"></span>
<h4>Логаритмична сложност.
</h4>
<p>&nbsp;&nbsp;&nbsp; Да разгледаме цикъла:
<br>
<b><tt><font color="#006600">for (sum = 0, i = 0; i &lt; n; i *= 2)
sum++;</font></tt></b>
<br>
Променливата <b><tt>i</tt></b> приема стойности 1, 2, 4, ..., 2<i><sup>k</sup></i>,
...&nbsp;
докато
надмине
<b><tt>n</tt></b>. Цикълът се изпълнява [log <i>n</i>]
пъти. Сложността е <i>O</i>(log <i>n</i>).
</p>
<p>&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">Изчисляване на
сложност при рекурсия.</span><br>
<span style="font-weight: bold;">Пример:</span> Двоично търсене -
рекурсивен алгоритъм.
<br>
&nbsp;&nbsp;&nbsp; Броим обръщенията към елементите на масива. В
рекурсивната функция
се разглежда средния елемент и се прави едно рекурсивно извикване с два
пъти по-малък масив. Следователно, ако <i>T</i>(<i>n</i>) е функцията,
която задава броя на обръщенията, то <i>T</i>(<i>n</i>) = <i>T</i>(<i>n/</i>2)
+
1.
От
равенствата
<br>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
T</i>(<i>n</i>) = <i>T</i>(<i>n/</i>2) + 1 = <i>T</i>(<i>n/</i>4) + 2
=
<i>T</i>(<i>n/</i>8)
+ 3 = ... = <i>T</i>(<i>n/</i>2<i><sup>k</sup></i>) + <i>k</i>
<br>
получаваме за <i>n</i> = 2<i><sup>k</sup></i>, че&nbsp;<i> T</i>(<i>n</i>)
=
<i>T</i>(1) + log <i>n</i>, т.е. сложността на алгоритъма е <i>O</i>(log
<i>n</i>).
</p>
&nbsp;&nbsp;&nbsp; Най-добър случай, най-лош случай, обща сложност.<br>
&nbsp;&nbsp;&nbsp; Проблеми при асимптотичната нотация [1.4.11]
<br>
<br>
<span style="font-weight: bold;">Проблеми на асимптотичната нотация -
зависимост от входните данни</span><br>
<ul>
  <li>най-лошия случай</li>
  <li>най-добрия случай</li>
  <li>средния случай</li>
</ul>
<hr width="100%">
</body>
</html>
