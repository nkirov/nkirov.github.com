<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="GENERATOR" content="Mozilla/4.75 [en] (Win98; U)
      [Netscape]">
    <title>Тest 2</title>
  </head>
  <body>
    <center>
      <h3>ТЕСТ 2 </h3>
      <p><b>( въпросите на теста, един верен и един грешен отговор</b> )<br></p>
    </center>
    <hr width="100%" size="2">Дадени са свързан списък и итератор:<br>
    &nbsp;&nbsp; <big><tt> list&lt;int&gt; bip;</tt></big><big><tt><br>
        &nbsp;list&lt;int&gt;::iterator it;</tt></big> <br>
    Списъкът съдържа 10 елемента и итераторът сочи втория елемент на
    свързания списък. Верни ли са (синтактично и/или логически) дадените
    изрази?<br>
    (да) <big><tt>*it &gt; 0</tt></big><br>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
p, li { white-space: pre-wrap; }
</style>
    <meta name="qrichtext" content="1">
    (не)<big><tt> *it != *bip.end()<br>
      </tt></big>&nbsp;<br>
    <hr width="100%" size="2"> Верни ли са твърденията за достъп на
    член-функции от един клас до членове на друг клас за класовете,
    дефинирани във файла <tt>list2.cpp</tt>? <br>
    (да) Член-функциите на класа <big><tt>List</tt></big> имат достъп
    до частните членове на класа <big><tt>Node</tt></big>. <br>
    (не) Член-функциите на класа <big><tt>Iterator</tt></big> имат
    достъп до частните членове на класа <big><tt>List</tt></big>.<br>
    <br>
    <hr width="100%" size="2"> Даден е свързан списък от цели числа,
    състоящ се от 3 елемента. Полето <big><tt>next</tt></big> сочи към
    следващия елемент, полето <big><tt>prev</tt></big> - предишния
    елемент от списъка, а <big><tt>h </tt></big>е указател за началото
    на списъка. <br>
    &nbsp;&nbsp; <big><tt>struct Item </tt><tt> </tt></big><br>
    &nbsp;&nbsp; <big><tt>{ </tt></big><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <big><tt> Item *next, *prev;
        int data; </tt></big><br>
    &nbsp;&nbsp; <big><tt>}; </tt></big><br>
    &nbsp;&nbsp; <big><tt>Item *h;</tt></big> <br>
    Определете верните и неверните твърдения. <br>
    (да) <big><tt>(h-&gt;next)-&gt;next</tt></big> е адресът на
    последния елемент от списъка. <br>
    (не) <big><tt>(h-&gt;next)-&gt;prev</tt></big> е <big><tt>NULL</tt></big>.<br>
    <br>
    <hr width="100%" size="2"> Определете верните и неверните дефиниции
    и твърдения за структури от данни и свързан списък. <br>
    (да) Опашката е линейна структура от данни. <br>
    (не) Стекът е нелинейна структура от данни. <br>
    <meta name="qrichtext" content="1">
    <br>
    <hr width="100%" size="2"> Посочете верните и грешни твърдения от
    текста на програмата <tt>list2.cpp</tt> за реализация на свързан
    списък.<br>
    (да) Операторът <big><tt>friend class List;</tt></big> в
    дефиницията на класа <big><tt>Node</tt></big> дава достъп на
    член-фукциите на класа <big>List</big> до частните членове на класа
    <big><tt>Node</tt></big>.<br>
    (не) <big><tt>class Iterator;</tt></big> е оператор за дефиниране
    на класа <big><tt>Iterator.<br>
        <br>
      </tt></big>
    <hr width="100%" size="2">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
p, li { white-space: pr</style>Проверете твърденията за стандартната
    библиотека шаблони (STL) на езика С++. <br>
    (да) Контейнерът <big><tt>map</tt></big> осигурява пряк и ефективен
    достъп до елементите. <br>
    (не) Контейнерът <big><tt>list </tt></big>осигурява пряк достъп
    (операция индекс) до елементите на свързания списък. <br>
    <br>
    <hr width="100%" size="2">
    <meta name="qrichtext" content="1">
    Отбележете верни и грешни твърдения относно сортиране и търсене.<br>
    (да) За метода сортиране чрез избор удвояване на броя на елементите
    води до четирикратно учеличаване на времето за сортиране.<br>
    (не) За метода сортиране чрез сливане удвояване на броя на
    елементите води до четирикратно учеличаване на времето за сортиране.<br>
    <br>
    <hr width="100%" size="2">
    <meta name="qrichtext" content="1">
    Ако 10000 записа се сортират за 4 секунди от двата метода за
    сортиране (избор и сливане), то<br>
    (да) методът сортиране чрез сливане ще сортира 1000000 записа за
    около 10 минути.<br>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
p, li { white-space: pre-wrap; }</style>
    <meta name="qrichtext" content="1">
    (не) методът сортиране чрез избор ще сортира 1000 записа за повече
    от 1 секунда.<br>
    <br>
    <meta name="qrichtext" content="1">
    <hr width="100%" size="2"> Намерете броят <i>N</i>(<i>b</i>) на
    посещенията на елементите на масива<br>
    <big><tt>int a[10] = {14,43,76,100,115,290,400,511,512,601};</tt></big><br>
    необходими за намиране на стойност <i>b</i> при прилагане на
    алгоритъма за двоично търсене. Отговорете със стойността на
    математическия израз <i>N</i>(<i>b</i>) mod 2 за дадените стойности
    на <i>b</i>. <br>
    (0) <i>b </i>= 90<br>
    (1)<i> b</i> = 10<br>
    <br>
    <meta name="qrichtext" content="1">
    <hr width="100%" size="2"> Пребройте посещенията на елементите на
    дадения масив, необходими за сортиране на масива по метода сортиране
    чрез избор и отбележете с ,,да'', ако този брой съвпада с числото,
    написано след елементите на масива.<br>
    (да) {5, 8, 7} 7<br>
    (не) {5, 7, 8} 7<br>
    <br>
    <hr width="100%" size="2">
    <meta name="qrichtext" content="1">
    Отбележете с ,,да'' случаите, когато числото в скобите е броят на
    размените (swap) в алгоритъма за сортиране чрез селекция на дадения
    масив.<br>
    (да) {1, 2, 4, 5} (0)<br>
    (не) {1, 4, 2, 5} (2)<br>
    <br>
    <meta name="qrichtext" content="1">
    <hr width="100%" size="2">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
p, li { white-space: </style>Посочете верните твърдения за параметрите
    на функциите, предефиниращи операции и за аргументите на самите
    предефинирани операции.<br>
    (да) Първият на аргумент на предефинирана операция с член-функция е
    текущият обект.<br>
    (не) Унарна операция се предефинира с член-функция с един&nbsp;
    параметър.<br>
    <br>
    <hr width="100%" size="2">Отбележете верни/неверни твърдения за
    предефиниране на операции.<br>
    (да) Операция се предефинира като са дeфинира функция с име <font
      size="+1"><tt>operator</tt></font> и знака на операцията.<br>
    (не) Функцията <font size="+1"><tt>Time&amp; operator++(Time&amp;)</tt></font>
    предефинира постфиксната операция ++ за обекти от клас <font
      size="+1"><tt>Time</tt></font>. <br>
    <br>
    <hr width="100%" size="2"> Разгледайте главната функция на
    програмата, дадена във файла <font size="+1"><tt>overload.cpp</tt></font>
    и отбележете с "да" изразите, в които има предефинирана операция. <br>
    (да) <font size="+1"><tt>now + 1000</tt></font> <br>
    (не) <font size="+1">cout &lt;&lt; "Another "<br>
      <br>
    </font>
    <hr width="100%" size="2">Възможно ли е да се предефинира следващата
    операция за обекти от класа <font size="+1"><tt>Time</tt></font>,
    като използваме следната декларация на обикновена функция?<br>
    (не) <font size="+1"><tt>bool operator&gt;(Time);</tt></font><br>
    (да) <font size="+1"><tt>long operator-(Time, Time); <br>
        <br>
      </tt></font>
    <hr width="100%" size="2">Възможно ли е да се предефинира следващата
    операция за обекти от класа <tt>Time</tt>_new, като използваме
    следната декларация на член-функция?<br>
    (да) <font size="+1"><tt>bool Time</tt></font><font size="+1"><tt>_new::operator==(Time</tt></font><font
      size="+1"><tt>_new);</tt></font><br>
    (не)<tt> <font size="+1">istream&amp; Time</font></tt><tt><font
        size="+1">_new::operator&gt;&gt;(Time</font></tt><tt><font
        size="+1">_new&amp;);<br>
        <br>
      </font></tt>
    <hr width="100%" size="2">
  </body>
</html>
