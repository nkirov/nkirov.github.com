<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>lec3</title>
  </head>
  <body>
    <h3>3. Динамично оптимиране - други задачи </h3>
    <a href="../../../2014/NETB151/sources/ch16/map.cpp"><span
        style="font-family: monospace;"></span></a>**Домино подредица
    [8.4.12, стр. 541] <br>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    Домино-редица ще наричаме редица от естествени числа, за която
    най-старшата цифра на i-тия член съвпада с най-младшата на
    (i–1)-ия. <br>
    <i>Пример 1: </i><br>
    34 402 2 29 91 11 1<br>
    Задача: По зададена редица X(n)&nbsp; x<sub>1</sub>, x<sub>2</sub>,
    ..., x<sub>n</sub> от естествени числа да се намери нейна
    максимална по дължина домино-подредица.<br>
    <i>Пример 2:</i><br>
    &nbsp;25 62 36 51 12 6 33 22 <br>
    [1&nbsp;&nbsp; 2&nbsp;&nbsp; 3&nbsp;&nbsp; 4&nbsp;&nbsp;
    5&nbsp;&nbsp; 6&nbsp; 7&nbsp;&nbsp; 8]<br>
    Да разгледаме редицата X(k)&nbsp; x<sub>k</sub>, x<sub>k+1</sub>,
    ..., x<sub>n</sub>. С F(i, k) означаваме максималната дължина на
    домино-редица, подредица на X(k),&nbsp; и с първа цифра i на първия
    член на домино-редицата.<br>
    i = 0, 1, 2, ...., 9; k = 1, 2, ..., n<br>
    <i>Пример 2:</i><br>
    F(1, 8) = F(1, 7) = F(1, 6) = 0;&nbsp; F(1, 5) = F(1, 4) = F(1, 3) =
    F(1, 2) = F(1, 1) = 2; 12 22<br>
    F(2, 8) = F(2, 7) = F(2, 6) =&nbsp; F(2, 5) = F(2, 4) = F(2, 3) =
    F(2, 2) = 1, F(2, 1) = 4; 25 51 12 22<br>
    ...<br>
    Решението на задачата ще бъде най-голямото от числата F(1, 1), F(2,
    1), ..., F(9, 1).<br>
    Означаваме с l(k) първата цифра на числото x<sub>k</sub> и с r(k) -
    последната цифра на x<sub>k</sub>.<br>
    F(i, k) = F(i, k + 1), ако l(k) != i;<br>
    F(i, k) = max{F(i, k + 1), 1 + F(r(k), k + 1)}, ако&nbsp; l(k) = i;<br>
    F(i, 1) е или 0 или 1.<br>
    <i>Пример 2:<br>
    </i>F(1, 5) = max{F(1, 6), 1 + F(2, 6)} = 2<br>
    F(2, 1) = max{F(2, 2), 1 + F(5, 2)} = 4<br>
    <title>Програмиране = ++Алгоритми; (Programming = ++Algorithms;)</title>
    <hr style="width: 100%; height: 2px;"> ** Разстояние на Левенщайн
    [Edit distance, AL p. 74]<br>
    <br>
    Задача B.<br>
    <a
      href="https://www.hackerrank.com/nbu-january-2020-programming-contest">https://www.hackerrank.com/nbu-january-2020-programming-contest</a><br>
    <br>
    Разстояние на Левенщайн между два низа е минималният брой операции
    за редактиране, необходими за преобразуване на низ в друг низ.
    Операциите за редактиране са:<br>
    • insert - добавя символ (например ABC -&gt; ABCA)<br>
    • remove - изтрива символ (например ABC -&gt; AC)<br>
    • modify - замества един символ с друг (например ABC -&gt; ADC)<br>
    Например разстоянието между LOVE и MOVIE е 2, защото можем първо да
    извършим операцията LOVE -&gt; MOVE (modify) и след това операцията
    MOVE -&gt; MOVIE (insert). Това е най-малкият възможен брой
    операции, защото е ясно, че само една операция не е достатъчна.<br>
    Да се напише прогрома за пресмятане на разстоянието на Левенщайн
    между два низа, не съдържащи интервали.<br>
    <br>
    Input Format<br>
    За всеки тестов пример на стандартния вход на един ред са дадени два
    низа.<br>
    <br>
    Constraints<br>
    Дължините на низовете са не по-големи от 1000.<br>
    <br>
    Output Format<br>
    За всеки тестов пример на стандартния изход да се отпечати едно
    число на отделен ред - полученото от програмата разстояние.<br>
    <br>
    Sample Input 0<br>
    alabala balaala<br>
    abcd xy<br>
    <br>
    Sample Output 0<br>
    2<br>
    4<br>
    <hr size="2" width="100%"><br>
  </body>
</html>
