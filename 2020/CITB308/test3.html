<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>test3</title>
  </head>
  <body>
    <h3>Тест 3</h3>
    Отбележете верни и грешни твърдения за речник АТД.<br>
    (да) Речник с пълна наредба на ключовете наричаме нареден речник. <br>
    (не) Реализация на речник АТД с наредена редица се нарича log файл.
    <hr> Даден е нареден речник АТД с n елемента. Отбележете
    вярно/невярно ли е даденото съответствие: <br>
    реализация - функция - асимптотична оценка. <br>
    (да) Log File - <font size="+1"><tt>keys</tt></font> - <i>O</i>(<i>n</i>)
    <br>
    (не) Lookup Table - <font size="+1"><tt>findAll</tt></font> - <i>O</i>(1)






    <hr size="2" width="100%"> Даден е нареден речник АТД <i>с n</i>
    елемента, реализиран с хеш таблица. Отбележете вярно/невярно ли е
    даденото съответствие: функция - асимптотична оценка. <br>
    (да) <tt><font size="+1">keys</font> </tt>- <i>O</i>(<i>n</i>) <br>
    (не) <tt><font size="+1">elements</font> </tt>-<i> O</i>(1)
    <hr size="2" width="100%">Прост алгоритъм за разрешаване на колизии
    в хеш таблици e линейно пробване. Даден е клетъчен масив <br>
    &nbsp;&nbsp;&nbsp; A = { 35,14,D,21,E,12,E } <br>
    с капацитет N=7, където E означава empty и D означава available
    елемент на масива. Хеш функцията e <i>h</i>(<i>k</i>) = <i>k</i>
    mod 7. Посочете верни/неверни съответствия, като след -&gt; е дадено
    предполагаемото място на добавения елемент в масива. <br>
    (да) <font size="+1"><tt>insrtItem(7)</tt></font> -&gt; A[2] = 7 <br>
    (не) <font size="+1"><tt>insrtItem(18)</tt></font> -&gt; A[5] = 18<br>
    <hr size="2" width="100%">Двойно хеширане е метод за решаване на
    колизии в хеш таблици.&nbsp; Дадена е следната редица от ключове:
    18, 11, 4, 10, 8, 15, клетъчен масив с дължина <i>N</i>, <br>
    хеш функция <i>h</i>(<i>x</i>) = <i>x</i> mod <i>N</i> и втора
    хеш функция <i>d</i>(<i>k</i>) = <i>M</i> - <i>k</i> mod <i>M</i>.
    <br>
    При зададени стойности на <i>N</i> и <i>M</i> определете дали
    правилно са разположени дадените ключове в клетъчния масив.<br>
    (да) <i>N</i> = 7, <i>M</i> = 5&nbsp; <tt>- <font size="+1">8 11
        0 10 18 4 15</font></tt><br>
    (не) <i>N</i> = 14, <i>M</i> = 5 <tt>- <font size="+1">15 0 0 0
        18 4 0 0 8 0 10 11 0 0</font></tt><br>
    <hr size="2" width="100%">Класът <font size="+1"><tt>BinarySearchTree</tt></font>
    съдържа следната член-функция (Code Fragment 9.3): <br>
    <font size="+1"><tt>void setItem(const BTPosition&amp; p, const
        BSTItem&amp; i) const </tt><tt><br>
      </tt><tt>{ </tt><tt><br>
      </tt><tt>&nbsp; /*add*/ </tt><tt><br>
      </tt><tt>&nbsp; p.element().setKey(i.key()); </tt><tt><br>
      </tt><tt>&nbsp; p.element().setElement(i.element()); </tt><tt><br>
      </tt><tt>} </tt></font><br>
    Отбележете верни/неверни твърдения за тази функция. <br>
    (да) Функцията поставя<font size="+1"><tt> Item</tt></font> от BST
    (речник) на позиция <font size="+1"><tt>p</tt></font> в <font
      size="+1"><tt>LinkedBinaryTree</tt></font>. <br>
    (не) Като заместим <font size="+1"><tt>/*add*/</tt></font> с <font
      size="+1"><tt>p.isNull(); </tt></font>получаваме синтактична
    грешка.<br>
    <hr size="2" width="100%">Дадено е AVL дърво: <br>
    <font size="+1"><tt>&nbsp; 44(17(-,32),78(50(48,62),88)). </tt></font><br>
    Външните възли не са включени в представянето. Определете дали
    даденото след операцията AVL дърво е получено като резултат от
    прилагане на операцията. <br>
    (да) <font size="+1"><tt>insertItem(54)
        44(17(-,32),62(50(48,54),78(-,88))) </tt></font><br>
    (не) <font size="+1"><tt>remove</tt></font><font size="+1"><tt><font
          size="+1"><tt>Element</tt></font>(32) 44(17,78(50(48,62),88))</tt></font><br>
    <hr size="2" width="100%">Класът <font size="+1"><tt>Position</tt></font>
    e включен в дефиницията на класа <font size="+1"><tt>BinarySearchTree</tt></font>
    (Code Fragment 9.2). Отбележете верни/неверни твърдения за
    член-функцията <br>
    <font size="+1"><tt>Element&amp; element() </tt><tt><br>
      </tt><tt>{ </tt><tt><br>
        &nbsp; </tt><tt>return btPos.element().element(); </tt><tt><br>
      </tt><tt>} </tt><tt><br>
      </tt><tt>от class Position. </tt></font><br>
    (да) Върнатата стойност е псевдоним на член-данна на класа <font
      size="+1"><tt>Item</tt></font>. <br>
    (не) Функцията е рекурсивна. <br>
    <hr size="2" width="100%">Разгледайте частта от реализацията на AVL
    дървета, дадена в <font size="+1"><tt>Code Fragment: AVLTree1</tt></font>
    и определете следните твърдения като "верни" или "грешни".<br>
    (да) Всеки обект от клас <font size="+1"><tt>AVLTree&lt;K,E&gt;</tt></font>
    е обект от клас <font size="+1"><tt>BinarySearchTree&lt;K,E,Item&lt;K,E&gt;






        &gt;</tt></font>.<br>
    (не) Функцията <font size="+1"><tt>height(p)</tt></font> връща
    височината на двоичното дърво.<br>
    <hr size="2" width="100%">Посочете верни/неверни дефиниции и
    твърдения за търсещи дървета. <br>
    (да) Търсене в AVL дърво с <i>n</i> члена отнема време <i>O</i>(log







    <i>n</i>). <br>
    (не) Височината на AVL дърво, съдържащо <i>n</i> ключа е <i>O</i>(<i>n</i>).<br>
    <hr size="2" width="100%">Дадено е (2,4) дърво: T =
    {12}({3,6,9},{15}). Външните възли не са включени в представянето.
    Определете дали след прилагане на дадената функция ще се получи
    даденото дърво.<br>
    (да) <font size="+1"><tt>insertItem(1)</tt></font> -
    T={6,12}({1,3}, {9},{15})<br>
    (не) <font size="+1"><tt>insertItem(1) </tt></font>-
    T={3,12}({1,6,9},{15})<br>
    <hr size="2" width="100%">Дадено е (2,4) дърво: T =
    {10,15,24}({2,8},{12},{18}, {27,32,35}). Външните възли не са
    включени в представянето. Определете дали даденото&nbsp; дърво е
    получено като резултат от&nbsp; прилагане на дадената операция.<br>
    (да) <font size="+1"><tt>removeElement(24)</tt></font> -
    T={10,15,27}({2,8},{12},{18},{32,35})<br>
    (не) <font size="+1"><tt>removeElement(2)</tt></font> -
    T={10,15,24}({8,12},{18},{27,32,35})<br>
    <hr size="2" width="100%">
    <meta name="qrichtext" content="1">
    Дадено е <i>червено</i>-<b>черно</b> дърво АТД, като <b>черните</b>
    възли са <b>bold</b>, а <i>червените</i> - <i>italic</i>.
    Външните възли не са включени в представянето. Определете дали
    даденото след операцията <i>червено</i>-<b>черно</b> дърво е
    получено като резултат от прилагане на операцията. <br>
    (да) <b>6</b>(<i>8</i>) - <font size="+1"><tt>insertItem(7)</tt></font>
    - <b>7</b>(<i>6</i>,<i>8</i>) <br>
    (не) <b>5</b>(<i>7</i>) - <font size="+1"><tt>insertItem(6)</tt></font>
    - <b>5</b>(<i>6</i>,<i>7</i>) <br>
    <hr size="2" width="100%">Дадено е <i>червено</i>-<b>черно</b>
    дърво АТД, като <b>черните</b> възли са <b>bold</b>, а <i>червените</i>
    - <i>italic</i>. Външните възли не са включени в представянето.
    Определете дали даденото след операцията <i>червено</i>-<b>черно</b>
    дърво е получено като резултат от прилагане на операцията <font
      size="+1"><tt>removeElement</tt></font>.<br>
    (да) <b>4</b>(<b>2</b>,<b>7</b>(<i>6</i>)) - <font size="+1"><tt>removeElement(6)</tt></font>
    - <b>4</b>(<i>2</i>,<i>7</i>) <br>
    (не) <b>4</b>(<b>2</b>,<b>7</b>(<i>6</i>)) - <font size="+1"><tt>removeElement(2)</tt></font>
    - <b>4</b>(<i>6</i>,<i>7</i>) <br>
    <hr size="2" width="100%"><cg(n) за="" n=""><cg(n)$ за="" всяко=""
        $n="">Разгледайте кода от <font size="+1"><tt>Code Fragment:
            RBTree3</tt></font> и определете дали следните твърдения са
        верни.<br>
        (да) Функцията <font size="+1"><tt>parent</tt></font> е
        дефинирана в класа, реализиращ двоично дърво АТД.<br>
        (не) Функцията <font size="+1"><tt>setBlack</tt></font> е
        дефинирана в базовия клас.<br>
        <hr size="2" width="100%"></cg(n)$></cg(n)>
  </body>
</html>
