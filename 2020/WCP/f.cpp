/*
 connect.cpp
 Свързани компоненти на неориентиран граф
 
Фериботни линии
Архипелагът Островландия се състои от няколко острова. Всеки остров има поне една фериботна връзка с някой друг остров. Амбициозен владетел на островите решил да разшири фериботната мрежа така, че от всеки до всеки остров да може да се отида с един или с няколко ферибота, т.е. с няколко прекачвания на други острови. Задачата е колко нови фериботни линии трябва да бъдат открити.
 
 Вход
 Всеки пример започва с число n - броя на пътуващите фериботи. Следват n реда, като на всеки ред са дадени трибуквените кодовете на двата острова, свързани с този ферибот. Азбуката на Островландия се състои от 25 букви, за означаването на които ще използваме малките букви от латинската азбука, без буквата z. От тези букви са съставени и кодовете на островите.
 
 Ограничения
 1 < n < 10000
 
 Изход
 За всеки тестов пример на стандартния вход да се изведе броя на новите фериботни линии, които трябва да се открият, за да се изпълни желанието на вледетеля.
 
 ПРИМЕР
Вход
2
gen fen
jar far

Изход
1
 
 15625 = 25*25*25 върха на графа
 15625*15625 =    244 140 625
 max unsigned int 4 294 967 295
 4.777s
*/
// DFS
#include <iostream>
#include <string>
#define MAXN 20000
using namespace std;

char a[MAXN][MAXN];
char used[MAXN];
int n;

void DFS(unsigned i)
{
    unsigned k;
    used[i] = 1;
//    cout << i + 1 << " ";
    for (k = 0; k < n; k++)
        if (a[i][k] && !used[k]) DFS(k);
}

string ver[MAXN];

int conv(string s)
{
    int i = 0;
    while(i < n && s != ver[i]) i++;
    if (i == n)
    {
        ver[n] = s; n++;
    }
    return i;
}
void printa()
{
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < n; j++) cout << int(a[i][j]) << " ";
        cout << endl;
    }
}

int main()
{
    int m;
    while(cin >> m)
    {
        n = 0;
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < n; j++) a[i][j] = 0;
            used[i] = 0;
        }
        for(int i = 0; i < m; i++)
        {
            string s1, s2;
            cin >> s1 >> s2;
//            cout << s1 << " " << s2 << endl;
            a[conv(s1)][conv(s2)] = 1;
            a[conv(s2)][conv(s1)] = 1;
        }
//        printa();
        int num = 0;
        for(int i = 0; i < n; i++)
            if (used[i] == 0)
        {
            num++; DFS(i);
        }
        cout << num << endl;
    }
    return 0;
}
